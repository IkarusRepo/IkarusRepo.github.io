{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the documentation of Ikarus","text":"<p>This project tries to provide an easy-to-read and an easy-to-use finite element framework. It is heavily inspired by the finite element software DUNE, the book DUNE \u2014 The Distributed and Unified Numerics Environment, deal.II and Kratos. Furthermore, it directly uses several modules from DUNE.</p> <p>The design of CI and the documentation were inspired by Autodiff  and Kratos.</p> <p>The documentation is built using Material for MkDocs.</p> <p>Ikarus provides the tools to create one's own examples and rapidly prototype finite element solution algorithms. This is done by using template metaprogramming in C++ to write generic code, which is compiled for the particular example.</p> <p>Look at our blog to see what we are currently working on: Blog</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#what-is-ikarus","title":"What is Ikarus?","text":"<p>Ikarus is a project developed by the Institute for Structural Mechanics, University of Stuttgart. It strives to develop an easy-to-read and easy-to-use framework to perform finite element analysis. It acts as a front-end code that utilizes several modules from DUNE and has some other dependencies.</p> <p></p> <p>Ikarus endeavors to not reinvent the wheel but to just provide a generic interface that makes use of the existing modules, resulting in a more expressive, modular library to solve partial differential equations. The main idea is to provide users with a platform to rapidly prototype their ideas, thereby enabling researchers across the world to quickly test their various theories. One of the major principles that we follow is \"take what you need,\" where the users can pick different functionalities as per their requirements to try out their own examples. We also provide certain examples that can help a user get familiar with Ikarus. Ikarus itself is written in C++, but it also comes with Python bindings, which can then aid in combining the functionalities of Ikarus with different Python packages. It uses C++ template (meta) programming to achieve a general and easy-to-extend library. The idea of interface segregation between a grid space and an ansatz space from DUNE is heavily exploited here. Some of the features that we provide are</p> <ul> <li>Element library (linear elastic, nonlinear elastic, Kirchhoff-Love Shell, truss)</li> <li>Material library (St. Venant-Kirchhoff, Neo-Hookean)</li> <li>Nonlinear Solvers (Newton-Raphson Method, Trust region Method)</li> <li>Assemblers for sparse and dense matrices</li> <li>Control routines (load control, displacement control, arc-length control)</li> <li>Handle Dirichlet boundary conditions</li> <li>Observer patterns to log user-desired information as an output</li> </ul>"},{"location":"about/#dependencies","title":"Dependencies","text":"<p>Bug</p> <p>This section will be updated.</p>"},{"location":"about/#ikarus-core-developers","title":"Ikarus Core Developers","text":"<p>The Ikarus Core Developers develop, maintain and look after Ikarus.</p> <ul> <li>Alexander M\u00fcller</li> <li>Tarun Kumar Mitruka Vinod Kumar Mitruka</li> <li>Henrik Jakob</li> </ul>"},{"location":"about/#talks","title":"Talks","text":"<ul> <li>Jakob, H., Vinod Kumar Mitruka, T.\u00a0K.\u00a0M., M\u00fcller, A.   Ikarus and dune-iga: Easy-To-Use C++ Libraries With Python Bindings for Structural Analysis Within DUNE.   9<sup>th</sup> European Congress on Computational Methods in Applied Sciences and Engineering (ECCOMAS),   Lisbon, Portugal, June 03\u201307, 2024.</li> <li>Jakob, H., Vinod Kumar Mitruka, T.\u00a0K.\u00a0M., M\u00fcller, A.   Ikarus and dune-iga: Easy-To-Use C++ Libraries With Python Bindings.   FE im Schnee 2024,   Hirschegg, Austria, March 17\u201320, 2024.</li> <li>M\u00fcller, A., Jakob, H., Vinod Kumar Mitruka, T.\u00a0K.\u00a0M., Sander, O., Bischoff, M.   Ikarus with dune-iga: An open-source C++ library for Isogeometric Analysis within the Dune framework.   11<sup>th</sup> International Conference on Isogeometric Analysis 2023 (IGA 2023),   Lyon, France, June 18\u201321, 2023.</li> </ul>"},{"location":"about/#datasets","title":"Datasets","text":"<p>Different versions of Ikarus are released via the Data Repository of the University of Stuttgart (DaRUS).</p> <ul> <li>Ikarus v0.4</li> <li>Ikarus v0.3</li> </ul>"},{"location":"about/#how-to-cite-us","title":"How to cite us?","text":"<p>Here is the BibTex entry for our latest dataset:</p> <pre><code>@data{Ikarusv04_2024,\nauthor    = {M\u00fcller, Alexander and Vinod Kumar Mitruka, Tarun Kumar Mitruka and Jakob, Henrik},\npublisher = {DaRUS},\ntitle     = {Ikarus v0.4},\nyear      = {2024},\nversion   = {V1},\ndoi       = {10.18419/darus-3889}\n}\n</code></pre>"},{"location":"download/","title":"Installation of Ikarus","text":"<p>Change links on this website when final accounts for repository and docker container are fixed and remove this warning.</p> <p>Graphical output is currently not supported on Windows 10 (but will probably be available in the future). Therefore, working on Windows 11 is recommended.</p> <p>The installations on Windows relies on WSL 2, i.e. although working with Windows, the code is compiled and executed in Linux.</p>"},{"location":"download/#installation-on-windows-using-docker-container-and-clion","title":"Installation on Windows using Docker Container and Clion","text":"<ol> <li> <p>Install WSL: Open the PowerShell as an admin and execute the following commands. Reboot afterwards, if requested.</p> <pre><code>wsl --install\nwsl --set-default-version 2 #(Is not needed for Windows 11)\n</code></pre> </li> <li> <p>Download and install Docker for Windows.   During the installation, select the option \"Install required Windows components for WSL 2\"</p> </li> <li>Install debian from WindowsAppStore<ol> <li>Open the debian app</li> <li>Give yourself a username and password</li> <li>Close the debian app</li> </ol> </li> <li> <p>Open the PowerShell and execute:</p> <pre><code>wsl --list --all\n# `Debian` should appear as one of the available Linux distributions.\n</code></pre> </li> <li> <p>In the PowerShell execute:</p> <pre><code>wsl --setdefault Debian\n</code></pre> </li> <li> <p>Try to start Docker. If it works, continue with the next step. If a message occurs that you are not allowed to use docker because     you are not in the docker user group, follow these instructions.     In short:</p> <ol> <li>Open computer management as admin</li> <li>Go to Local users and groups and find docker-users</li> <li>Add your Account (or a group of which you are a member) to the group.</li> <li>Restart your computer</li> </ol> </li> <li>In Docker, go to Settings \u2192 General and select autostart for docker     (otherwise you have to start it manually each time you want to work with Ikarus).</li> <li> <p>In the Docker settings, select that Docker uses your WSL2 distribution Debian as shown in the picture.          In cases docker says that you don't have a WSL 2 distribution, go to the PowerShell and execute</p> <pre><code>wsl --set-default-version 2 #(just to be sure that you didn't forgot this at the beginning)\nwsl --set-version Debian 2 #(Converts debian to version 2)\n</code></pre> <p>You should now be able to change the docker settings according to the picture above. 9. Open the PowerShell and execute:</p> <pre><code>docker pull ikarusproject/ikarus-dev:latest #if you want to develop in Ikarus\ndocker pull ikarusproject/ikarus:latest #if you want to use Ikarus to run your own main file as in https://github.com/ikarus-project/ikarus-examples\n</code></pre> </li> <li> <p>Download and install CLion. You need a version &gt;=2022.1.</p> </li> <li> <p>In CLion, go to File and Settings and apply the following settings for the toolchain:          Edit the Container settings and paste the following command into <code>Run options</code>:</p> <pre><code>-e DISPLAY=:0 -v \\\\wsl$\\debian\\mnt\\wslg\\.X11-unix:/tmp/.X11-unix -v \\\\wsl$\\debian\\mnt\\wslg:/mnt/wslg --cap-add=SYS_PTRACE\n</code></pre> </li> </ol>"},{"location":"download/#clone-ikarus","title":"Clone Ikarus","text":"<ul> <li>Clone the Ikarus repository.</li> <li>Open the <code>CMake</code> tab in the CLion footer:   </li> <li>Click on <code>Reload CMake project</code> (refresh symbol):   </li> <li>CMake now detects all required sources automatically. The output should look similar to   the screenshot below:   </li> </ul>"},{"location":"download/#installation-on-linux","title":"Installation on Linux","text":"<ol> <li> <p>If you have docker available, simply pull the container with Ikarus installed to start developing.</p> <pre><code>docker pull ikarusproject/ikarus:latest\n</code></pre> </li> <li> <p>Log in to the container via</p> <pre><code>docker container run -it --entrypoint /bin/bash  ikarusproject/ikarus:latest\n</code></pre> </li> <li> <p>Instead of point 2, one can now also follow the documentation above if Clion on Linux is preferred.</p> </li> </ol>"},{"location":"gallery/","title":"Gallery","text":"<p>In the future, several figures from simulations performed via Ikarus will be found here.</p>"},{"location":"01_framework/","title":"Framework","text":"<pre><code>classDiagram\n  GridView &lt;-- Grid\n  GlobalBasis &lt;-- GridView\n  Assembler &lt;-- GlobalBasis\n  NonlinearOperator &lt;-- Assembler\n  Assembler &lt;-- FiniteElement\n  FiniteElement &lt;-- FERequirements\n  FERequirements &lt;|-- ResultRequirements\n  FiniteElement &lt;-- ResultRequirements\n  FiniteElement &lt;-- Local function\n  Localfunction &lt;-- Localbasis\n  GlobalBasis &lt;--&gt; Localbasis\n  Localfunction &lt;-- Manifold\n  NonlinearSolver &lt;-- NonlinearOperator\n  NonlinearSolver &lt;-- LinearSolver\n  Controlroutine &lt;-- NonlinearSolver\n  VTKWriter &lt;-- Controlroutine\n  DirichletConditions .. Assembler\n  DirichletConditions .. Controlroutine\n  Controlroutine &lt;|-- IObservable\n  NonlinearSolver &lt;|-- IObservable\n  Observer ..&gt; IObservable\n  FERequirements &lt;-- Affordances\n  Affordances &lt;-- ScalarAffordance\n  Affordances &lt;-- VectorAffordance\n  Affordances &lt;-- MatrixAffordance\n  ResultRequirements &lt;-- ResultType\n\n\n  class ScalarAffordance{\n  &lt;&lt;enumeration&gt;&gt;\n      mechanicalPotentialEnergy\n      microMagneticPotentialEnergy\n      ...\n  }\n\n  class VectorAffordance{\n        &lt;&lt;enumeration&gt;&gt;\n      forces\n      microMagneticForces\n      ...\n  }\n\n  class MatrixAffordance{\n        &lt;&lt;enumeration&gt;&gt;\n      stiffness\n      materialstiffness\n      geometricstiffness\n      mass\n      stiffnessdiffBucklingVector\n      microMagneticHessian\n      ...\n  }\n\n  class ResultType{\n      &lt;&lt;enumeration&gt;&gt;\n      noType\n      magnetization\n      gradientNormOfMagnetization\n      vectorPotential\n      divergenceOfVectorPotential\n      BField\n      HField\n      cauchyStress\n      director\n      ...\n  }\n\n  class Observer{\n    +update()\n  }\n\n  class DirichletConditions{\n  TBA\n  }\n\n  class IObservable{\n    +subscribe()\n    +subscribeAll()\n    +unSubscribe()\n    +unSubscribeAll()\n    +notify()\n  }\n\n  class FERequirements{\n    +hasAffordance()\n    +getGlobalSolution()\n    +getParameter()\n  }\n\n  class ResultRequirements{\n    +isResultRequested()\n    +getParameter()\n  }\n\n  class Assembler{\n    +scalar()\n    +matrix()\n    +vector()\n    +createFullVector()\n  }\n  class GridView{\n    +elements(gridView)\n    +vertices(gridView)\n    +edges(gridView)\n    +surfaces(gridView)\n  }\n  class Controlroutine{\n    +run()\n  }\n\n  class NonlinearSolver{\n    +setup()\n    +solve()\n    +nonLinearOperator()\n  }\n\n  class GlobalBasis{\n    +localView()\n  }\n\n    class Grid{\n    +leafGridView()\n  }\n\n  class FiniteElement{\n  +calculateScalar()\n  +calculateVector()\n  +calculateMatrix()\n  +calculateAt()\n  }\n\n  class LinearSolver{\n    +analyzePattern()\n    +factorize()\n    +compute()\n    +solve()\n  }\n  class NonlinearOperator{\n    +value()\n    +derivative()\n    +secondDerivative()\n    +nthDerivative&lt;n&gt;()\n    +subOperator()\n}\n\n  class Localfunction{\n    +calculateFunction()\n    +calculateDerivative()\n    +bind()\n    +viewOverIntegrationPoints()\n  }\n\n  class Localbasis{\n    +calculateFunction()\n    +evaluateJacobian()\n    +bind()\n    +isBound()\n    +viewOverIntegrationPoints()\n  }\n\n  class Manifold{\n    +setValue()\n    +operator+=()\n    +getValue()\n    +size()\n    +size()\n  }\n\nclick NonlinearOperator href \"../nonlinearOperator/\"\nclick LinearSolver href \"../solvers/#linear-solver\"\nclick NonlinearSolver href \"../solvers/#non-linear-solver\"\nclick FiniteElement href \"../finiteElements/\"\nclick GridView href \"../grid/\"\nclick Grid href \"../grid/\"\nclick Controlroutine href \"../controlRoutines/\"\nclick Assembler href \"../assembler/\"\nclick Localfunction href \"../localFunctions/\"\nclick Manifold href \"../manifolds/\"\nclick Localbasis href \"../localBasis/\"\nclick FERequirements href \"../feRequirements/\"\nclick ResultRequirements href \"../feRequirements/#fe-result-requirements\"\nclick Affordances href \"../feRequirements/\"\nclick ResultType href \"../feRequirements/\"\nclick IObservable href \"../observer/#iobservable\"\nclick Observer href \"../observer/#iobserver\"\nclick GlobalBasis href \"../globalBasis/\"\n</code></pre>"},{"location":"01_framework/assembler/","title":"Assembler","text":"<p>The purpose of an assembler is to assemble local quantities (local stiffness matrix, local force vector, local energy, etc.) by looping over finite elements and thereby arriving at a global structure. This page describes the available assemblers and how they can be used.</p> <p>Each of the assemblers is constructed as follows:</p> <pre><code>AssemblerName(const FEContainer&amp; fes, const std::vector&lt;bool&gt;&amp; dirichletFlags)\n</code></pre> <ul> <li><code>basis</code> is the basis that was used to construct the finite elements. The implementation of the bases involves four different   strategies: <code>BlockedLexicographic</code>, <code>BlockedInterleaved</code>, <code>FlatLexicographic</code> and <code>FlatInterleaved</code>. These strategies are to be   considered while creating the assembler. For further information on these strategies, refer to Chapter 10 of DUNE<sup>1</sup>.</li> <li><code>fes</code> is a container that contains all the finite elements that should be assembled.</li> <li><code>dirichletFlags</code> is a <code>std::vector&lt;bool&gt;</code> type. The <code>i</code>-th degree of freedom is fixed when <code>dirichletFlags[i] = true</code>.   When a reduced matrix or vector is chosen, the corresponding row and column entries are removed.</li> </ul>"},{"location":"01_framework/assembler/#base-class-for-flat-assemblers","title":"Base class for flat assemblers","text":"<p>The FlatAssemblerBase is the base class for all assemblers currently available. All other assemblers inherit from this one, i.e., their interface includes the following functions:</p> <pre><code>size_t size() // (1)!\nsize_t reducedSize() // (2)!\nauto &amp;finiteElements() const // (3)!\nEigen::VectorXd createFullVector(const Eigen::VectorXd &amp;reducedVector) // (4)!\nsize_t constraintsBelow(size_t i) // (5)!\nbool isConstrained(size_t i) // (6)!\nsize_t estimateOfConnectivity() // (7)!\nvoid bind(const RequirementType&amp; feRequirements, AffordanceCollection&lt;ScalarAffordance, VectorAffordance, MatrixAffordance&gt; affordance)  // (8)!\n</code></pre> <ol> <li>Returns the number of degrees of freedom.</li> <li>Returns the number of degrees of freedom that are not constrained by a Dirichlet boundary condition.</li> <li>Returns a reference to the finite element container, which was passed to the assembler.</li> <li>Gets a reduced vector and returns a full vector. Entries corresponding to fixed dofs are set to 0. The values of the other entries are     obtained from the reduced vector.</li> <li>Indicates how many degrees of freedom {0,1,...i-1} are fixed.</li> <li>Indicates whether the degree of freedom <code>i</code> is fixed.</li> <li>An estimate for the connectivity. It can be used to allocate vectors.</li> <li>The assembler can be bound to specific FE requirements and an affordance collection</li> </ol>"},{"location":"01_framework/assembler/#scalar-assembler","title":"Scalar assembler","text":"<p>It has the capabilities of FlatAssemblerBase plus one additional function:</p> <pre><code>double&amp; scalar(const RequirementType&amp; feRequirements, ScalarAffordance affordance)\ndouble&amp; scalar()\n</code></pre> <p>This assembler can be used when only a scalar quantity is of interest and the assembly of matrices or vectors is irrelevant. The available requirements are explained on the FE requirements page. <code>dirichletFlags</code> is not used in this assembler.</p> <p>It assembles the requested scalar quantity. A call to this function could look like this:</p> <pre><code>ScalarAssembler myAssembler(...) // (1)!\nconst auto&amp; K = myAssembler.scalar(feRequirements, scalarAffordance) // (2)!\n</code></pre> <ol> <li>Represents the construction of the desired assembler.</li> <li>To learn more about the available alternatives to <code>energy</code> and how this works, read the FE requirements page.</li> </ol>"},{"location":"01_framework/assembler/#flat-vector-assembler","title":"Flat vector assembler","text":"<p>It has all the features of ScalarAssembler plus more, like:</p> <pre><code>Eigen::VectorXd&amp; vector(const FERequirementType&amp; feRequirements, VectorAffordance affordance,  DBCOption dbcOption)\nEigen::VectorXd&amp; vector( DBCOption dbcOption)\n</code></pre> <p>The Enum <code>DBCOption</code> dictates how the Dirichlet boundary conditions should be applied The <code>DBCOption::Raw</code> returns a vector without considering the boundary conditions. The <code>DBCOption::Full</code> option returns a full vector, where zeros are written for the fixed degrees of freedom and <code>DBCOption::Reduced</code> returns reduced vector removing the fixed degrees of freedom. The second function can be used if the assembler is bound to specific fe requirements and affordances. They work in the same way as the scalar assembly functions of ScalarAssembler. The available FE requirements are explained on the FE requirements page.</p>"},{"location":"01_framework/assembler/#flat-sparse-assembler","title":"Flat sparse assembler","text":"<p>It offers the functions of VectorFlatAssembler plus more, like:</p> <pre><code>Eigen::SparseMatrix&lt;double&gt;&amp; matrix(const FERequirementType&amp; feRequirements, MatrixAffordance affordance, DBCOption dbcOption)\nEigen::SparseMatrix&lt;double&gt;&amp; matrix(DBCOption dbcOption)\n</code></pre> <p>A sparse matrix is returned. The Enum <code>DBCOption</code> dictates how the Dirichlet boundary conditions should be applied The <code>DBCOption::Raw</code> returns a matrix without considering the boundary conditions. The <code>DBCOption::Full</code> option returns a full matrx, where zeros are written on the  rows and columns associated to fixed degrees of freedom  and a one is written on the diagonal.  <code>DBCOption::Reduced</code> returns reduced matrix removing the rows and columns associated to fixed degrees of freedom. The second function can be used if the assembler is bound to specific fe requirements and affordances. They work in the same way as the vector assembly functions of VectorFlatAssembler. The available FE requirements are explained on the FE requirements page.</p>"},{"location":"01_framework/assembler/#flat-dense-assembler","title":"Flat dense assembler","text":"<p>The only difference between the SparseFlatAssembler and the DenseFlatAssembler is that the DenseFlatAssembler returns a dense matrix.</p> <pre><code>Eigen::MatrixXd&amp; matrix(const FERequirementType&amp; feRequirements, MatrixAffordance affordance, DBCOption dbcOption)\nEigen::MatrixXd&amp; matrix(DBCOption dbcOption)\n</code></pre> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/controlRoutines/","title":"Control routines","text":""},{"location":"01_framework/controlRoutines/#load-control","title":"Load control","text":"<p>A load control object is constructed as follows:</p> <pre><code>auto lc = Ikarus::LoadControl(nonlinearSolver, numLoadSteps, {loadFactorStartValue, loadFactorEndValue});\n</code></pre> <ul> <li><code>nonlinearSolver</code> is a nonlinear solver, e.g., Newton-Raphson method, trust-region method, etc.</li> <li><code>numLoadSteps</code> is the number of load steps.</li> <li><code>loadFactorStartValue</code> is the value of the load factor at the beginning of the simulation.</li> <li><code>loadFactorEndValue</code> is the value of the load factor at the end of the simulation.</li> </ul> <p>The load control is started with the <code>run()</code> method, i.e., for the above-mentioned example:</p> <pre><code>lc.run();\n</code></pre>"},{"location":"01_framework/controlRoutines/#obtaining-information-from-control-routines","title":"Obtaining information from control routines","text":"<p>The load control is an observable object, i.e. one can subscribe to the messages of the load control method. To read further on the implementation of observer patterns in Ikarus, see here.</p> <p>The following messages are available:</p> <pre><code>enum class ControlMessages {\n  BEGIN,\n  CONTROL_STARTED,\n  CONTROL_ENDED,\n  STEP_STARTED,\n  STEP_ENDED,\n  SOLUTION_CHANGED,\n  END\n};\n</code></pre>"},{"location":"01_framework/controlRoutines/#path-following-techniques","title":"Path-following techniques","text":"<p>A general routine based on the standard arc-length method is included, which uses a scalar subsidiary function to impose a constraint on the non-linear system of equations. The previously mentioned LoadControl method can also be recreated using this technique. For more details on the standard arc-length method, see, among others, the works of Wempner<sup>1</sup>, Crisfield<sup>2</sup>, Ramm<sup>3</sup> and Riks<sup>4</sup> among others. A path-following object is constructed as follows:</p> <pre><code>auto alc = Ikarus::PathFollowing(nr, load_steps, stepSize, pft);\n</code></pre> <p>where <code>nr</code> is a Newton-Raphson solver which considers a scalar subsidiary function and is defined by</p> <pre><code>auto nr = Ikarus::makeNewtonRaphsonWithSubsidiaryFunction(nonLinOp, std::move(linSolver));\n</code></pre> <p>and <code>pft</code> is the desired path-following technique. Three different path-following techniques are included, namely</p> <ul> <li>Standard arc-length method</li> <li>Load control method (as a subsidiary function under this generalized implementation)</li> <li>Displacement control method (uses a vector of indices which are all controlled by a same <code>stepSize</code>).</li> </ul> <p>These can be invoked by defining</p> <pre><code>auto pft = Ikarus::StandardArcLength{};\nauto pft = Ikarus::LoadControlWithSubsidiaryFunction{};\nauto pft = Ikarus::DisplacementControl{controlledIndices};\n</code></pre> <p>Note</p> <p>The default path-following type is the <code>Ikarus::StandardArcLength{}</code>. In the current implementation, it is assumed that the external forces are given by \\(F_{ext} = F_{ext}^0\\lambda\\) such that $$ -\\frac{\\partial \\mathbf{R}}{\\partial \\lambda} = F_{ext}^0 $$ An implementation for a general non-linear \\(F_{ext} = F_{ext}^0\\left(\\mathbf{D},\\lambda\\right)\\) is an open task.</p> <p>In order to create an own implementation for the scalar subsidiary function, the user has to create a <code>struct</code> with the following three member functions:</p> <pre><code>void evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args) const;\nvoid initialPrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args);\nvoid intermediatePrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args);\n</code></pre> <p>For each Newton-Raphson iteration, the function <code>evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args)</code> is used to evaluate the subsidiary function and its derivatives with respect to the displacement \\(\\mathbf{D}\\) and the load factor \\(\\lambda\\). The other two functions are used to specify a prediction for \\(\\mathbf{D}\\) and \\(\\lambda\\) for the initial step and for all the other intermediate subsequent <code>load_steps</code>, respectively.</p> <p><code>SubsidiaryArgs</code> is a <code>struct</code> which is defined as</p> <pre><code>struct SubsidiaryArgs {\n  double stepSize; // (1)!\n  Eigen::VectorX&lt;double&gt; DD; // (2)!\n  double Dlambda{}; // (3)!\n  double f{}; // (4)!\n  Eigen::VectorX&lt;double&gt; dfdDD; // (5)!\n  double dfdDlambda{}; // (6)!\n  int currentStep; // (7)!\n};\n</code></pre> <ol> <li>User-desired step size</li> <li>Vector of displacement increments</li> <li>Increment in the load factor</li> <li>Scalar value evaluated from the subsidiary function</li> <li>Derivative of the subsidiary function with respect to the displacement increment</li> <li>Derivative of the subsidiary function with respect to the load factor increment</li> <li>Current load step number</li> </ol> <p>An example for the standard arc-length method is shown below:</p> <pre><code>struct StandardArcLength {\n    void evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args) const {\n      if (psi) {\n        const auto root = sqrt(args.DD.squaredNorm() + psi.value() * psi.value() * args.Dlambda * args.Dlambda);\n        args.f          = root - args.stepSize;\n        args.dfdDD      = args.DD / root;\n        args.dfdDlambda = (psi.value() * psi.value() * args.Dlambda) / root;\n      } else\n        DUNE_THROW(Dune::InvalidStateException,\n                   \"You have to call initialPrediction first. Otherwise psi is not defined\");\n    }\n\n    template &lt;typename NonLinearOperator&gt;\n    void initialPrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args) {\n      auto linearSolver\n          = Ikarus::LinearSolver(Ikarus::SolverTypeTag::d_LDLT);  // for the linear predictor step\n\n      nonLinearOperator.lastParameter() = 1.0;  // lambda =1.0\n\n      nonLinearOperator.template update&lt;0&gt;();\n      const auto&amp; R = nonLinearOperator.value();\n      const auto&amp; K = nonLinearOperator.derivative();\n\n      linearSolver.factorize(K);\n      linearSolver.solve(args.DD, -R);\n\n      const auto DD2 = args.DD.squaredNorm();\n\n      psi    = sqrt(DD2);\n      auto s = sqrt(psi.value() * psi.value() + DD2);\n\n      args.DD      = args.DD * args.stepSize / s;\n      args.Dlambda = args.stepSize / s;\n\n      nonLinearOperator.firstParameter() = args.DD;\n      nonLinearOperator.lastParameter()  = args.Dlambda;\n    }\n\n    template &lt;typename NonLinearOperator&gt;\n    void intermediatePrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args) {\n      nonLinearOperator.firstParameter() += args.DD;\n      nonLinearOperator.lastParameter() += args.Dlambda;\n    }\n\n    std::string name = \"Arc length\";\n\n  private:\n    std::optional&lt;double&gt; psi;\n  };\n</code></pre>"},{"location":"01_framework/controlRoutines/#adaptive-step-sizing-for-the-path-following-techniques","title":"Adaptive step-sizing for the path-following techniques","text":""},{"location":"01_framework/controlRoutines/#interface","title":"Interface","text":"<p>The general interface for adaptive step-sizing is represented by the following concept.</p> <pre><code>namespace Ikarus::Concepts {\n    template &lt;typename AdaptiveStepSizing, typename NonLinearSolverInformation, typename SubsidiaryArgs,\n              typename NonLinearOperator&gt;\n    concept AdaptiveStepSizingStrategy = requires(AdaptiveStepSizing adaptiveSS, NonLinearSolverInformation info,\n                                                  SubsidiaryArgs args, NonLinearOperator nop) {\n      { adaptiveSS(info, args, nop) } -&gt; std::same_as&lt;void&gt;; // (1)!\n      { adaptiveSS.targetIterations() } -&gt; std::same_as&lt;int&gt;; // (2)!\n      { adaptiveSS.setTargetIterations(std::declval&lt;int&gt;()) } -&gt; std::same_as&lt;void&gt;; // (3)!\n    };\n}\n</code></pre> <ol> <li><code>operator()</code> is overloaded such that the step size is modified.</li> <li>Function that returns <code>targetIterations</code> to be achieved. See Iteration-based, for example.</li> <li>Function used to set <code>targetIterations</code>.</li> </ol> <p>For implementation details, refer to <code>ikarus/controlroutines/adaptivestepsizing.hh</code>.</p>"},{"location":"01_framework/controlRoutines/#implementations","title":"Implementations","text":""},{"location":"01_framework/controlRoutines/#no-operation","title":"No Operation","text":"<p>By default, <code>AdaptiveStepSizing::NoOp</code> is used with a path-following technique. <code>AdaptiveStepSizing::NoOp</code> uses the step size provided by the user and doesn't modify them while using <code>PathFollowing</code>. <code>NoOp</code> here stands for No Operation.</p>"},{"location":"01_framework/controlRoutines/#iteration-based","title":"Iteration-based","text":"<p>Instead of using a constant step size, the step size can be automatically adapted for efficient computations. The <code>AdaptiveStepSizing::IterationBased</code> is implemented according to Ramm<sup>3</sup>. The step size can be scaled as shown below:</p> \\[ \\hat{s}_{k+1} = \\left(\\frac{\\hat{i}}{i_k}\\right)^{1/2}\\hat{s}_k \\] <p>Here, \\(\\hat{s}_{k+1}\\) and \\(\\hat{s}_{k}\\) are the step sizes at \\(k+1\\)-th and \\(k\\)-th iteration. Here, \\(\\hat{i}\\) is the desired number of iterations and \\(i_k\\) is the number of iterations used in the previous step.</p> <ol> <li> <p>Gerald A. Wempner. Discrete approximations related to nonlinear theories of solids. International Journal of Solids and Structures, 7(11):1581\u20131599, 1971. doi:10.1016/0020-7683(71)90038-2.\u00a0\u21a9</p> </li> <li> <p>M.A. Crisfield. A fast incremental/iterative solution procedure that handles \u201csnap-through\u201d. Computers &amp; Structures, 13(1):55\u201362, 1981. doi:10.1016/0045-7949(81)90108-5.\u00a0\u21a9</p> </li> <li> <p>E. Ramm. Strategies for Tracing the Nonlinear Response Near Limit Points. In W. Wunderlich, E. Stein, and K.-J. Bathe, editors, Nonlinear Finite Element Analysis in Structural Mechanics, pages 63\u201389. Springer Berlin Heidelberg, Berlin, Heidelberg, 1981. doi:10.1007/978-3-642-81589-8_5.\u00a0\u21a9\u21a9</p> </li> <li> <p>E. Riks. The Application of Newton\u2019s Method to the Problem of Elastic Stability. Journal of Applied Mechanics, 39(4):1060\u20131065, 1972. doi:10.1115/1.3422829.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/dirichletBCs/","title":"Dirichlet boundary conditions","text":""},{"location":"01_framework/dirichletBCs/#introduction","title":"Introduction","text":"<p>In finite element problems, it is essential to incorporate the Dirichlet boundary conditions, i.e., prescribing a part of the solution to a fixed value. Let us consider the following:</p> <p>$$  \\boldsymbol{u} = \\boldsymbol{g} \\quad \\text{on  } \\Gamma_\\mathrm{D}. $$ Here \\(  \\boldsymbol{u} \\) is the solution field with a prescribed value \\(\\boldsymbol{g}\\) on the boundary \\(\\Gamma_\\mathrm{D}\\).</p> <p>For the discrete algebraic problem, this translates to fixing the values of \\(u_i\\) to \\(g_i\\) in the approximation \\(  \\boldsymbol{u}^h = \\sum_i N^i u_i \\), where \\(  N^i \\) is the \\(i\\)-th ansatz function.</p> <p>The handling of such a function \\(\\boldsymbol{g}\\) is done by the class <code>Ikarus::DirichletValues</code>.</p>"},{"location":"01_framework/dirichletBCs/#interface","title":"Interface","text":"<p>The interface of <code>Ikarus::DirichletValues</code> is represented by the following code snippet:</p> <pre><code>Ikarus::DirichletValues dirichletValues2(basis); // (1)!\nvoid fixBoundaryDOFs(f); // (2)!\nvoid fixDOFs(f); // (3)!\nvoid setSingleDOF(i, flag); // (4)!\nconst auto&amp; basis() const; // (5)!\nbool isConstrained(i) const; // (6)!\nauto fixedDOFsize() const; // (7)!\nauto size() const ; // (8)!\nauto reset(); // (9)!\n</code></pre> <ol> <li>Create class by inserting a global basis, <sup>1</sup> Chapter 10.</li> <li>Accepts a functor to fix boundary degrees of freedom. <code>f</code> is  a functor that will be called with the Boolean vector of fixed boundary.  degrees of freedom and the usual arguments of <code>Dune::Functions::forEachBoundaryDOF</code>, as defined on page 388 of the Dune    <sup>1</sup> book.</li> <li>A more general version of <code>fixBoundaryDOFs</code>. Here, a functor is to be provided that accepts a basis and the corresponding Boolean</li> <li>A function that helps to fix or unfix the \\(i\\)-th degree of freedom    vector considering the Dirichlet degrees of freedom.</li> <li>Returns the underlying basis.</li> <li>Indicates whether the degree of freedom \\(i\\) is fixed.</li> <li>Returns the number of fixed degrees of freedom.</li> <li>Returns the number of all Dirichlet degrees of freedom.</li> <li>Resets the whole container</li> </ol> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"01_framework/feRequirements/","title":"FE requirements","text":"<p>Finite element requirements are a simple way to communicate the needs and expectations of a finite element.</p> <p>FE requirements are used to pass information from assemblers to finite elements.</p>"},{"location":"01_framework/feRequirements/#construction-and-usage","title":"Construction and usage","text":"<p>Usually the construction is as follows:</p> <pre><code>FErequirements req = fe.createRequirement()\n                           .insertGlobalSolution( d)\n                           .insertParameter( lambda);\nMatrixType A = sparseFlatAssembler.matrix(req,MatrixAffordance::stiffness,DBCOption::Full);\n</code></pre> <p>All the methods return a reference to <code>FErequirements</code>, so they can be chained together.</p> <p>As in line 2, the finite element solution can also be inserted. The solution is passed with the <code>enum</code> type <code>FESolutions::displacement</code> vector <code>d</code>. This stores a reference to the vector.</p> <p>Additionally, if some parameters are to be passed, use the method <code>insertParameter</code> (line 3), where, similar to the global solutions, an <code>enum</code> type of <code>FEParameter::loadfactor</code> is passed to indicate the meaning of the parameter, followed by its value.</p> <p>Finally, the method <code>addAffordance</code> is used to indicate the request required from the finite element. Thus, there exist scalar, vector, matrix and general affordance collections.</p> <p>Currently, the following are defined:</p> <pre><code>#include &lt;Eigen/Core&gt;\n\n#include &lt;ikarus/finiteelements/feresulttypes.hh&gt;\n#include &lt;ikarus/utils/makeenum.hh&gt;\n\nnamespace Ikarus {\n// clang-format off\n\n  /**\n * ScalarAffordance\n * \\ingroup Affordancetags\n * \\brief A strongly typed enum class representing the scalar affordance\n */\n// cppcheck-suppress MAKE_ENUM\n MAKE_ENUM(ScalarAffordance,\n            noAffordance,\n            mechanicalPotentialEnergy,\n            microMagneticPotentialEnergy\n      );\n\n  /**\n* VectorAffordance\n* \\ingroup Affordancetags\n* \\brief A strongly typed enum class representing the vector affordance\n*/\n  MAKE_ENUM(VectorAffordance,\n            noAffordance,\n            forces,\n            microMagneticForces\n      );\n\n  /**\n* MatrixAffordance\n* \\ingroup Affordancetags\n</code></pre> <p>Inside the finite element, the information can then be conveniently extracted:</p> <pre><code>const auto&amp; d      = req.globalSolution();\nconst auto&amp; lambda = req.parameter();\n</code></pre> <p>Thus, the local finite element can be developed.</p> <p>Affordance</p> <pre><code>It is good style to indicate that you cannot fulfill an affordance by throwing an appropriate exception!\n</code></pre>"},{"location":"01_framework/feRequirements/#fe-result-requirements","title":"FE result requirements","text":"<p>Bug</p> <p>This section is outdated!</p> <p>In addition to the above-mentioned finite element requirements, there are also result requirements. They accept the same parameter types as the <code>FErequirements</code> and add one more, the <code>ResultType</code>. These are used in the <code>calculateAt</code> method of finite elements. They are used to communicate the results required from the finite elements.</p> <p>Its construction is shown below:</p> <pre><code>ResultRequirements resultRequirements = Ikarus::ResultRequirements()\n        .insertGlobalSolution(FESolutions::displacement, d)\n        .insertParameter(FEParameter::loadfactor, lambda)\n        .addResultRequest(ResultType::cauchyStress,,ResultType::director);\n</code></pre> <p>The current supported results are:</p> <pre><code>*/\n  MAKE_ENUM(MatrixAffordance,\n            noAffordance,\n            stiffness,\n            materialstiffness,\n            geometricstiffness,\n            stiffnessdiffBucklingVector,\n            microMagneticHessian,\n            mass\n      );\n</code></pre> <p>The interface for result requirements is similar to the finite element requirements. They do, however, support querying specific results to be calculated.</p> <pre><code>if( req.isResultRequested( ResultType::cauchyStress)) {\n  ...\n}\n\nif( req.isResultRequested( ResultType::BField)) {\n  ...\n}\n\nif( req.isResultRequested( ResultType::director)) {\n  ...\n}\n</code></pre>"},{"location":"01_framework/finiteElements/","title":"Finite elements","text":"<p>Several disciplines associate finite elements with different meanings. In Ikarus, finite elements have two different objectives. The first one is to provide an evaluation of the scalars, vectors, and matrices. These are associated with an algebraic representation of discrete energies, weak forms, or bilinear forms. These algebraic objects are usually constructed using some combination of local functions and parameters stemming from the underlying physical problem, e.g., load factor, Young's modulus, or viscosity.</p> <p>The second task of finite elements is to evaluate derived results in the element parameter space, e.g., stresses or geometric quantities. This leads to the following interface for the finite elements:</p>"},{"location":"01_framework/finiteElements/#interface","title":"Interface","text":"<p>Finite elements should have non-template and non-virtual (considering non-virtual interface idiom (NVI) for the latter) interface methods. This is because these methods are usually used to assemble quantities. These functions are <code>calculateScalar</code>, <code>calculateVector</code> and <code>calculateMatrix</code>. These are public methods. Such an interface is provided by the local functions are shown below:</p> <pre><code>ScalarType calculateScalar(const FERequirements&amp; req);\nvoid calculateVector(const FERequirements&amp; req, VectorType&amp; b);\nvoid calculateMatrix(const FERequirements&amp; req, MatrixType&amp; A);\nvoid calculateLocalSystem(const FERequirements&amp; req, MatrixType&amp; A, VectorType&amp; b);\nvoid calculateAt(const Resultrequirements&amp; req, const Eigen::Vector&lt;double, Traits::mydim&gt;&amp; local,\n                     ResultTypeMap&lt;ScalarType&gt;&amp; result);\n</code></pre> <p>Since we would also like to use <code>autodiff</code> for our element, we have their protected implementations. These methods are templates to allow double or <code>autodiff</code> scalar types. These methods are <code>calculateScalarImpl</code>, <code>calculateVectorImpl</code> and <code>calculateMatrixImpl</code>. <code>calculateScalar</code>, <code>calculateVector</code> and <code>calculateMatrix</code> simply forward to these implementation functions.</p> <p>Please refer to the FE requirements to learn more about the finite element requirements and result requirements. The first four methods receive an object of type <code>FERequirements</code>. This object is responsible for passing different types of information needed for the local evaluation of the local linear algebra objects. The first method, <code>evaluateScalar</code>, simply returns by value because it is cheaper to return a <code>double</code>, for example, when evaluating energy. The other methods, <code>evaluateVector</code>, <code>evaluateMatrix</code>, and <code>calculateLocalSystem</code>, receive one or two additional output arguments where the results are to be written. This interface is needed to circumvent the dynamic memory allocation, that is required if these methods return by value.</p> <p>The method <code>calculateAt</code> is responsible for evaluating several results, and it receives the <code>ResultRequirements</code> object. These results are stored inside the output argument <code>result</code>, which is of the type <code>ResultTypeMap</code>. Additionally, there is the argument <code>local</code>, which contains the element coordinates where the results are to be evaluated.</p> <p>A typical <code>calculateAt</code> method is implemented as shown below:</p> <pre><code>typename ResultTypeMap&lt;double&gt;::ResultArray res;\nif(req.isResultRequested( ResultType::gradientNormOfMagnetization)) {\n  res.resize(1,1);\n  res(0,0)=...;\n  result.insertOrAssignResult(ResultType::gradientNormOfMagnetization,res);\n}\nif(req.isResultRequested( ResultType::BField)) {\n  res.setZero(3,1);\n  res=...;\n  result.insertOrAssignResult(ResultType::BField,res);\n}\nif(req.isResultRequested( ResultType::cauchyStress)) {\n  res.setZero(3,3);\n  res = ...;\n  result.insertOrAssignResult(ResultType::cauchyStress,res);\n}\n</code></pre> <p><code>ResultTypeMap&lt;double&gt;::ResultArray</code></p> <p><code>ResultTypeMap&lt;double&gt;::ResultArray</code> is an object of type <code>Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,0,3,3&gt;</code>. Thus, the maximum size of <code>result</code> is limited to a 3x3 matrix. This is used to circumvent dynamic memory allocations again.</p> <p>The method <code>FEHelper::globalIndices</code> is used to write a finite element's global indices to an output parameter of type <code>std::vector&lt;LocalView::MultiIndex&gt;</code>. This information originates from a <code>basis</code> object. It works for both <code>FlatInterleaved</code> and <code>BlockedInterleaved</code> types of indexing. See existing implementations for details.</p>"},{"location":"01_framework/finiteElements/#linear-and-non-linear-elasticity","title":"Linear and Non-linear Elasticity","text":"<p><code>LinearElastic</code> and <code>NonLinearElastic</code> classes are designed in a generic way. This means that they could be directly used for any \\(n\\)-dimensional finite element in the geometrically linear and non-linear cases. They inherit from the class <code>FEBase</code>, which helps to arrange the nodal degrees of freedom in a <code>FlatInterleaved</code> format. Refer DUNE<sup>1</sup> for more details. The constructor for both classes of elements has the following signature:</p> <pre><code>template &lt;typename VolumeLoad = LoadDefault, typename NeumannBoundaryLoad = LoadDefault&gt;\nLinearElastic(const Basis&amp; globalBasis, const typename LocalView::Element&amp; element, double emod, double nu,\n                  VolumeLoad p_volumeLoad = {}, const BoundaryPatch&lt;GridView&gt;* p_neumannBoundary = nullptr,\n                  NeumannBoundaryLoad p_neumannBoundaryLoad = {}) {}\n</code></pre> <pre><code>template &lt;typename VolumeLoad = LoadDefault, typename NeumannBoundaryLoad = LoadDefault&gt;\nNonLinearElastic(const Basis&amp; globalBasis, const typename LocalView::Element&amp; element, const Material&amp; p_mat,\n                 VolumeLoad p_volumeLoad = {}, const BoundaryPatch&lt;GridView&gt;* p_neumannBoundary = nullptr,\n                 NeumannBoundaryLoad p_neumannBoundaryLoad = {})\n</code></pre> <p>The first argument defines the basis function used to interpolate the solution field, while the second argument points to the <code>gridElement</code> itself. The next set of arguments are related to the material law to be used. For the geometrically linear case, the Young's modulus and the Poisson's ratio are passed, and a <code>planeStress</code> material model is assumed. For the geometrically non-linear case, the material model is to be passed as an argument. This could be, for instance, the St. Venant-Kirchhoff material law or the Neo-Hookean material law. <code>volumeLoad</code> and <code>neumannBoundaryLoad</code> are optional parameters that could be passed as per the use case. It is necessary to note that a <code>neumannBoundary</code> must be defined if a <code>neumannBoundaryLoad</code> is to be applied. Member functions are defined as per the interface mentioned above. Two member functions are written such that the stiffness matrices and load vectors can also be obtained by automatic differentiation. These functions are <code>protected</code>. They are:</p> <pre><code>calculateScalarImpl(const FERequirementType&amp; par, const Eigen::VectorX&lt;ScalarType&gt;&amp; dx)\ncalculateVectorImpl(const FERequirementType&amp; par, const Eigen::VectorX&lt;ScalarType&gt;&amp; dx, Eigen::VectorX&lt;ScalarType&gt;&amp; force)\n</code></pre> <p>Inside <code>strainFunction(const FERequirementType&amp; par, const Eigen::VectorX&lt;ScalarType&gt;&amp; dx)</code> is used to get the desired strain measure. It can be used to toggle between the geometrically linear and non-linear cases. <code>LinearStrains</code> are used for the geometrically linear case, while <code>GreenLagrangianStrains</code> are used for the non-linear case. These strain measures are defined as expressions in <code>dune-localfefunctions</code>. Refer to Expressions for more details. The strain-displacement operators are obtained by evaluating the derivative of the strain measure with respect to the nodal degrees of freedom. This is then used to evaluate the stiffness matrix. For more details on derivatives w.r.t. coefficients, refer here. Finally, the <code>calculateAt()</code> function evaluates the <code>linearStress</code> and <code>PK2Stress</code> (the second Piola-Kirchhoff stress tensor) as per the <code>ResultRequirementsType</code>. An implementation for a push forward operation to evaluate the <code>cauchyStress</code> is an open task. Refer to open tasks for more details.</p>"},{"location":"01_framework/finiteElements/#enhanced-assumed-strain-elements","title":"Enhanced Assumed Strain Elements","text":"<p>The Enhanced Assumed Strain (EAS) elements are a class of finite elements that helps to avoid the locking phenomenon. They are obtained by re-parametrizing the Hu-Washizu principle and enforcing an orthogonality condition. This results in an extension of the standard pure displacement formulation with an enhanced strain field (\\(\\tilde\\epsilon\\)). (\\(\\tilde\\epsilon\\)) is as an additional independent variable. The locking characteristics of the pure displacement formulations can be eliminated with an appropriate choice of ansatz space for \\(\\tilde\\epsilon\\). For further theoretical aspects, the readers are referred to <sup>2</sup> and <sup>3</sup>. The EAS formulation is currently implemented for the linear-elastic case, but it could be extended to the non-linear regime. The currently implemented EAS elements are the following:</p> <ul> <li>Q1E4</li> <li>Q1E5</li> <li>Q1E7</li> <li>H1E9</li> <li>H1E21</li> </ul> <p>The notation used here is described as follows: the first alphabet stands for a Quadrilateral (Q) or a Hexahedral (H) element. The second index denotes the order of the element. E stands for the EAS element, and the number following that denotes the number of EAS parameters used to enhance the strain field. The only difference amongst various EAS formulations arises from the matrix, \\(\\mathbf{M}\\) which is used to approximate the enhanced strain field. An example for the calculation of the matrix \\(\\mathbf{M}\\) for a Q1E4 element is shown below:</p> <pre><code>template &lt;typename Geometry&gt;\nstruct Q1E4 {\n  static constexpr int strainSize         = 3;\n  static constexpr int enhancedStrainSize = 4;\n\n  Q1E4() = default;\n  explicit Q1E4(const Geometry&amp; geometry)\n      : geometry{std::make_unique&lt;Geometry&gt;(geometry)}, T0InverseTransformed{calcTransformationMatrix2D(geometry)} {}\n\n  auto calcM(const Dune::FieldVector&lt;double, 2&gt;&amp; quadPos) const {\n    Eigen::Matrix&lt;double, strainSize, enhancedStrainSize&gt; M;\n    M.setZero(strainSize, enhancedStrainSize);\n    const double xi   = quadPos[0];\n    const double eta  = quadPos[1];\n    M(0, 0)           = 2 * xi - 1.0;\n    M(1, 1)           = 2 * eta - 1.0;\n    M(2, 2)           = 2 * xi - 1.0;\n    M(2, 3)           = 2 * eta - 1.0;\n    const double detJ = geometry-&gt;integrationElement(quadPos);\n    M                 = T0InverseTransformed / detJ * M;\n    return M;\n  }\n\n  std::unique_ptr&lt;Geometry&gt; geometry;\n  Eigen::Matrix3d T0InverseTransformed;\n};\n</code></pre> <p>The implementations of EAS variants for 2D elements can be found at <code>ikarus/finiteelements/mechanics/eas/eas2d.hh</code>. Similarly, the implementations of EAS variants for 3D elements can be found at <code>ikarus/finiteelements/mechanics/eas/eas3d.hh</code>. It is to be noted that the ansatz spaces for the matrix \\(\\mathbf{M}\\) are to be modified such that they fulfill the orthogonality condition in the \\(\\left[0,1\\right]\\) element domain used in DUNE, in contrast to the \\(\\left[-1,1\\right]\\) usually found in literature.</p> <p>In order to add a new EAS element, the following additions are to be made:</p> <ol> <li>Create a <code>struct</code> to calculate the matrix \\(\\mathbf{M}\\) as shown above exemplarily for the Q1E4 element.</li> <li> <p>Add the new variant in the file <code>ikarus/finiteelements/mechanics/easvariants.hh</code> to the corresponding variant type as shown below:</p> <pre><code>template &lt;typename Geometry&gt;\nstruct Variants{\nstatic constexpr int worldDim = Geometry::coorddimension;\nusing EAS2D = std::variant&lt;std::monostate, Q1E4&lt;Geometry&gt;, Q1E5&lt;Geometry&gt;, Q1E7&lt;Geometry&gt;&gt;;\nusing EAS3D = std::variant&lt;std::monostate, H1E9&lt;Geometry&gt;, H1E21&lt;Geometry&gt;&gt;;\nusing type = std::conditional_t&lt;worldDim == 2, EAS2D, EAS3D&gt;;\n};\n</code></pre> </li> <li> <p>Finally, add the new EAS variant with an appropriate switch statement (as shown below) to automatically call the     desired functions</p> <pre><code>void setEASType(int numberOfEASParameters) {\n    if constexpr (Traits::mydim == 2) {\n      switch (numberOfEASParameters) {\n        case 0:\n          onlyDisplacementBase = true;\n          break;\n        case 4:\n          easVariant = EAS::Q1E4(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 5:\n          easVariant = EAS::Q1E5(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 7:\n          easVariant = EAS::Q1E7(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        default:\n          DUNE_THROW(Dune::NotImplemented, \"The given EAS parameters are not available for the 2D case.\");\n          break;\n      }\n    } else if constexpr (Traits::mydim == 3) {\n      switch (numberOfEASParameters) {\n        case 0:\n          onlyDisplacementBase = true;\n          break;\n        case 9:\n          easVariant = EAS::H1E9(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 21:\n          easVariant = EAS::H1E21(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        default:\n          DUNE_THROW(Dune::NotImplemented, \"The given EAS parameters are not available for the 3D case.\");\n          break;\n      }\n    }\n  }\n</code></pre> </li> </ol> <p>If the number of EAS parameters is set to zero, the pure displacement formulation is then utilized for analysis.</p> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>J. C. Simo and M. S. Rifai. A class of mixed assumed strain methods and the method of incompatible modes. Int. J. Numer. Meth. Engng., 29(8):1595\u20131638, June 1990. doi:10.1002/nme.1620290802.\u00a0\u21a9</p> </li> <li> <p>U. Andelfinger and E. Ramm. EAS-elements for two-dimensional, three-dimensional, plate and shell structures and their equivalence to HR-elements. International Journal for Numerical Methods in Engineering, 36(8):1311\u20131337, 1993. doi:10.1002/nme.1620360805.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/grids/","title":"Grids","text":"<p>In the context of the finite element method, the terms \"elements\" and \"meshes\" are often used. Each element is linked with certain attributes. The finite element (FE) code should thus be able to evaluate these attributes. Here are some examples of attributes and the capabilities expected from the FE code:</p> <ul> <li>element number - provide a unique identifier for each element</li> <li>element shape in physical space, shape functions, ... - provide a description of the geometry</li> <li>element mass matrix, element stiffness matrix, element internal force vector, ... - provide quantities with physical meaning</li> <li>and more ...</li> </ul> <p>In the FE code, there is not one single class that serves to provide all these attributes to an element. Different goals are achieved by different classes. A group of elements along with their attributes connected to discretize the actual physical space is called the mesh.</p> <p>In Ikarus and i.e. in Dune, the description of the grid is decoupled from the description of the mesh to preserve its physical meaning. This helps to have the flexibility of discretizing a simple square-shaped grid with different basis functions like Langrange or NURBS bases with different polynomial orders. This helps to attain higher levels of abstraction and fewer iterations of modifying the existing code while studying different grids or the effects of different bases.</p> <p>For the notions of grids, grid entities, and grid factories, the definitions of Dune are utilized. For details, see <sup>1</sup> Chapter 5. All the grids that satisfy the <code>dune::grid</code> interface can be used within the Ikarus framework. This link provides an overview of the available <code>dune::grid</code> modules.</p> <p>There also exists an IGA-based grid called dune-iga to perform isogeometric analysis (refer <sup>2</sup>).</p> <p>It is important to note that the grid only provides geometric information and their relationship to their neighbors. Even though geometry is typically constructed by some ansatz functions, grids do not provide this information to the user because some global bases provide ansatz functions for the solution fields. Thus, the user can choose if the problem should be formulated using the iso-parametric concept, i.e., the same ansatz functions for geometry and solution fields, or if the ansatz functions for the solution should be independent. The basis defined by Dune is directly used here. Thus, they use the same interface. For details, see<sup>1</sup> Chapter 10.</p> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9\u21a9</p> </li> <li> <p>J. Austin Cottrell, Thomas J. R. Hughes, and Yuri Bazilevs. Isogeometric Analysis: Toward Integration of CAD and FEA. Wiley, 2009.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/localBasis/","title":"Local Basis","text":"<p>Each finite element includes a kind of local basis in terms of ansatz functions. These ansatz functions need to be evaluated in the parameter domain of the finite element.</p>"},{"location":"01_framework/localBasis/#interface","title":"Interface","text":"<p>In the exported module <code>dune-localfefunctions</code>, we provide  a thin wrapper with basic caching functionality for dune bases. For the definitions of bases, refer Chapter 8.2.1 of the Dune book<sup>1</sup>. Thus <code>Dune::CachedLocalBasis</code> (<code>#include &lt;dune/cachedlocalBasis/cachedlocalBasis.hh&gt;</code>) provides the following interface:</p> <pre><code>Dune::LocalBasis(const DuneLocalBasis&amp; p_basis);// (1)!\nvoid evaluateFunction(const DomainType&amp; local, Eigen::VectorX&lt;RangeFieldType&gt;&amp; N);\nvoid evaluateJacobian(const DomainType&amp; local,Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; dN);\nvoid evaluateFunctionAndJacobian(const DomainType&amp; local,Eigen::VectorX&lt;RangeFieldType&gt;&amp; N,\n                                 Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; dN);\n\nvoid evaluateSecondDerivatives(const DomainType&amp; local, Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim*(gridDim + 1) / 2&gt;&amp; dN);\n\nconst Eigen::VectorX&lt;RangeFieldType&gt;&amp; evaluateFunction(const unsigned int&amp; integrationPointIndex);\nconst Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; evaluateJacobian(const unsigned int&amp; integrationPointIndex);\nconst Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim*(gridDim + 1) / 2&gt;&amp; evaluateSecondDerivatives(const unsigned int&amp; integrationPointIndex);\nauto viewOverIntegrationPoints();// (2)!\nauto viewOverFunctionAndJacobian();// (3)!\n\ntemplate &lt;typename IntegrationRule, typename... Ints&gt;\nvoid bind(IntegrationRule&amp;&amp; p_rule, Derivatives&lt;Ints...&gt;&amp;&amp; ints);\n\nbool isBound(int i) const;// (4)!\nconst Dune::QuadraturePoint&lt;DomainFieldType, gridDim&gt;&amp; indexToIntegrationPoint(int i) const;// (5)!\n</code></pre> <ol> <li>The constructor only accepts a local basis that satisfies the concept <code>Concepts::DuneLocalBasis</code>. In keeping with the spirit of    duck-typing, this also allows for the use of a local basis from the Dune module.</li> <li>This returns a vector of structs containing the integration point and its index. Therefore, the syntax is usually <code>for (const auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()) {...}</code></li> <li>Returns a view over the  ansatz functions and the ansatz function Jacobians at the integration points</li> <li>Checks if the i-th derivatives are bounded.</li> <li>Convert an integration point index to a full integration point.</li> </ol> <p>The first two function calls, <code>evaluateFunction</code>  and <code>evaluateJacobian</code>, can be used to calculate the function values \\( N(\\boldsymbol{\\xi}) \\) and the spatial derivatives \\( N_{,\\boldsymbol{\\xi}}(\\boldsymbol{\\xi}) \\). One must allocate the objects and pass them as mutable references. The same holds for <code>evaluateSecondDerivatives</code>.</p> <p>In contrast to this, there are three other methods that receive an integration point index. These methods return a <code>const</code> reference to the evaluated ansatz function values and their first and second derivatives.</p> <p>This functionality is dependent on a previous call to <code>bind(...)</code>. This binds the local basis to one quadrature rule and caches the passed <code>bindDerivatives(..)</code>. An error is thrown if <code>evaluateFunction(const unsigned int&amp; integrationPointIndex)</code> is called before binding. Finally, to bind to an integration rule and cache the value and ansatz function Jacobian, one would use the following syntax:</p> Usage with integration point indexusing integration point coordinates <pre><code>using LocalFEType = LagrangeSimplexLocalFiniteElement&lt;double,double,dim,2&gt;;\nLocalFEType localFE;\n\nDune::CachedLocalBasis(localFE.localBasis());\nconst auto&amp; rule = Dune::QuadratureRules&lt;double, Traits::mydim&gt;::rule(localView.element().type(), order);\nlocalBasis.bind(rule, bindDerivatives(0, 1));\n\nfor (const auto&amp; [gpIndex, gp] : localBasis.viewOverIntegrationPoints()) {\n  const auto&amp; N = localBasis.evaluateFunction(gpIndex);\n  const auto&amp; dN = localBasis.evaluateJacobian(gpIndex);\n}\n</code></pre> <pre><code>using LocalFEType = LagrangeSimplexLocalFiniteElement&lt;double,double,dim,2&gt;;\nLocalFEType localFE;\n\nDune::CachedLocalBasis(localFE.localBasis());\nconst auto&amp; rule = Dune::QuadratureRules&lt;double, Traits::mydim&gt;::rule(localView.element().type(), order);\nEigen::VectorXd N;\nEigen::Matrix&lt;double, Eigen::Dynamic, gridDim&gt; dN;\n\nfor(auto&amp; gp : rule){\n  localFunction.evaluateFunction(gp.position(), N);\n  localFunction.evaluateJacobian(gp.position(), dN);\n  localFunction.evaluateFunctionAndJacobian(gp.position(), N, dN);// (1)!\n}\n</code></pre> <ol> <li>Alternative to the two lines above (Line 6 and 7)</li> </ol> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/localFunctions/","title":"Local functions","text":"<p>Local functions are functions that are bound to single grid elements. Therefore, they are constructed from some local basis, a coefficient vector, and the geometry of the grid element. Since the implementation is quite involved, <code>localfefunctions</code> do not reside at Ikarus but in the separate module dune-localfefunctions.</p> <p>Usually, local functions are need to be evaluated in the local coordinate system \\( \\mathbb{\\xi} \\in T_{\\text{ref}} \\subset\\mathbb{R}^n \\) :</p> \\[ f: \\boldsymbol{\\xi}^n \\rightarrow \\mathbb{R}^m \\] <p>where \\(T_{\\text{ref}}\\) is the reference element, e.g., for a hypercube, \\(T_{\\text{ref}}= [0,1]^d\\).</p>"},{"location":"01_framework/localFunctions/#interface","title":"Interface","text":"<p>Local functions provide the following interface:</p> <pre><code>LocalFunction(const Dune::CachedLocalBasis&lt;DuneBasis&gt;&amp; p_basis, const CoeffContainer&amp; coeffs_,\n              const std::shared_ptr&lt;const Geometry&gt;&amp; geo,\n              Dune::template index_constant&lt;ID&gt; = Dune::template index_constant&lt;std::size_t(0)&gt;{}); // (1)!\n\nFunctionReturnType evaluate(const DomainType&amp; local);\nFunctionReturnType evaluate(const unsigned int&amp; integrationPointIndex);\n\nauto evaluateDerivative(const DomainType&amp; local,...);\nauto evaluateDerivative(const unsigned int&amp; integrationPointIndex,...);\nauto viewOverIntegrationPoints(); // (2)!\n\ntemplate&lt;std::size_t ID=0&gt;\nconstexpr int order(Dune::index_constant&lt;ID&gt; ); // (3)!\n\ntemplate&lt;std::size_t ID=0&gt;\nauto basis(Dune::index_constant&lt;ID&gt; ); // (4)!\n\ntemplate&lt;std::size_t ID=0&gt;\nauto coefficientsRef(Dune::index_constant&lt;ID&gt;); // (5)!\n\ntemplate &lt;typename IntegrationRule, typename... Ints&gt;\nvoid bind(IntegrationRule&amp;&amp; p_rule, Derivatives&lt;Ints...&gt;&amp;&amp; ints); // (6)!\n\nauto clone (); // (7)!\n\ntemplate&lt;typename ScalarType, std::size_t ID=0&gt;\nauto rebindClone (ScalarType, Dune::index_constant&lt;ID&gt;); // (8)!\n</code></pre> <ol> <li>The constructor takes a <code>Dune::CachedLocalBasis</code>, a vector of coefficients and a shared pointer to the geometry of the grid elements.    Additionally, the local function can be tagged with a compile-time constant, e.g., <code>Dune::template index_constant&lt;0&gt;</code> or    <code>Dune::Indices::_0</code>.</li> <li>This returns a vector of structs representing the integration point and its index. Therefore, the syntax is <code>for (const auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()) {...}</code></li> <li>Returns the order of the local function with respect to the coefficients. An id tag can be passed, which returns the order with    respect to a tagged function. For details, see Tagging leaf local functions.</li> <li>Returns the basis of the local function. An id tag can be passed, which returns the basis of a specific tagged function. For details    see Tagging leaf local functions.</li> <li>Returns a reference to the coefficient of the underlying leaf local finite elements. An id tag can be passed, which returns the basis    of a specific tagged function. It can return a const or non-const reference. The non-const version is deactivated, if there is more    than one leaf node with the passed id tag.  For details, see Tagging leaf local functions.</li> <li>This function is passed to the given <code>localBasis</code>. See link</li> <li>Clones the local function and stores a copy of all leave nodes.</li> <li>Clones the local function and rebinds the scalar type of the coefficients with id tag <code>ID</code>. This comes in handy if, for example, one    wants to replace doubles with an autodiff type.</li> </ol> <p>The \"...\" in the <code>evaluateDerivative</code> function call refers to several possible variadic templates. The implementation looks like the following:</p> Usage with integration point indexusing integration point coordinates <pre><code>using namespace Dune::DerivativeDirections;\nlocalFunction.bind(rule, bindDerivatives(0,1));\nfor(auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()){\n  localFunction.evaluateDerivative(gpIndex, wrt(spatialAll)); // (1)!\n  localFunction.evaluateDerivative(gpIndex, wrt(spatialAll), on(gridElement)); // (2)!\n}\n</code></pre> <ol> <li>Compute the spatial Jacobian of localFunction</li> <li>Compute the spatial Jacobian of localFunction and transform it to the grid element</li> </ol> <pre><code>using namespace Dune::DerivativeDirections;\nfor(auto&amp; gp : rule){\n  localFunction.evaluateDerivative(gp.position(), wrt(spatialAll)); // (1)!\n  localFunction.evaluateDerivative(gp.position(), wrt(spatialAll), on(gridElement)); // (2)!\n}\n</code></pre> <ol> <li>Compute the spatial Jacobian of localFunction</li> <li>Compute the spatial Jacobian of localFunction and transform it to the grid element</li> </ol> <p>where the first call implements</p> \\[ \\operatorname{grad}_\\boldsymbol{\\xi} f : \\boldsymbol{\\xi} \\rightarrow \\mathbb{R}^{m \\times d}. \\] <p>The second one takes into account the fact that the local function is defined in some physical space \\(\\boldsymbol{X}\\) with the coordinate \\(\\boldsymbol{x}\\). Therefore, it transforms the Jacobian from the reference element \\(\\operatorname{grad}_{\\boldsymbol{\\xi}}\\) to the Jacobian on the grid element \\(\\operatorname{grad}_\\boldsymbol{x}\\). This behavior is activated, if <code>on(gridElement)</code> is passed; otherwise, if the derivatives on the reference element is needed, pass <code>on (referenceElement)</code>. Here, <code>gridElement</code> and <code>referenceElement</code> are global constants in the namespace <code>Dune::DerivativeDirections</code>.</p> <p>Thus, if <code>on(gridElement)</code> is passed, the local function usually implements</p> \\[ \\operatorname{grad}_\\boldsymbol{x} = \\operatorname{grad}_{\\boldsymbol{\\xi}} \\boldsymbol{J}^{-1} \\] <p>where \\(J\\) is the Jacobian of the mapping from the reference element \\(T_{\\text{ref}}\\) to the element living in physical space \\(T\\). For details, see page 22 of the Dune book<sup>1</sup>.</p> <p>Instead of passing <code>spatialAll</code> to <code>wrt(..)</code>, there are other helper functions such as:</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(spatial(0))); // (1)!\nlocalFunction.evaluateDerivative(gpIndex, wrt(spatial(1))); // (2)!\n</code></pre> <ol> <li>Compute the first column of the spatial Jacobian of <code>localFunction</code></li> <li>Compute the second column of the spatial Jacobian of <code>localFunction</code></li> </ol> <p>which can also be combined with <code>on(...)</code>.</p>"},{"location":"01_framework/localFunctions/#derivatives-wrt-coefficients","title":"Derivatives w.r.t. coefficients","text":"<pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j)));\n</code></pre> <p>which evaluates the first derivative for a vector space valued function,e.g., for \\(f(\\boldsymbol{\\xi}) = \\sum_{I=1}^n N^I(\\boldsymbol{\\xi}) \\boldsymbol{x}_I\\), we arrive at a matrix \\(\\boldsymbol{A}\\) such that</p> \\[ [\\boldsymbol{A}]_{ij}  = A_{ij} =  \\frac{\\partial f_i(\\boldsymbol{\\xi})}{\\partial \\boldsymbol{x}_j} \\] <p>and the second derivative</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k)), along(q));\n</code></pre> \\[ [\\boldsymbol{B}]_{jk} =  B_{jk} = q_i A_{ijk} =  \\frac{\\partial^2 (q_i  f_i(\\boldsymbol{\\xi}))}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k} \\] <p>where \\(\\boldsymbol{q}\\) is an arbitrary vector of the same size as \\(f\\), i.e., it is the direction of the derivative in this case. \\(\\boldsymbol{A}\\) and \\(\\boldsymbol{B}\\) are simply then the returned matrices and do not have any special meaning. If a vector is not passed while evaluating the second derivative, the result would be a third-order tensor for a vector-valued function \\(f\\). As a result, a direction derivative in the direction given by <code>along(q)</code> is computed to return a matrix \\(\\boldsymbol{B}\\) in this case. This helps for both readability and performance. See the example later for more details.</p>"},{"location":"01_framework/localFunctions/#derivatives-wrt-coefficients-and-spatial-derivatives","title":"Derivatives w.r.t. coefficients and spatial derivatives","text":"<p>Spatial derivatives and derivatives w.r.t. the coefficients can be combined. Therefore, it is legal to call</p> <pre><code>auto B = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatialAll), along(Q));\nauto b1 = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatial(0)), along(q));\nauto b2 = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatial(1)), along(q));\n</code></pre> <p>Warning</p> <p>The order of spatial and coefficient derivatives does not matter. The returned value is always rearranged so that the first derivative is the spatial one.</p> <p>The first line is then equivalent to</p> \\[ [\\boldsymbol{B}]_{jk} =  B_{jk} = Q_{il} A_{iljk} =  \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{\\xi} f(\\boldsymbol{\\xi})]_{il} Q_{il} )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] <p>For the second and third line, we have</p> \\[\\begin{align} \\boldsymbol{b}_{0,jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^0} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}, \\\\ \\boldsymbol{b}_{1,jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^1} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\end{align}\\] <p>These objects are also returned when the second and third lines above are used.</p> <p>All of these function calls, once again, can be combined with <code>on(gridElement)</code> as shown below:</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatialAll), along(Q), on(gridElement));\n</code></pre> <p>which computes</p> \\[ \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{x} f(\\boldsymbol{\\xi})]_{il} Q_{il} )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] <p>Warning</p> <p>Currently, only first-order spatial derivatives and second-order derivatives w.r.t. the coefficients are supported.</p>"},{"location":"01_framework/localFunctions/#example-dirichlet-energy","title":"Example: Dirichlet energy","text":"<p>This example shows how the energy, gradient, and Hessian of a dirichlet energy can be calculated. $$ E(\\boldsymbol{u}) = \\frac{1}{2} \\int_\\Omega ||\\operatorname{grad}_\\boldsymbol{x} \\boldsymbol{u}(\\boldsymbol{x})|| ^2 \\textrm{d} \\boldsymbol{x} $$</p> <p>If the energy is to be minimized w.r.t. the coefficients of the nodes, the energy, gradient, and Hessian w.r.t. the coefficients are to be calculated. Of course, this depends on the optimization algorithms, but for now, the general case where all three are needed is considered.</p> <pre><code>auto dirichletEnergy() {\n  double energy = 0;\n  // bind localBasis to some integration rule\n  // create uNodalCoeffs\n  Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs, sharedGeometry);\n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) {\n    //.. calculate the inverse Jacobian of the geometry\n    const auto gradu = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll), on(gridElement));\n    energy+= 0.5 * (gradu.transpose() * gradu).trace() * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n  }\n}\n</code></pre> <pre><code>auto gradientDirichletEnergy(Eigen::VectorXd&amp; g) {\n  //.bind localBasis to some integration rule\n  // create uNodalCoeffs\n  constexpr int size =  // spatial size of u\n      Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs, sharedGeometry);\n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) {\n    //.. calculate the inverse Jacobian of the geometry\n    const auto gradu = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll), on(gridElement));\n    for (auto i : fe.size()) { //loop over coeffs, i.e.nodes of the finite element\n      const auto graduDCoeffs\n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeff(i)), on(gridElement));\n      Eigen::Vector&lt;double, size&gt; tmp;\n      tmp.setZero();\n      for (int k = 0; k &lt; gridDimension; ++k)\n        tmp += graduDCoeffs[k] * gradu.col(k);  // (1)!\n      g.segment&lt;size&gt;(i * size) += tmp * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n    }\n  }\n}\n</code></pre> <ol> <li><code>graduDCoeffs</code> contains in <code>graduDCoeffs[0]</code> the derivatives w.r.t. the coefficient of the first column, and at <code>graduDCoeffs[1]</code> the    derivatives w.r.t. the second column of <code>gradu</code>.</li> </ol> <pre><code>auto hessianDirichletEnergy(Matrix&amp; h) {\n  //... bind localBasis to some integration rule\n  // and create uNodalCoeffs\n  constexpr int size =  // spatial size of u\n      Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs, sharedGeometry);\n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) {\n    //.. calculate the inverse Jacobian of the geometry\n    for (auto i : loop over coeffs, i.e.nodes of the finite element) {\n      const auto graduDCoeffsI\n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeff(i)), on(gridElement));\n      for (auto j : fe.size()) { //loop over coeffs, i.e.nodes of the finite element\n        const auto graduDCoeffsJ\n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeffs), on(gridElement), coeffIndices(j));\n        Eigen::Matrix&lt;double, size, size&gt; tmp;\n        tmp.setZero();\n        for (int k = 0; k &lt; gridDimension; ++k)\n          tmp += graduDCoeffsI[k] * graduDCoeffsJ[k];\n        h.block&lt;size, size&gt;(i * size, j * size) += tmp * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"01_framework/localFunctions/#implementations","title":"Implementations","text":"<p>In the following, the local functions that are currently available are summarized. The ansatz functions are denoted as \\(N^i(\\boldsymbol{\\xi})\\) in the table below.</p> Name Interpolation formula Note Header Standard $$ \\boldsymbol{x} = \\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i  $$ - <code>standardLocalFunction.hh</code> Projection-Based<sup>2</sup> $$ \\boldsymbol{x} = P\\left(\\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\right) $$ This is one version of geometric finite elements. These are finite elements suited  for interpolation on manifolds. Here \\(P: \\mathbb{R}^m \\rightarrow \\mathcal{M}\\) is an operator that projects  the usual linear interpolation onto a manifold. <code>projectionBasedLocalFunction.hh</code>"},{"location":"01_framework/localFunctions/#how-to-implement-your-own-local-functions","title":"How to implement your own local functions","text":"<p>To implement your own local function, the file <code>ikarus/localFunctions/impl/localFunctionTemplate.hh</code> is made available.</p> <p>The file can be copied, and then you can rename the class to your preferred name and implement the functions mentioned below. If a particular function is not required, it has to be deleted explicitly. Then, if someone calls that function, it returns a zero matrix or vector of appropriate size.</p> <p>These functions are all templated with <code>DomainTypeOrIntegrationPointIndex</code>, which is an integration point index or position. Additionally, <code>On&lt;TransformArgs&gt;</code> specifies whether the function should be evaluated on the reference element or the grid element (see above).</p> <pre><code>FunctionReturnType evaluateFunctionImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                        const On&lt;TransformArgs&gt;&amp;) const; // (1)!\n\nJacobian evaluateDerivativeWRTSpaceAllImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                           const On&lt;TransformArgs&gt;&amp; transArgs) const; // (2)!\n\nJacobianColType evaluateDerivativeWRTSpaceSingleImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                                     int spaceIndex, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (3)!\n\n\nCoeffDerivMatrix evaluateDerivativeWRTCoeffsImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                                 int coeffsIndex, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (4)!\n\nCoeffDerivMatrix evaluateSecondDerivativeWRTCoeffsImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                                       const std::array&lt;size_t, 2&gt;&amp; coeffsIndex,\n                                                       const Along&lt;AlongArgs...&gt;&amp; alongArgs,\n                                                       const On&lt;TransformArgs&gt;&amp; transArgs) const; // (5)!\n\nstd::array&lt;CoeffDerivEukRieMatrix, gridDim&gt; evaluateDerivativeWRTCoeffsANDSpatialImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, int coeffsIndex,\n    const On&lt;TransformArgs&gt;&amp; transArgs) const; // (6)!\n\n\nCoeffDerivEukRieMatrix evaluateDerivativeWRTCoeffsANDSpatialSingleImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, int coeffsIndex, int spatialIndex,\n    const On&lt;TransformArgs&gt;&amp; transArgs) const;  // (7)!\n\n\nauto evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, const std::array&lt;size_t, 2&gt;&amp; coeffsIndex,\n    const Along&lt;AlongArgs...&gt;&amp; alongArgs, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (8)!\n\nCoeffDerivMatrix evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialSingleImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, const std::array&lt;size_t, 2&gt;&amp; coeffsIndex,\n    const int spatialIndex, const Along&lt;AlongArgs...&gt;&amp; alongArgs, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (9)!\n</code></pre> <ol> <li>This is called by <code>localFunction.evaluate(...)</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(coeff(j,k)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll,coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i),coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll,coeff(j,k)), along(A))</code>. <code>A</code> can be accessed via <code>std::get&lt;0&gt;(alongArgs.args)</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i),coeff(j,k)), along(v))</code>. <code>v</code> can be accessed via <code>std::get&lt;0&gt;(alongArgs.args)</code>.</li> </ol>"},{"location":"01_framework/localFunctions/#expressions","title":"Expressions","text":"<p>Expression templates are usually used in linear algebra libraries, e.g., Eigen or Blaze. The syntax is similar to the one provided by UML but only acts on local functions. Expression templates are used here to combine existing local functions in order to obtain new nested ones.</p> <p>For example, consider the following code:</p> <pre><code>...\nauto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0, sharedGeometry);\nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1, sharedGeometry);\n</code></pre> <p>Two local functions that satisfy the interface described above are created. Now it is possible to combine these functions and get an object that also satisfies the concept above. Thus, the following is possible:</p> <pre><code>...\nauto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0, sharedGeometry);\nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1, sharedGeometry);\nauto k = f + g;\nk.evaluateDerivative(ipIndex, wrt(coeff(i), spatial(d)));\n</code></pre> <p>Currently, binary and unary expressions are supported. The following expressions are defined:</p> Name Mathematical formula Code Note Sum $$ \\boldsymbol{f} + \\boldsymbol{g}  $$ <code>f+g</code> \\(\\boldsymbol{f}\\)  and  \\(\\boldsymbol{g}\\) needs to be of the same size. DotProduct $$ \\boldsymbol{f} \\cdot \\boldsymbol{g} = f_i g_i $$ <code>dot(f,g)</code> \\(\\boldsymbol{f}\\)  and  \\(\\boldsymbol{g}\\) needs to be of the same size. normSquared $$ \\boldsymbol{f} \\cdot \\boldsymbol{f} = f_i f_i $$ <code>normSquared(f)</code> Negate $$ -\\boldsymbol{f}  $$ <code>-f</code> sqrt $$ \\sqrt{f}  $$ <code>sqrt(f)</code> The function \\(f\\) needs a scalar return type. log $$ \\log{f}  $$ <code>log(f)</code> The function \\(f\\) needs a scalar return type. Here, log is the natural logarithm. pow $$ f^n  $$ <code>pow&lt;n&gt;(f)</code> The function \\(f\\) needs a scalar return type. \\(n\\) is an integer given during compile-time. Scale $$  a f , \\quad a \\in  \\mathbf{R}$$ <code>a*f</code> and <code>f/a</code> <code>a</code> has to satisfy <code>std::is_arithmetic&lt;..&gt;</code> LinearStrains $$ \\frac{1}{2}\\left(\\boldsymbol{H}+\\boldsymbol{H}^T \\right),\\quad \\boldsymbol{H} = \\mathrm{grad}(\\boldsymbol{f})  $$ <code>linearStrains(f)</code> If you call the formula on the left with <code>on(gridElement)</code>, it will assume the transformed derivatives. GreenLagrangianStrains $$ \\frac{1}{2}\\left(\\boldsymbol{H}+\\boldsymbol{H}^T +\\boldsymbol{H}^T \\boldsymbol{H}\\right),\\quad \\boldsymbol{H} = \\mathrm{grad}(\\boldsymbol{f})  $$ <code>greenLagrangianStrains(f)</code> If you call the formula on the left with <code>on(gridElement)</code>, it will assume the transformed derivatives. <p>These expressions can also be nested. As a result, it is valid to write</p> <pre><code>auto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0);\nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1);\nauto k = -sqrt(dot(2*f+f,5*g));\nk.evaluateDerivative(ipIndex, wrt(coeff(i), spatial(d)));\n</code></pre> <p>To use these expressions, there are additional exported static types for all expressions.</p> <pre><code>constexpr bool isLeaf; // (1)!\nconstexpr bool children; // (2)!\n</code></pre> <ol> <li>This is true if the underlying expression is one of the above local functions that really contain the coefficients; see Implementations.</li> <li>Returns the number of children (2 for binary expressions and 1 for unary expressions).</li> </ol> <p>Note</p> <p>To use these expression, simply include the header <code>#include &lt;dune/localfefunctions/expressions.hh&gt;</code>.</p>"},{"location":"01_framework/localFunctions/#tagging-leaf-local-functions","title":"Tagging leaf local functions","text":"<p>In the context of mixed finite elements, there are usually several local functions that contribute to the energy. These stem from different local bases. For example, consider the Q1P0 element, where displacements are interpolated by using the four bilinear ansatz functions and the element-wise constant pressure field.</p> <p>Then, to obtain gradients and Hessians, we need to differentiate w.r.t. different coefficients. This can be done by tagging the local function during construction.</p> <pre><code>using namespace Dune::Indices;\nauto f = Ikarus::StandardLocalFunction(localBasis0, coeffVectors0, sharedGeometry, _0);\nauto g = Ikarus::StandardLocalFunction(localBasis1, coeffVectors1, sharedGeometry, _1);\nauto k = dot(f,g);\nk.evaluateDerivative(ipIndex, wrt(coeff(_0,i,_1,j))); // Second derivative w.r.t. the nodal coefficients\n</code></pre> <p>To explain the last line above, let us consider that the function f is constructed as \\(f= \\sum_{I=0}^n N^L f_L\\) and similarly \\(g= \\sum_{I=0}^m M^K g_K\\), where \\(N\\) and \\(M\\) are ansatz functions and \\(f_L\\) and \\(g_K\\) are nodal coefficients.</p> <p>Thus, the above call translates to</p> \\[\\begin{align} \\frac{\\partial^2 (\\boldsymbol{f} \\cdot \\boldsymbol{g} )}{\\partial \\boldsymbol{f}_i\\partial \\boldsymbol{g}_j}, \\end{align}\\] <p>where the correct sizes of the result are derived at compile-time. The complete Hessian of \\(\\boldsymbol{f} \\cdot \\boldsymbol{g}\\) can be calculated by the following:</p> <pre><code>using namespace Dune::Indices;\nauto hessianDirichletEnergy(Matrix&amp; h) {\n  //... bind localBasis to some integration rule\n  using namespace Dune::Indices;\n  auto f = Ikarus::StandardLocalFunction(localBasis0, coeffVectors0, sharedGeometry, _0);\n  auto g = Ikarus::StandardLocalFunction(localBasis1, coeffVectors1, sharedGeometry, _1);\n  auto k = dot(f,g);\n  constexpr int sizef = f.correctionSize; // spatial size of the correction of the coefficients of f\n  constexpr int sizeg = g.correctionSize; // spatial size of the correction of the coefficients of g\n  constexpr int coeffSizef = coeffVectors0.size();\n  constexpr int coeffSizeg = coeffVectors1.size();\n\n  Dune::MultiTypeBlockMatrix&lt;Dune::MultiTypeBlockVector&lt;MatrixBlock00,MatrixBlock01&gt;,\n                                       Dune::MultiTypeBlockVector&lt;MatrixBlock10,MatrixBlock11&gt; &gt; KBlocked; // (1)!\n\n\n  for (const auto&amp; [gpIndex, gp] : k.viewOverIntegrationPoints()) {\n    for (size_t I = 0; I &lt; coeffSizef; ++I)\n      for (size_t J = 0; J &lt; coeffSizef; ++J)\n        KBlocked[_0,_0].block&lt;sizef, sizef&gt;(I * sizef, J * sizef)\n          += k.evaluateDerivative(gpIndex, wrt(coeff(_0,I,_0,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n\n    for (size_t I = 0; I &lt; coeffSizef; ++I)\n      for (size_t J = 0; J &lt; coeffSizeg; ++J)\n        KBlocked[_0,_1].block&lt;sizef, sizeg&gt;(I * sizef, J * sizeg)\n          += k.evaluateDerivative(gpIndex, wrt(coeff(_0,I,_1,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n\n    for (size_t I = 0; I &lt; coeffSizeg; ++I)\n      for (size_t J = 0; J &lt; coeffSizeg; ++J)\n        KBlocked[_1,_1].block&lt;sizeg, sizeg&gt;(I * sizeg, J * sizeg)\n          += k.evaluateDerivative(gpIndex, wrt(coeff(_1,I,_1,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n\n    for (size_t I = 0; I &lt; coeffSizeg; ++I)\n      for (size_t J = 0; J &lt; coeffSizef; ++J)\n        KBlocked[_1,_0].block&lt;sizef, sizeg&gt;(I * sizeg, J * sizef)\n          += k.evaluateDerivative(gpIndex, wrt(coeff(_1,I,_0,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n    }\n}\n</code></pre> <ol> <li>This block structure is not necessary. Additionally, in this example, all types (MatrixBlock00, MatrixBlock01, MatrixBlock10,    MatrixBlock11) are considered as <code>Eigen::MatrixXd</code>.</li> </ol>"},{"location":"01_framework/localFunctions/#writing-your-own-expressions","title":"Writing your own expressions","text":"<p>It is also possible to write your own expressions. To do so, please take a look at the existing expressions. The <code>sqrt</code> and <code>normSquared</code> expressions are the most general unary and binary expressions implemented.</p>"},{"location":"01_framework/localFunctions/#implementing-the-return-value","title":"Implementing the return value","text":"<p>Implementing a return value is the first step in implementing an expression. This is done by using the following function:</p> <pre><code>template &lt;typename LFArgs&gt;\nauto evaluateValueOfExpression(const LFArgs &amp;lfArgs) const;\n</code></pre> <p>Warning</p> <p>The interface dictates that the return value needs to be an <code>Eigen</code> type. Thus, even if a scalar double is to be returned, it is to</p> <p>be wrapped in <code>Eigen::Vector&lt;double, 1&gt;</code></p> <p>Additionally, the evaluation of the derivative is to be implemented as shown below:</p> <pre><code>template &lt;int DerivativeOrder, typename LFArgs&gt;\nauto evaluateDerivativeOfExpression(const LFArgs &amp;lfArgs) const;\n</code></pre>"},{"location":"01_framework/localFunctions/#evaluate-the-underlying-functions","title":"Evaluate the underlying functions","text":"<p>Expressions always act on existing expressions. Therefore, to have the correct return value for the expression, the underlying quantities are to be evaluated. <code>this-&gt;m()</code> is used to access unary functions, and <code>this-&gt;l()</code> and <code>this-&gt;r()</code> are used to access binary expressions.</p> <p>To evaluate unary functions, the following syntax is used:</p> <pre><code>const auto mEvaluated = evaluateFunctionImpl(this-&gt;m(), lfArgs);\n</code></pre> <p>and for binary functions,</p> <pre><code>const auto l_Evaluated = evaluateFunctionImpl(this-&gt;l(), lfArgs);\nconst auto r_Evaluated = evaluateFunctionImpl(this-&gt;r(), lfArgs);\n</code></pre> <p>Because the expression conforms to the syntax of a local function, its derivative can also be evaluated.</p> <p>In the function <code>evaluateDerivativeOfExpression</code>, the template argument <code>DerivativeOrder</code> contains the derivative order. Additionally, the derivative types can also be accessed using the static booleans, as shown below:</p> <pre><code>    static constexpr bool hasTwoCoeff;\n    static constexpr bool hasSingleCoeff;\n    static constexpr bool hasNoCoeff;\n    static constexpr bool hasNoSpatial;\n    static constexpr bool hasOneSpatialAll;\n    static constexpr bool hasOneSpatialSingle;\n    static constexpr bool hasOneSpatial;\n</code></pre> <p>Using the dot-product as a binary expression example, we have</p> <pre><code>template &lt;int DerivativeOrder, typename LFArgs&gt;\n    auto evaluateDerivativeOfExpression(const LFArgs &amp;lfArgs) const {\n      const auto u = evaluateFunctionImpl(this-&gt;l(), lfArgs);\n      const auto v = evaluateFunctionImpl(this-&gt;r(), lfArgs);\n      if constexpr (DerivativeOrder == 1)  // (1)!\n      {\n        const auto u_x = evaluateDerivativeImpl(this-&gt;l(), lfArgs); // (2)!\n        const auto v_x = evaluateDerivativeImpl(this-&gt;r(), lfArgs);\n        return Ikarus::eval(v.transpose() * u_x + u.transpose() * v_x); // (3)!\n      } else if constexpr (DerivativeOrder == 2) {   // (4)!\n        const auto &amp;[u_x, u_y] = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (5)!\n        const auto &amp;[v_x, v_y] = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs);\n        if constexpr (LFArgs::hasNoSpatial and LFArgs::hasTwoCoeff) { // (6)!\n          const auto alonguArgs = replaceAlong(lfArgs, along(v)); // (7)!\n          const auto alongvArgs = replaceAlong(lfArgs, along(u));\n\n          const auto u_xyAlongv = evaluateDerivativeImpl(this-&gt;l(), alongvArgs); // (8)!\n          const auto v_xyAlongu = evaluateDerivativeImpl(this-&gt;r(), alonguArgs);\n\n          return Ikarus::eval(u_xyAlongv + transpose(u_x) * v_y + transpose(v_x) * u_y + v_xyAlongu);\n        } else if constexpr (LFArgs::hasOneSpatial and LFArgs::hasSingleCoeff) { // (9)!\n          const auto u_xy = evaluateDerivativeImpl(this-&gt;l(), lfArgs); // (10)!\n          const auto v_xy = evaluateDerivativeImpl(this-&gt;r(), lfArgs);\n          if constexpr (LFArgs::hasOneSpatialSingle and LFArgs::hasSingleCoeff) { // (11)!\n            return Ikarus::eval(transpose(v) * u_xy + transpose(u_x) * v_y + transpose(v_x) * u_y\n                                + transpose(u) * v_xy);\n          } else if constexpr (LFArgs::hasOneSpatialAll and LFArgs::hasSingleCoeff) { // (12)!\n            std::array&lt;std::remove_cvref_t&lt;decltype(Ikarus::eval(transpose(v) * u_xy[0]))&gt;, gridDim&gt; res; // (13)!\n            for (int i = 0; i &lt; gridDim; ++i)\n              res[i] = Ikarus::eval(transpose(v) * u_xy[i] + transpose(u_x.col(i)) * v_y + transpose(v_x.col(i)) * u_y\n                                    + transpose(u) * v_xy[i]);\n            return res;\n          }\n        }\n      } else if constexpr (DerivativeOrder == 3) { // (14)!\n        if constexpr (LFArgs::hasOneSpatialSingle) {  // (15)!\n          const auto argsForDyz = lfArgs.extractSecondWrtArgOrFirstNonSpatial(); // (16)!\n\n          const auto &amp;[u_x, u_y, u_z] = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (17)!\n          const auto &amp;[v_x, v_y, v_z] = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs);\n          const auto &amp;[u_xy, u_xz]    = evaluateSecondOrderDerivativesImpl(this-&gt;l(), lfArgs); // (18)!\n          const auto &amp;[v_xy, v_xz]    = evaluateSecondOrderDerivativesImpl(this-&gt;r(), lfArgs);\n\n          const auto alonguArgs             = replaceAlong(lfArgs, along(u));\n          const auto alongvArgs             = replaceAlong(lfArgs, along(v));\n          const auto argsForDyzalongv_xArgs = replaceAlong(argsForDyz, along(v_x)); // (19)!\n          const auto argsForDyzalongu_xArgs = replaceAlong(argsForDyz, along(u_x));\n\n          const auto u_xyzAlongv = evaluateDerivativeImpl(this-&gt;l(), alongvArgs); // (20)!\n          const auto v_xyzAlongu = evaluateDerivativeImpl(this-&gt;r(), alonguArgs);\n          const auto u_yzAlongvx = evaluateDerivativeImpl(this-&gt;l(), argsForDyzalongv_xArgs); // (21)!\n          const auto v_yzAlongux = evaluateDerivativeImpl(this-&gt;r(), argsForDyzalongu_xArgs);\n\n          return Ikarus::eval(u_xyzAlongv + transpose(u_xy) * v_z + transpose(u_xz) * v_y + v_yzAlongux + u_yzAlongvx\n                              + transpose(v_xz) * u_y + transpose(v_xy) * u_z + v_xyzAlongu);\n        } else if constexpr (LFArgs::hasOneSpatialAll) { // (22)!\n          const auto &amp;alongMatrix = std::get&lt;0&gt;(lfArgs.alongArgs.args); // (23)!\n\n          const auto uTimesA = eval(u * alongMatrix);\n          const auto vTimesA = eval(v * alongMatrix);\n\n          const auto &amp;[gradu, u_c0, u_c1]  = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (24)!\n          const auto &amp;[gradv, v_c0, v_c1]  = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs);\n          const auto &amp;[gradu_c0, gradu_c1] = evaluateSecondOrderDerivativesImpl(this-&gt;l(), lfArgs); // (25)!\n          const auto &amp;[gradv_c0, gradv_c1] = evaluateSecondOrderDerivativesImpl(this-&gt;r(), lfArgs);\n\n          const auto graduTimesA = (gradu * alongMatrix.transpose()).eval();\n          const auto gradvTimesA = (gradv * alongMatrix.transpose()).eval();\n\n          const auto argsForDyz = lfArgs.extractSecondWrtArgOrFirstNonSpatial();\n\n          const auto alonguAArgs          = replaceAlong(lfArgs, along(uTimesA));\n          const auto alongvAArgs          = replaceAlong(lfArgs, along(vTimesA));\n          const auto alonggraduTimesAArgs = replaceAlong(argsForDyz, along(graduTimesA));\n          const auto alonggradvTimesAArgs = replaceAlong(argsForDyz, along(gradvTimesA));\n\n          const auto u_xyzAlongv            = evaluateDerivativeImpl(this-&gt;l(), alongvAArgs);\n          const auto v_xyzAlongu            = evaluateDerivativeImpl(this-&gt;r(), alonguAArgs);\n          const auto v_c0c1AlongGraduTimesA = evaluateDerivativeImpl(this-&gt;r(), alonggraduTimesAArgs);\n          const auto u_c0c1AlongGradvTimesA = evaluateDerivativeImpl(this-&gt;l(), alonggradvTimesAArgs);\n          decltype(eval(u_xyzAlongv)) res;\n\n          res = u_xyzAlongv + v_xyzAlongu + v_c0c1AlongGraduTimesA + u_c0c1AlongGradvTimesA;\n          for (int i = 0; i &lt; gridDim; ++i)\n            res += (transpose(u_c1) * gradv_c0[i] + transpose(v_c1) * gradu_c0[i] + transpose(v_c0) * gradu_c1[i]\n                    + transpose(u_c0) * gradv_c1[i])\n                   * alongMatrix(0, i);\n\n          return res;\n\n        }\n      }\n    }\n</code></pre> <ol> <li>Compile-time branch for first-order derivatives</li> <li>Evaluates the derivative of <code>this-&gt;l()</code> in relation to the only derivative contained within the local function arguments <code>lfArgs</code>.</li> <li>Evaluates the return value; derivatives and function values are combined as dictated by the product rule.</li> <li>Compile-time branch for second-order derivatives</li> <li>We have four cases for evaluating functions because we are in the second-order derivatives branch: the function value, the function    derivative w.r.t. the first argument or the second argument, and the function's derivative w.r.t. both arguments.    Here, the function <code>evaluateFirstOrderDerivativesImpl</code> returns the derivatives w.r.t. the first argument and the second argument.    If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\), this calls returns    \\begin{flalign*}    \\verb+u_x+ &amp;= \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{\\xi}} \\quad \\text{or} \\quad \\verb+u_x+ = \\frac{\\partial\\boldsymbol{u}}    {\\partial\\xi_0} \\quad \\text{or} \\quad \\verb+u_x+ = \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{u}_I}\\\\    \\verb+u_y+ &amp;= \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{u}_J}    \\end{flalign*}    The first one would be returned if it is called as</li> </ol> <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i)));\n</code></pre> <p>and the second one if it is called as</p> <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i)));\n</code></pre> <p>and the third without any spatial derivative is returned using</p> <pre><code>    u.evaluateDerivative(gpIndex, wrt(coeff(i,j)));\n</code></pre> <p>Therefore, this function separates the two <code>wrt</code> arguments and returns the corresponding first order derivatives. 6. Compile-time branch for the case where no spatial derivatives are requested but only the derivatives w.r.t. coefficients are needed. 7. Creates a new argument variable where the <code>along</code> argument is replaced by <code>v</code>. 8. This function evaluates the derivatives of <code>l</code> w.r.t. to both <code>wrt</code> arguments. Furthermore, it takes the <code>along</code> argument since    otherwise the returned object would be a 3-dimensional array.    If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\)  and \\(\\boldsymbol{v}\\) of the same size as    \\(\\boldsymbol{u}\\) this calls returns    \\begin{flalign*}    \\verb+u_xyAlongv + &amp;= \\frac{\\partial^2 u_i }{\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} v_i    \\end{flalign*}    This is the same if the following is called:</p> <pre><code>    u.evaluateDerivative(gpIndex, wrt(coeff(i,j)),along(v));\n</code></pre> <ol> <li>Compile-time branch for the case where one spatial derivative and one derivative w.r.t. the coefficients is needed.</li> <li> <p>This function evaluates the derivatives of <code>l</code> w.r.t. to both <code>wrt</code> arguments.    If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\)  this calls returns    \\begin{flalign*}    \\verb+u_xy+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_I}    \\quad \\text{or} \\quad \\verb+u_xy+ = \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\xi_0\\partial\\boldsymbol{u}_I}    \\end{flalign*}    The first one would be returned if it is called as</p> <pre><code>   u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i)));\n</code></pre> <p>and the second one if it is called as</p> <pre><code>u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i)));\n</code></pre> <p>In the first case the result is stored in an array. Thus, in the first index, the derivative w.r.t. to the first spatial coordinate is stored. Therefore, we have</p> <pre><code>spatialAllCoeffDeriv = u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i)));\nspatialAllCoeffDeriv[0] // derivative as in u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i)));\nspatialAllCoeffDeriv[1] // derivative as in u.evaluateDerivative(gpIndex, wrt(spatial(1),coeff(i)));\n</code></pre> </li> <li> <p>Compile-time branch for the case where one single spatial derivatives and one derivative w.r.t. coefficients is needed.</p> </li> <li>Compile-time branch for the case where all spatial derivatives and one derivative w.r.t. coefficients is needed.</li> <li>The return type here is an array of single spatial derivatives and each derived w.r.t. the coefficient. Thus, the type inside the     array must be deduced here.</li> <li>Compile-time branch for third order derivatives</li> <li>Compile-time branch for single spatial derivatives</li> <li> <p>To obtain derivatives w.r.t. to the second and third <code>wrt</code> argument, we extract the arguments here. E.g., for the following request:</p> <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix));\n</code></pre> <p>This call would extract the arguments as</p> <pre><code>newArgs =  \"wrt(coeff(i,j)),along(matrix))\" //THIS IS NO VALID SYNTAX\n</code></pre> <p>This can then be used as</p> <pre><code>u.evaluateDerivative(gpIndex, newArgs);\n</code></pre> </li> <li> <p>As in the second order derivative case, it returns all the three first order derivatives. E.g., for the case,</p> <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix));\n</code></pre> <p>the returned values would be \\begin{flalign*} \\verb+u_x+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}} \\\\ \\verb+u_y+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{u}_I} \\\\ \\verb+u_z+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{u}_J} \\end{flalign*} 18. This returns the derivatives w.r.t. the given spatial direction and w.r.t. the first and second coefficient.  E.g., for the case,</p> <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix));\n</code></pre> <p>the returned values would be \\begin{flalign*} \\verb+u_xy+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_I} \\\\ \\verb+u_xz+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_J} \\\\ \\end{flalign*} 19. Creates a new argument variable where the <code>along</code> argument is replaced by <code>v_x</code>. 20. This return call would be</p> <pre><code>u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i,j),along(v));\n</code></pre> <p>In mathematical notation, it returns \\begin{flalign*} \\verb+u_xyzAlongv  + &amp;= \\frac{\\partial^3 u_i }{\\partial \\xi_0\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} v_i \\end{flalign*} 21. This return would be</p> <pre><code>v_x = v.evaluateDerivative(gpIndex, wrt(spatial(0));\nu_yzAlongvx = u.evaluateDerivative(gpIndex, wrt(coeff(i,j),along(v_x));\n</code></pre> <p>In mathematical notation, it returns \\begin{flalign*} \\verb+u_yzAlongvx+ &amp;= \\frac{\\partial^2 u_i }{\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} \\left[\\frac{\\partial \\boldsymbol{v}}{\\xi_0}\\right]_i \\end{flalign*} 22. Compile-time branch for all spatial derivatives 23. Obtain the <code>along</code> argument defined, for example, in</p> <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j),along(matrix));\n</code></pre> </li> <li> <p>Similar to the single spatial case</p> </li> <li>Similar to the single spatial case</li> </ol> <p>If your expression is working, it can be added to <code>dune/localfefunctions/expressions.hh</code> by submitting a PR to dune-localfefunctions.</p> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal, 57(1):404\u2013428, 2019. doi:10.1137/18M1176798.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/manifolds/","title":"Manifold elements","text":"<p>Usually optimization problems are defined in terms of a cost function, such as:</p> <p>$$  \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) $$ where \\( f: \\mathcal{M} \\rightarrow \\mathbb{R} \\).</p> <p>Usually \\( \\mathcal{M} \\) is an Euclidean vector space \\( \\mathbb{R}^n \\).</p> <p>In a finite element context, for example, in 2D elasticity problems, we have a two-dimensional displacement for each node. As a result, if there are \\(n \\) nodes, we optimize in \\( {\\mathbb{R}^{2n}} \\).</p> <p>The nodal degrees of freedom should be wrapped in <code>Ikarus::RealTuple&lt;double,2&gt;</code> in this case.</p> <p>Another case of optimization is on non-linear manifolds. These arise typically for Cosserat materials \\( \\mathcal{S}\\mathcal{O}(3) \\)<sup>1</sup>, Reissner-Mindlin shells \\( \\mathcal{S}^2 \\)<sup>2</sup> and micro-magnetics \\( \\mathcal{S}^{2} \\) or incompressible materials.</p>"},{"location":"01_framework/manifolds/#interface","title":"Interface","text":"<p>The general interface of the manifold elements is represented by the following concept.</p> <pre><code>namespace Ikarus::Concepts {\n  template &lt;typename ManifoldType&gt;\n  concept Manifold = requires(ManifoldType var, typename ManifoldType::CorrectionType correction, std::ostream&amp; s,\n                              typename ManifoldType::CoordinateType value) {\n    typename ManifoldType::ctype; // (1)!\n    ManifoldType::valueSize; // (2)!\n    ManifoldType::correctionSize; // (3)!\n    typename ManifoldType::CoordinateType; // (4)!\n    typename ManifoldType::CorrectionType; // (5)!\n    { var.getValue() } -&gt; std::convertible_to&lt;typename ManifoldType::CoordinateType&gt;; // (6)!\n    { var.setValue(value) } -&gt; std::same_as&lt;void&gt;; // (7)!\n    { var+=correction };  // (8)!\n    //...\n  };\n}\n</code></pre> <ol> <li>The type for the coordinate values, usually <code>double</code>.</li> <li>The number of values to store for the state of the element. E.g., the three-dimensional unit vector needs three entries to store its    state.</li> <li>The size of the correction for an element. <code>valueSize</code> and <code>correctionSize</code> are the same in Euclidean space. But, for example, the    three-dimensional unit vector needs a two-dimensional correction (which lives in the tangent space).</li> <li>The type to store the element coordinates is usually <code>Eigen::Vector&lt;double,ManifoldType::valueSize&gt;</code></li> <li>The type to store the element correction type is usually <code>Eigen::Vector&lt;double,ManifoldType::correctionSize&gt;</code></li> <li>Access the underlying coordinate vector of the manifold element.</li> <li>Directly set the value. E.g., set <code>Ikarus::UnitVector&lt;double,3&gt; a; a.setValue(Eigen::Vector3d::UnitZ());</code></li> <li> <p>Update the element with a correction vector. E.g.,</p> <pre><code>   Ikarus::RealTuple&lt;double,3&gt; a;\n   a+= Eigen::Vector3d::UnitX();\n\n   Ikarus::UnitVector&lt;double,3&gt; b;\n   b+= Eigen::Vector2d::UnitX();\n</code></pre> </li> </ol>"},{"location":"01_framework/manifolds/#implementations","title":"Implementations","text":"Name Formal definition Notes Header \\(n\\)-th dimensional Euclidean space $$ \\boldsymbol{x} \\in \\mathbb{R}^n  $$ <code>realTuple.hh</code> Unit sphere $$ \\boldsymbol{x} \\in \\mathcal{S}^{n-1}, \\quad \\mathcal{S}^{n-1} = \\left\\{ \\boldsymbol{x} \\in \\mathbb{R}^n :  \\boldsymbol{x}\\cdot  \\boldsymbol{x}  = 1 \\right\\}  $$ <code>unitVector.hh</code> <ol> <li> <p>Oliver Sander. Geodesic finite elements for cosserat rods. International Journal for Numerical Methods in Engineering, 82(13):1645\u20131670, 2010. doi:10.1002/nme.2814.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/nonlinearOperator/","title":"Nonlinear operator","text":"<p>The class <code>NonLinearOperator</code> consists of a collection of a function and its derivatives, including their dependence on parameters.</p> <p>Let us assume a function <code>f(x)</code> and its derivative <code>df(x)</code>. Then, a <code>NonLinearOperator</code> can be constructed as follows:</p> <pre><code>double x               = 13;\nauto fvLambda  = [&amp;](auto&amp;&amp; x) { return f(x); };\nauto dfvLambda = [&amp;](auto&amp;&amp; x) { return df(x); };\n\nauto nonLinOp = Ikarus::NonLinearOperator(functions(fvLambda, dfvLambda), parameter(x));\n</code></pre> <p>Note</p> <p>It is assumed that the second function is the derivative of the first function, the third function is the derivative of the second function (2<sup>nd</sup> derivative of the first function), and so on.</p> <p><code>functions(...)</code> and <code>parameter(...)</code> are helper functions. They are necessary to distinguish which argument is a function and which argument is a parameter.</p> <p><code>nonLinOp</code> provides the following features:</p> <pre><code>void updateAll() // (1)!\nvoid update&lt;n&gt;() // (2)!\nauto&amp; value() // (3)!\nauto&amp; derivative() // (4)!\nauto&amp; secondDerivative() // (5)!\nauto&amp; nthDerivative&lt;n&gt;() // (6)!\nauto&amp; firstParameter() // (7)!\nauto&amp; secondParameter() // (8)!\nauto&amp; nthParameter&lt;n&gt;() // (9)!\nauto&amp; lastParameter() // (10)!\nauto subOperator&lt;n,m,...&gt;() // (11)!\n</code></pre> <ol> <li>Evaluates all functions.</li> <li>Evaluates the n-th function in <code>functions(...)</code> . Counting starts from 0, as always in C++.</li> <li>Returns the result of the function evaluation.</li> <li>Returns the result of the evaluation of the first derivative (if the function for the first derivative is passed to the nonlinear    operator during construction).</li> <li>Returns the result of the evaluation of the second derivative (if the function for the second derivative is passed to the nonlinear    operator during construction).</li> <li>Returns the result of the evaluation of the n-th derivative (if the function for the n-th derivative is passed to the nonlinear    operator during construction).</li> <li>Returns the value of the first parameter.</li> <li>Returns the value of the second parameter (if available).</li> <li>Returns the value of the n-th parameter (if available).</li> <li>Returns the value of the last parameter.</li> <li>Creates an <code>Ikarus::NonLinearOperator</code> with a subset of the derivatives. For example, let us consider a nonlinear operator with     (function, first derivative, second derivative). <code>subOperator&lt;0,1&gt;()</code> then returns a nonlinear operator with     (function, first derivative).</li> </ol>"},{"location":"01_framework/observer/","title":"Observer and Observable","text":"<p>To write output messages when desired by the user, the observer pattern is implemented in Ikarus. Four things are necessary to understand the implementation of observer patterns: <code>Messages</code>, <code>IObservable</code>, <code>IObserver</code> and <code>Subscriptions</code>.</p>"},{"location":"01_framework/observer/#messages","title":"Messages","text":"<p>A message class is a list of possible events that can happen and might be of interest. The messages that are used for nonlinear solvers are listed below as an example.</p> <pre><code>enum class NonLinearSolverMessages {\n  BEGIN,\n  INIT,\n  ITERATION_STARTED,\n  ITERATION_ENDED,\n  RESIDUALNORM_UPDATED,\n  CORRECTIONNORM_UPDATED,\n  SOLUTION_CHANGED,\n  FINISHED_SUCESSFULLY,\n  END\n};\n</code></pre>"},{"location":"01_framework/observer/#iobservable","title":"IObservable","text":"<p>A class can be observable. The class then sends notifications when events are happening. To become observable, a class must inherit from <code>IObservable&lt;MessageType&gt;</code>, for example,</p> <pre><code>class NewtonRaphson : public IObservable&lt;NonLinearSolverMessages&gt; {...};\n</code></pre> <p>The function <code>this-&gt;notify(MessageType::Message)</code> is called at the appropriate position in the code to send a notification. This could be, for example,</p> <pre><code>this-&gt;notify(NonLinearSolverMessages::SOLUTION_CHANGED);\n</code></pre>"},{"location":"01_framework/observer/#iobserver","title":"IObserver","text":"<p>A class can be an observer. The class is then notified when events are happening and can perform actions. A very simple example is shown below. To become an observer, the class must inherit from <code>IObserver&lt;MessageType&gt;</code>, where <code>MessageType</code> is the <code>enum</code> of messages to use (see above).</p> <pre><code>class OurFirstObserver : public IObserver&lt;NonLinearSolverMessages&gt; {\npublic:\n  void updateImpl(NonLinearSolverMessages message) override {\n    if (message == NonLinearSolverMessages::ITERATION_STARTED) std::cout &lt;&lt; \"Iteration started.\\n\";\n  }\n};\n</code></pre> <p>The observer has to implement the function <code>void updateImpl(MessageType message)</code>. In this function, all actions can be implemented that should be performed when the corresponding message is received.</p> <p>To connect observer and observable, one has to call <code>observalbe.subscribe(MessageType::Message,observer)</code>. Example:</p> <pre><code>Ikarus::NewtonRaphson nr(...);\nauto ourSimpleObserver = std::make_shared&lt;OurFirstObserver&gt;();\nnr.subscribe(NonLinearSolverMessages::ITERATION_STARTED, ourSimpleObserver);\n};\n</code></pre>"},{"location":"01_framework/observer/#subscriptions","title":"Subscriptions","text":"<p>There are a couple of options for the subscription:</p> <pre><code>subscribe(MessageType::Message,observer) // (1)!\nsubscribeAll(observer) // (2)!\nsubscribeAll({observer1,observer2}) // (3)!\nunSubscribe(...) // (4)!\n</code></pre> <ol> <li>Subscribe to one specific message.</li> <li>Subscribes to all the messages in <code>enum</code>.</li> <li>Multiple observers can subscribe at once.</li> <li>Unsubscribe from specific messages or all messages.</li> </ol> <p>To send a message together with data, the sender (observable) calls</p> <pre><code>this-&gt;notify(MessageType::Message, data);\n</code></pre> <p>and the receiver (observer) has to implement</p> <pre><code>void updateImpl(MessageType message, data) override {...}\n</code></pre> <p>To see all available options for <code>data</code>, we refer to the file <code>observer.hh</code>.</p>"},{"location":"01_framework/solvers/","title":"Solvers","text":"<p>In Ikarus, there are essentially two types of solvers: linear and non-linear.</p>"},{"location":"01_framework/solvers/#linear-solver","title":"Linear solver","text":"<p>It solves for the vector \\( \\boldsymbol{x} \\) in</p> <p>$$ \\boldsymbol{A}  \\boldsymbol{x} =  \\boldsymbol{b} $$ where \\(\\boldsymbol{A} \\) and \\(\\boldsymbol{b}\\) are any matrix or vector, respectively. These solvers can be direct or iterative. Furthermore, they depend on the underlying structure of the matrix \\(\\boldsymbol{A} \\), i.e., whether it is stored in a <code>dense</code> or <code>sparse</code> format.</p> <p>Currently, only the linear solvers provided by the Eigen library are supported.</p> <p>Linear solvers can be constructed by calling the constructor:</p> <pre><code>LinearSolver(const SolverTypeTag&amp; solverTypeTag)\n</code></pre> <p>There exists an enum type <code>SolverTypeTag</code> with the following values:</p> <pre><code>namespace Ikarus {\n\n/**\n * \\enum SolverTypeTag\n * \\brief Enumeration representing different solver types.\n * \\details The prefix s and d stand for sparse and dense solvers and the second prefix i and d stand for iterative or\n * direct solvers for the sparse case\n */\nMAKE_ENUM(SolverTypeTag, none, si_ConjugateGradient, si_LeastSquaresConjugateGradient, si_BiCGSTAB, sd_SimplicialLLT,\n          sd_SimplicialLDLT, sd_SparseLU, sd_SparseQR, sd_CholmodSupernodalLLT, sd_UmfPackLU, sd_SuperLU,\n          d_PartialPivLU, d_FullPivLU, d_HouseholderQR, d_ColPivHouseholderQR, d_FullPivHouseholderQR,\n          d_CompleteOrthogonalDecomposition, d_LLT, d_LDLT);\n\n/**\n * \\enum MatrixTypeTag\n * \\brief Enumeration representing different matrix types (Dense or Sparse).\n */\nenum class MatrixTypeTag\n{\n  Dense,\n</code></pre> <p>The prefixes <code>s_</code> and  <code>d_</code> indicate whether the linear solver can be used for <code>sparse</code> or <code>dense</code> matrices, respectively. Furthermore, there is also a second prefix for sparse solvers: <code>d</code> and <code>i</code> for direct solvers and for iterative solvers, respectively. Thus, using <code>si_ConjugateGradient</code> means that this solver is for sparse matrices and is an iterative solver.</p> <p>Note</p> <p>All dense solvers are currently direct solvers. Therefore, we do not distinguish them.</p> <p>The naming of the solvers is the same as in the Eigen library. For more details on the solvers, we refer to Eigen's documentation for dense decompositions and to Eigen's documentation for sparse decompositions.</p>"},{"location":"01_framework/solvers/#interface","title":"Interface","text":"<p>Similar to Eigen's interface, the following functions are provided:</p> <pre><code>void analyzePattern(const MatrixType&amp; A);  // (1)!\nvoid factorize(const MatrixType&amp; A); // (2)!\nLinearSolver&amp; compute(const MatrixType&amp; A); // (3)!\nvoid solve(Eigen::VectorX&lt;ScalarType&gt;&amp;x, const Eigen::VectorX&lt;ScalarType&gt;&amp; b); // (4)!\n</code></pre> <ol> <li>If the matrix is sparse, Eigen can collect information on the sparsity pattern of the matrix for a faster <code>solve</code> step. This pattern    does not change if the non-zero entries are modified.</li> <li>This method applies a decomposition technique for direct solvers, e.g., LU decomposition. For iterative solvers, the method is a    non-linear operator.</li> <li>It calls both the functions <code>analyzePattern</code> and <code>factorize</code>.</li> <li>Solves the problem and stores the result in <code>x</code>.</li> </ol> <p>Tip</p> <p>If your algorithm relies on special features or attributes of a linear solver, then the solver is to be directly used. For example, if the <code>.determinant()</code> method of <code>Eigen::SimplicialLDLT</code> is required, it must be called directly because <code>LinearSolver</code>does not support it.</p>"},{"location":"01_framework/solvers/#nonlinear-solver","title":"Nonlinear solver","text":"<p>Non-linear solvers are usually used to solve a kind of optimization problem, e.g., root-finding or minimization problems like: \\begin{align}   \\boldsymbol{R}(\\boldsymbol{x}) \\stackrel{!}{=} \\boldsymbol{0} \\quad \\text{or} \\quad   \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) \\end{align}</p> <p>It has the following interface:</p> <pre><code>void setup(const NewtonRaphsonSettings&amp; p_settings); // (1)!\nSolverInformation solve(const SolutionType&amp; dx_predictor = NoPredictor{}); // (2)!\nauto&amp; nonLinearOperator(); // (3)!\n</code></pre> <ol> <li>With this function, several properties of the nonlinear solver can be set. E.g., residual tolerance or maximum number of iterations</li> <li>Solves the non-linear problem. An initial guess to the function can be passed, otherwise, a zero vector is assumed.    It returns the <code>SolverInformation</code> which contains information like the success of the solution step and more.</li> <li>Just returns the underlying <code>nonLinearOperator</code>, see link.</li> </ol> <p>Note</p> <p>To ease the construction process, the non-linear solver can provide a method <code>make[...]</code> that allows shorter syntax since no <code>std::shared_ptr</code> has to be constructed specifying the template arguments. The construction of the nonlinear solvers can be very different. Therefore, we do not impose an interface for the constructors.</p>"},{"location":"01_framework/solvers/#implementations","title":"Implementations","text":"Name Purpose Constraints on nonlinear operator Header Properties Newton-Raphson Root finding Value and gradient <code>newtonRaphson.hh</code> Locally quadratic convergence Newton-Raphson with scalar subsidiary function Root finding with a scalar function as additional constraint Value, gradient and a scalar function <code>newtonraphsonwithscalarsubsidiaryfunction.hh</code> Locally quadratic convergence Trust-Region Minimization Value, gradient and Hessian <code>trustRegion.hh</code> Globally convergent and locally quadratic convergence <p>To see the Newton-Raphson implementation, we refer to the tests inside <code>nonLinearOperatorTest.cpp</code>, and for the trust-region method, <code>trustRegionTest.cpp</code>.</p>"},{"location":"02_examples/","title":"Examples","text":"<p>In order to understand several features of Ikarus, a set of examples is provided within the finite element framework. These can be found at IkarusExamples. The installation and execution methodologies are briefly discussed in the README file of the repository. Each example is given a unique identification in the beginning of the file name of the form <code>iksXXX</code>. This unique identification is also used in the following instead of the complete <code>*.cpp</code> file name. Auxiliary files for the examples, such as <code>*.msh</code>, <code>*.geo</code>, or <code>*.parset</code> can be found in <code>../../src/testfiles/</code>. In order to add a new example, create a pull request with your executable file in the repository IkarusExamples and, in parallel, update the documentation here. See How to Contribute and How to Edit for more information.</p> <p>The available examples are:</p> Identification Name of the example iks001 Compute the value of \\(\\pi\\) iks002 Cantilever beam with point load iks003 Deformation of an incompressible rubber block iks004 Plate subjected to a surface load iks005 Newton-Raphson method iks006 Non-linear Elasticity for 2D solids iks007 Von-Mises truss iks008 Cook's membrane"},{"location":"02_examples/cantileverBeam/","title":"Cantilever beam with point load","text":""},{"location":"02_examples/cantileverBeam/#description","title":"Description","text":"<p>The example <code>iks002_cantileverBeamOneDGrid.cpp</code> demonstrates a simple implementation of the standard one-dimensional Timoshenko beam element, which is clamped on the left-hand side. A point load is applied on the right-hand side of the beam. It uses <code>Dune::OneDGrid</code> to generate the required grid. The implementation shown here assembles the stiffness matrices explicitly. Advanced implementations of matrix assembly and other features of Ikarus are showcased in the other examples.</p>"},{"location":"02_examples/cantileverBeam/#code-highlights","title":"Code highlights","text":"<p>The <code>main()</code> function calls the following function to run the example.</p> <pre><code>void exampleTimoshenkoBeam(const int polynomialOrderW, // (1)!\nconst int polynomialOrderPhi, // (2)!\nconst int numElements // (3)!\n);\n</code></pre> <ol> <li>polynomial order for the approximation of the displacement <code>w</code></li> <li>polynomial order for the approximation of the rotation <code>phi</code></li> <li>number of elements</li> </ol> <p>This function has pre-defined geometric and material parameters that are mentioned below:</p> <pre><code>const double b  = 1; // (1)!\nconst double L  = 10; // (2)!\nconst double E  = 1000; // (3)!\nconst double G  = E / 2;  // Poisson's ratio = 0 // (4)!\nconst double t  = 1e-3; // (5)!\n</code></pre> <ol> <li>breadth of the beam (rectangular cross-section assumed)</li> <li>length of the beam</li> <li>Young's modulus</li> <li>Shear modulus (Poisson's ratio is assumed to be zero)</li> <li>thickness of the beam (rectangular cross-section assumed)</li> </ol> <p>The material matrix is then defined as</p> <pre><code>Eigen::Matrix2d C;\nC &lt;&lt; EI, 0, 0, GA;\n</code></pre> <p>The one-dimension grid is created by specifying the starting (<code>0</code>) and end (<code>L</code>) points of the beam and using <code>numElements</code>. The grid module <code>Dune::OneDGrid</code><sup>1</sup> is used here. The composite basis feature in Dune allows for different bases for the degrees of freedom <code>w</code> and <code>phi</code>. Empty dense global and local stiffness matrices are then defined along with a global external load vector. The quadrature rule for integration of the stiffness matrix and the external load vector is set up as shown below:</p> <pre><code>const int maxOrderIntegration = std::max(2 * (polynomialOrderW - 1), 2 * polynomialOrderPhi);\nconst auto &amp;rule\n    = Dune::QuadratureRules&lt;double, 1&gt;::rule(ele.type(), maxOrderIntegration, Dune::QuadratureType::GaussLegendre);\n</code></pre> <p>The local element stiffness matrix is then obtained by the following function:</p> <pre><code>void TimoshenkoBeamStiffness(auto &amp;KLocal, auto &amp;localView, auto &amp;gridElement, auto &amp;quadratureRule, const Eigen::Matrix2d &amp;C);\n</code></pre> <p>Access to the information corresponding to the two independent degrees of freedom (<code>w</code> and <code>phi</code>) can be obtained by using the child elements as depicted below:</p> <pre><code>auto wFE   = localView.tree().child(_0);\nauto phiFE = localView.tree().child(_1);\nDune::CachedLocalBasis basisW(wFE.finiteElement().localBasis()); // (1)!\nDune::CachedLocalBasis basisPhi(phiFE.finiteElement().localBasis()); // (2)!\n</code></pre> <ol> <li>a local basis created for <code>w</code></li> <li>a local basis created for <code>phi</code></li> </ol> <p>The determinant of Jacobian is obtained by using <code>auto detJ = gridElement.geometry().volume();</code>. The \\(\\mathbf{B}\\)-operator and the local stiffness matrix are then obtained by</p> <pre><code>Eigen::Matrix2Xd B;\nfor (auto &amp;gp : quadratureRule) { // (1)!\n  basisW.evaluateJacobian(gp.position(), dNwDxi); // (2)!\n  basisPhi.evaluateFunction(gp.position(), Nphi); // (3)!\n  basisPhi.evaluateJacobian(gp.position(), dNphiDxi); // (4)!\n\n  B.setZero(Eigen::NoChange, numDofsPerEle);\n\n  for (unsigned int i = 0; i &lt; wFE.size(); ++i)\n    B(1, wFE.localIndex(i)) = dNwDxi[i] / detJ; // (5)!\n\n  for (unsigned int i = 0; i &lt; phiFE.size(); ++i)\n    B.col(phiFE.localIndex(i)) &lt;&lt; dNphiDxi[i] / detJ, Nphi[i]; // (6)!\n\n  KLocal += B.transpose() * C * B * detJ * gp.weight(); // (7)!\n}\n</code></pre> <ol> <li>Looping over the integration point</li> <li>derivative of the ansatz function of <code>w</code> with respect to the local parametric space</li> <li>ansatz function of <code>phi</code></li> <li>derivative of the basis of <code>phi</code> with respect to the local parametric space</li> <li>Filling up the \\(\\mathbf{B}\\)-operator for the columns corresponding to 'w'</li> <li>Filling up the \\(\\mathbf{B}\\)-operator for the columns corresponding to 'phi'</li> <li>Integrating to arrive at the local stiffness matrix</li> </ol> <p>Assembly of the local element stiffness matrices is done to obtain the global element stiffness matrix, as shown below:</p> <pre><code>for (auto i = 0U; i &lt; localView.size(); ++i)\n  for (auto j = 0U; j &lt; localView.size(); ++j)\n    KGlobal(localView.index(i)[0], localView.index(j)[0]) += KLocal(i, j);\n</code></pre> <p>The point load on the right end of the beam is applied by setting the corresponding entry in the global external load vector to the prescribed value <code>F</code> using the command <code>FExtGlobal(getGlobalDofId(TimoshenkoBeam::w, basis, L)) = F;</code>. The function</p> <pre><code>unsigned int getGlobalDofId(TimoshenkoBeam requestedQuantity, const auto &amp;basis, const double position);\n</code></pre> <p>with</p> <pre><code>enum class TimoshenkoBeam { w, phi };\n</code></pre> <p>is used to get the degree of freedom of the <code>requestedQuantity</code> (<code>w</code> or <code>phi</code>) for the defined <code>basis</code> at position <code>L</code>.</p> <p>The left end of the beam is clamped by using the following code:</p> <pre><code>std::vector&lt;unsigned int&gt; fixedDofs{getGlobalDofId(TimoshenkoBeam::w, basis, 0.0),\n                                    getGlobalDofId(TimoshenkoBeam::phi, basis, 0.0)};\nfor (auto dof : fixedDofs) {\n  KGlobal.col(dof).setZero();\n  KGlobal.row(dof).setZero();\n  KGlobal(dof, dof) = 1.0;\n}\n</code></pre> <p>Finally, the system of equations is solved by using the solver type <code>Ikarus::SolverTypeTag::d_LDLT</code>. For more details on the solver types, refer to the documentation. For post-processing, the deformed configuration of the beam can be plotted using the following function, shown here in the example:</p> <pre><code>void plotDeformedTimoschenkoBeam(auto &amp;gridView, auto &amp;basis, auto &amp;d_glob, double EI, double GA, double L, double F);\n</code></pre> <p>This function uses the plotting features of Matplot++, which has a similar syntax to Matplotlib.</p>"},{"location":"02_examples/cantileverBeam/#takeaways","title":"Takeaways","text":"<ul> <li><code>Dune::OneDGrid</code> can be used to create one-dimensional grids.</li> <li>Grids and quadrature rules from Dune can be directly incorporated into the Ikarus framework.</li> <li>A composite basis can be used to have different ansatz functions for different degrees of freedom.</li> <li>Solvers from the Eigen library can be used to solve the linear system of equations.</li> <li><code>localBasis</code> functions can be used to evaluate the ansatz functions and its derivatives.</li> </ul> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"02_examples/computePi/","title":"Compute the value of \\(\\pi\\)","text":""},{"location":"02_examples/computePi/#description","title":"Description","text":"<p>The example <code>iks001_computePi.cpp</code> shows the calculation of \\(\\pi\\) by computing the area and circumference of a unit circle. This example helps to understand the <code>Grid</code> module from Dune and the refinement techniques it brings. The example shows that a global refinement doesn't refine the number of grid entities on the boundary of the circle, which leads to a poor approximation of \\(\\pi\\) when comparing it with the area and circumference of the circle. On the other hand, it also shows how elements on the boundaries can be marked and refined, thereby resulting in an accurate approximation of \\(\\pi\\).</p>"},{"location":"02_examples/computePi/#code-highlights","title":"Code highlights","text":"<p>This example contains the following two functions:</p> <pre><code>boundaryUnawareRefinedCircle();\nboundaryAwareRefinedCircle();\n</code></pre> <p>demonstrating the usage of certain attributes of the grid module from Dune<sup>1</sup>. Firstly, we explain the function <code>boundaryUnawareRefinedCircle();</code>.</p> <p>Here, a <code>circleCoarse.msh</code> file, which was created using Gmsh, is read using the <code>Dune::GmshReader</code> and a <code>Dune::ALUGrid</code> object is created as shown below:</p> <pre><code>constexpr int gridDim = 2;  // (1)\nusing Grid            = Dune::ALUGrid&lt;gridDim, 2, Dune::simplex, Dune::conforming&gt;;\nauto grid             = Dune::GmshReader&lt;Grid&gt;::read(\"auxiliaryFiles/circleCoarse.msh\", false);\nauto gridView         = grid-&gt;leafGridView();  // (2)\n</code></pre> <p>It is to note that dune-grid only supports Version 2 of the Gmsh format. The <code>draw(gridView);</code> functionality is included within the Ikarus framework to quickly draw grids and verify them for any major errors. The function <code>grid-&gt;globalRefine(1);</code> is invoked to refine the grid on a global level. This means that, if we have a single square-shaped 4-node quadrilateral element, the <code>globalRefine(1)</code> function will bisect the element once in either direction and thereby result in a grid with 2 elements in either direction. This type of refinement is done for triangular elements in the following, and the area of the circle is compared to the value of \\(\\pi\\). The area of the circle itself is obtained by summing the volumes (area in 2D terms) of individual elements.</p> <pre><code>double area = 0.0;\nfor (int i = 0; i &lt; 3; ++i) {\n  area = 0.0;\n  grid-&gt;globalRefine(1);\n  auto gridViewRefined = grid-&gt;leafGridView();\n  std::cout &lt;&lt; \"This gridview contains: \";\n  std::cout &lt;&lt; gridViewRefined.size(0) &lt;&lt; \" elements\" &lt;&lt; std::endl;\n  for (auto &amp;element : elements(gridViewRefined)) {\n    area += element.geometry().volume();\n  }\n  std::cout &lt;&lt; std::setprecision(10) &lt;&lt; \"Area: \" &lt;&lt; area &lt;&lt; \" Pi: \" &lt;&lt; std::numbers::pi &lt;&lt; std::endl;\n}\n</code></pre> <p>The area of individual elements is also written in a <code>*.vtu</code> file using the module <code>Dune::VTKWriter</code>. More explanations of this are found in subsequent examples. In this example, we restrict ourselves to the grid refinement strategies and accessing grid entities from Dune.</p> <p>It is also possible to check if the element has any edges at the boundary using the method <code>element.hasBoundaryIntersections()</code>. If this is true, the edges intersecting with the boundaries can be extracted, and the <code>volume</code> method on this <code>intersection</code> object would then return the length of the edge in the 2D case. The circumference of this unit circle is then computed as shown below:</p> <pre><code>double circumference = 0.0;\nfor (auto &amp;element : elements(gridView))\n  if (element.hasBoundaryIntersections())\n    for (auto &amp;intersection : intersections(gridView, element))\n      if (intersection.boundary()) circumference += intersection.geometry().volume();\n</code></pre> <p>It is observed that even though the grid is globally refined in every loop, the computed value of \\(\\pi\\) never converges. This is due to the fact that the triangular grid doesn't change its area with refinement. Even though the grid has many elements with every refinement, it doesn't contain enough information about the boundary of the circle to predict an accurate value of \\(\\pi\\). In order to refine the boundary entities correctly, the <code>boundaryAwareRefinedCircle()</code> function is formulated and explained next.</p> <p>In this function, the grid is created explicitly and isn't read from an external <code>*.msh</code> file. The corners are calculated manually, which is followed by the insertion of vertices, elements, and boundary segments as shown below:</p> <pre><code>Dune::GridFactory&lt;Dune::ALUGrid&lt;gridDim, 2, Dune::simplex, Dune::conforming&gt;&gt; gridFactory;\nEigen::Vector2d v(1, 0);\nstd::array&lt;FieldVector&lt;double, 2&gt;, 6&gt; corners0;\nEigen::Rotation2D&lt;double&gt; R;\nR.angle() = 0.0;\nfor (auto &amp;corner : corners0) {\n  Eigen::Vector2d a = R * v;\n  corner[0]         = a[0];\n  corner[1]         = a[1];\n  R.angle() += 60.0 / 180.0 * std::numbers::pi;\n}\n\ngridFactory.insertVertex({0, 0});\ngridFactory.insertVertex(corners0[0]);\ngridFactory.insertVertex(corners0[1]);\ngridFactory.insertVertex(corners0[2]);\ngridFactory.insertVertex(corners0[3]);\ngridFactory.insertVertex(corners0[4]);\ngridFactory.insertVertex(corners0[5]);\n\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 1, 2});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 2, 3});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 3, 4});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 4, 5});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 5, 6});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 6, 1});\n\n/// Create boundary segments which map the boundaries onto the unit circle\ngridFactory.insertBoundarySegment({1, 2}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[0], corners0[1]));\ngridFactory.insertBoundarySegment({2, 3}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[1], corners0[2]));\ngridFactory.insertBoundarySegment({3, 4}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[2], corners0[3]));\ngridFactory.insertBoundarySegment({4, 5}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[3], corners0[4]));\ngridFactory.insertBoundarySegment({5, 6}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[4], corners0[5]));\ngridFactory.insertBoundarySegment({6, 1}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[5], corners0[0]));\n\nauto grid     = gridFactory.createGrid();\nauto gridView = grid-&gt;leafGridView();\n</code></pre> <p>To refine the grid entities living in the boundary, the elements that have intersections with the boundary are first marked and then refined, as shown in the code below:</p> <pre><code>for (const auto &amp;ele : elements(grid-&gt;leafGridView())) {\n  if (ele.hasBoundaryIntersections()) grid-&gt;mark(1, ele);\n}\ngrid-&gt;preAdapt();\ngrid-&gt;adapt();\ngrid-&gt;postAdapt();\nauto gridViewRefined = grid-&gt;leafGridView();\n</code></pre> <p>Now, the calculation of area and circumference to determine the value of \\(\\pi\\) converges correctly.</p>"},{"location":"02_examples/computePi/#takeaways","title":"Takeaways","text":"<ul> <li><code>Dune::GmshReader</code> can be used to read <code>*.msh</code> files to import grids.</li> <li>Grid entities can be marked and locally refined, or the grid can be globally refined.</li> <li>Grids can also be explicitly created by inserting vertices, elements, and boundary segments.</li> <li><code>element.hasBoundaryIntersections()</code> can be used to check if an element has any intersections with the boundaries.</li> </ul> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"02_examples/cooksMembrane/","title":"Cook's membrane","text":""},{"location":"02_examples/cooksMembrane/#description","title":"Description","text":"<p>The example <code>iks008_cooksMembrane.cpp</code> implements the Cook's membrane problem adapted from the paper<sup>1</sup>. This problem can be solved not only with the structured meshes provided, but also with unstructured and triangular meshes. The input parameters, like material and grid parameters, are read from the file <code>iks008_cooksMembrane.parset</code>. The problem can also be solved with the standard 2D planar solid element or with enhanced assumed strain elements. For more details on the element technologies, refer to the documentation. <code>iks008</code> solves the problem with a set of existing finite elements and compares the convergence rates.</p>"},{"location":"02_examples/cooksMembrane/#code-highlights","title":"Code highlights","text":"<p>In this example, the standard Q1 finite element and the enhanced assumed strain elements Q1E4, Q1E5, and Q1E7 are used to solve the Cook's membrane problem. Convergence studies are done for the vertical displacement in the top right corner, and the assembly time for the stiffness matrix is also compared. The date and time utilities from the standard C++ library are used to determine the computation times in this example. This example not only loops over the different refinement levels for a convergence plot but also loops over the different element types. In order to avoid re-building the complete code with modifications to certain input parameters, the <code>parametertreeparser.hh</code> can be used from the dune-common module. The <code>Dune::ParameterTree</code> is used to read the Young's modulus (<code>E</code>), the Poisson's ratio (<code>nu</code>), and the level of refinement (<code>refinement_level</code>), as shown below:</p> <pre><code>Dune::ParameterTree parameterSet;\nDune::ParameterTreeParser::readINITree(argv[1], parameterSet);\n\nconst Dune::ParameterTree &amp;gridParameters     = parameterSet.sub(\"GridParameters\");\nconst Dune::ParameterTree &amp;controlParameters  = parameterSet.sub(\"ControlParameters\");\nconst Dune::ParameterTree &amp;materialParameters = parameterSet.sub(\"MaterialParameters\");\n\nconst double E             = materialParameters.get&lt;double&gt;(\"E\");\nconst double nu            = materialParameters.get&lt;double&gt;(\"nu\");\nconst int refinement_level = gridParameters.get&lt;int&gt;(\"refinement\");\n</code></pre> <p><code>argv[1]</code> is the variable in the argument vector that contains <code>iks008_cooksMembrane.parset</code> to read the input parameters. The file <code>cook.msh</code> contains the Cook's membrane problem with a structured grid, whereas <code>cook_tri.msh</code> and <code>cook_unstructured.msh</code> contains the same problem with triangular elements and with an unstructured mesh, respectively. The mesh file is read using <code>Dune::GmshReader</code> and <code>Dune::UGGrid</code> is used to get the <code>grid</code> object. <code>easSet</code> is an <code>Eigen::Vector</code> that contains the number of EAS parameters for the four element types. It is important to note that if the number of EAS parameters is set to zero, the standard Q1 formulation is used.</p> <pre><code>Eigen::Vector&lt;int, 4&gt; easSet;\neasSet &lt;&lt; 0, 4, 5, 7;\n</code></pre> <p>The EAS elements are created then, as shown below:</p> <pre><code>auto numberOfEASParameters = easSet(nep); // (1)!\nstd::vector&lt;Ikarus::EnhancedAssumedStrains&lt;Ikarus::LinearElastic&lt;decltype(basis)&gt;&gt;&gt; fes;\nfor (auto &amp;element : elements(gridView)) {\n  fes.emplace_back(basis, element, E, nu, &amp;volumeLoad, &amp;neumannBoundary, &amp;neumannBoundaryLoad);\n  fes.back().setEASType(numberOfEASParameters);\n}\n</code></pre> <ol> <li><code>nep</code> is the index of the <code>for</code>-loop which runs from 0 to 4 here.</li> </ol> <p>The Dirichlet boundary conditions are defined for the left edge, and the Neumann boundary condition on the right edge is defined by the usage of the dune-python interface. A sparse assembler is used, and the linear system of equations is solved. The vertical displacement in the top right corner is computed as shown below and is later stored in a vector:</p> <pre><code>auto dispGlobalFunc = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;Dune::FieldVector&lt;double, 2&gt;&gt;(*basis, D_Glob);\nauto localView      = basis.flat().localView();\nauto localw         = localFunction(dispGlobalFunc);\ndouble uy_fe        = 0.0;\nEigen::Vector2d req_pos;\nreq_pos &lt;&lt; 48.0, 60.0;\nfor (auto &amp;ele : elements(gridView)) {\n  localView.bind(ele);\n  localw.bind(ele);\n  const auto geo = localView.element().geometry();\n  for (size_t i = 0; i &lt; 4; ++i) {\n    if (Dune::FloatCmp::eq(geo.corner(i)[0], req_pos[0]) and Dune::FloatCmp::eq(geo.corner(i)[1], req_pos[1])) {\n      const auto local_pos = geo.local(toDune(req_pos));\n      uy_fe                = toEigen(localw(local_pos)).eval()[1];\n    }\n  }\n}\n</code></pre> <p>The datasets are then stored and plotted using Matplot++. The deformed configuration is also written using the <code>Dune::VTKWriter</code> and can be visualized using Paraview. Several log information is also displayed in this example using spdlog.</p>"},{"location":"02_examples/cooksMembrane/#takeaways","title":"Takeaways","text":"<ul> <li><code>Dune::ParameterTree</code> can be used to read input parameters from an external <code>*.parset</code> file.</li> <li>A linear elastic element of arbitrary dimension can be used to solve the underlying problem. In 2D and 3D, this element can be   enriched with enhanced assumed strains.</li> <li><code>spdlog/spdlog.h</code> can be used to display log information.</li> <li><code>chrono</code> library can be used to determine the computation time.</li> </ul> <ol> <li> <p>Robert D. Cook. Improved Two-Dimensional Finite Element. J. Struct. Div., 100(9):1851\u20131863, September 1974. doi:10.1061/JSDEAG.0003877.\u00a0\u21a9</p> </li> </ol>"},{"location":"02_examples/incompressibleRubberBlock/","title":"Deformation of an incompressible rubber block","text":""},{"location":"02_examples/incompressibleRubberBlock/#description","title":"Description","text":"<p><code>iks003_incompressible_LinearElasticity.cpp</code> uses finite element technology with displacement and pressure as independent degrees of freedom to simulate the deformation of an incompressible rubber block. The potential energy for such a system is defined in the <code>Solid struct</code> by the function <code>calculateScalarImpl(const FERequirementType &amp;par, const Eigen::VectorX&lt;ScalarType&gt; &amp;dx)</code>. This function uses the principles of automatic differentiation to provide the stiffness matrix and other necessary quantities to perform a static structural analysis. It inherits from <code>FEBase</code> which provides information about the <code>localView</code> of the element.</p>"},{"location":"02_examples/incompressibleRubberBlock/#code-highlights","title":"Code highlights","text":"<p>The <code>struct</code> named <code>Solid</code> is created. It is constructed as shown below:</p> <pre><code>Solid(const BasisHandler &amp;basisHandler, const typename LocalView::Element &amp;element, double emod, double nu)\n      : Base(basisHandler, element), emod_{emod}, nu_{nu} {\n    mu_       = emod_ / (2 * (1 + nu_));\n    lambdaMat = convertLameConstants({.emodul = emod_, .nu = nu_}).toLamesFirstParameter();\n}\n</code></pre> <p>It takes a reference to the basis handler (<code>&amp;basisHandler</code>), the element (<code>&amp;element</code>), and the material parameters, namely Young's modulus (<code>emod</code>) and Poisson's ratio (<code>nu</code>), as arguments during construction. The function <code>convertLameConstants()</code> is a helper function to switch between the Lame parameters.</p> <p><code>ScalarType calculateScalarImpl(const FERequirementType &amp;par, const Eigen::VectorX&lt;ScalarType&gt; &amp;dx)</code> is then defined, returning a scalar value, in this case the energy. The energy is then calculated as follows:</p> <pre><code>energy += (0.5 * (2 * mu_ * symgradu.squaredNorm() - 1 / lambdaMat * Dune::power(pressure, 2)) + pressure * divU\n           - x.dot(fext))\n          * geo.integrationElement(gp.position()) * gp.weight();  // plane strain for 2D\n</code></pre> <p>Here:</p> <ul> <li><code>symgradu</code> is the symmetric part of the gradient of displacements</li> <li><code>lambdaMat</code> is the first Lame parameter</li> <li><code>pressure</code> and <code>x</code> are the nodal pressure and current position, respectively</li> <li><code>divU</code> is the divergence of the displacement vector</li> <li><code>fext</code> is the external force vector</li> <li><code>gp.position()</code> and <code>gp.weight()</code> are the positions and weights from the quadrature rule</li> <li><code>geo.integrationElement()</code> returns the determinant of Jacobian required from the iso-parametric concept</li> </ul> <p>A Yasp 2D grid<sup>1</sup> is created of the size \\(L\\) x \\(h\\) with 20 elements in both directions, as shown below:</p> <pre><code>using Grid        = Dune::YaspGrid&lt;gridDim&gt;;\nconst double L    = 1;\nconst double h    = 1;\nconst size_t elex = 20;\nconst size_t eley = 20;\n\nDune::FieldVector&lt;double, 2&gt; bbox       = {L, h};\nstd::array&lt;int, 2&gt; elementsPerDirection = {elex, eley};\nauto grid                               = std::make_shared&lt;Grid&gt;(bbox, elementsPerDirection);\nauto gridView                           = grid-&gt;leafGridView();\n</code></pre> <p>A linear Lagrangian basis is opted for the displacements and a constant basis for the pressure degrees of freedom using the <code>composite</code> basis feature from Dune, as shown below:</p> <pre><code>auto basis = Ikarus::makeBasis(\ngridView, composite(power&lt;2&gt;(lagrange&lt;1&gt;()), lagrange&lt;0&gt;()));\n</code></pre> <p>Here, <code>power&lt;2&gt;</code> is used to approximate the displacement field in both \\(x\\) and \\(y\\) directions. A vector of <code>Solid</code> finite elements that are decorated by <code>AutoDiffFE</code> are then constructed as shown below:</p> <pre><code>std::vector&lt;AutoDiffFE&lt;Solid&lt;decltype(basis)&gt;&gt;&gt; fes;\nfor (auto &amp;ele : elements(gridView))\n  fes.emplace_back(basis, ele, Emod, nu);\n</code></pre> <p>The displacement degrees of freedom at position \\(y=0\\) are fixed using the following snippet:</p> <pre><code>auto basisP = std::make_shared&lt;const decltype(basis)&gt;(basis);\nIkarus::DirichletValues dirichletValues(basisP-&gt;flat());\ndirichletValues.fixDOFs([](auto &amp;basis_, auto &amp;dirichletFlags) {\n  Dune::Functions::forEachBoundaryDOF(subspaceBasis(basis_, _0),\n                   [&amp;](auto &amp;&amp;localIndex, auto &amp;&amp;localView, auto &amp;&amp;intersection) {\n                       if (std::abs(intersection.geometry().center()[1]) &lt; 1e-8)\n                         dirichletFlags[localView.index(localIndex)] = true;\n  });\n});\n</code></pre> <p>Here, all the element edges lying on the boundary of the physical domain are looped over and checked to see if the first index of the center of the edge (<code>intersection.geometry().center()[1]</code>) is close to zero. If this is the case, the corresponding \\(x\\)-displacement degrees of freedom (obtained via <code>subspaceBasis(basis_, _0)</code>) are set to <code>true</code> and used by the assembler later.</p> <p>A <code>sparse</code> assembler is used to arrive at the stiffness matrix and the external load vector using the finite element requirements as described here.</p> <pre><code>auto sparseFlatAssembler = SparseFlatAssembler(fes, dirichletValues);\nauto req = fe.createRequirement();\n\nauto fextFunction = [&amp;](auto &amp;&amp;lambdaLocal, auto &amp;&amp;dLocal) -&gt; auto &amp; {\n  req.insertGlobalSolution( dLocal)\n      .insertParameter( lambdaLocal);\n  return sparseFlatAssembler.vector(req,VectorAffordance::forces);\n};\nauto KFunction = [&amp;](auto &amp;&amp;lambdaLocal, auto &amp;&amp;dLocal) -&gt; auto &amp; {\n  req.insertGlobalSolution( dLocal)\n      .insertParameter( lambdaLocal);\n  return sparseFlatAssembler.matrix(req,MatrixAffordance::stiffness);\n};\n</code></pre> <p>The <code>SparseLU</code> package from the Eigen library is used to solve the linear system of equations.</p> <p>For post-processing, the function <code>Dune::Functions::makeDiscreteGlobalBasisFunction()</code> is used to create a function for the displacements and pressure using the basis functions and the nodal values. <code>Dune::VTKWriter</code> is used to write the <code>*.vtu</code> files. The results can then be plotted, for example, using Paraview.</p> <pre><code>auto disp\n    = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;Dune::FieldVector&lt;double, 2&gt;&gt;(subspaceBasis(basis.flat(), _0), d);\nauto pressure = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;double&gt;(subspaceBasis(basis.flat(), _1), d);\nDune::VTKWriter vtkWriter(gridView, Dune::VTK::nonconforming);\nvtkWriter.addVertexData(disp, Dune::VTK::FieldInfo(\"displacement\", Dune::VTK::FieldInfo::Type::vector, 2));\nvtkWriter.addVertexData(pressure, Dune::VTK::FieldInfo(\"pressure\", Dune::VTK::FieldInfo::Type::scalar, 1));\nvtkWriter.write(\"iks003_incompressibleLinearElasticity\");\n</code></pre>"},{"location":"02_examples/incompressibleRubberBlock/#takeaways","title":"Takeaways","text":"<ul> <li><code>Ikarus::AutoDiffFE</code> can be used to arrive at the stiffness matrix and external load vector from the energy function.</li> <li>Easier implementation of mixed finite elements is possible due to the composite basis feature from Dune.</li> <li>Helper functions are included to switch between the Lame parameters.</li> <li>Grids from Dune can be directly incorporated within the Ikarus framework.</li> <li>Sparse assembler can be used to construct the global stiffness matrices and load vectors.</li> <li>Solvers from the Eigen library can be used to solve the linear system of equations.</li> <li>Post-processing can be done via Paraview after writing the <code>*.vtu</code> files using <code>Dune::VTKWriter</code>.</li> </ul> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"02_examples/kirchhoffPlate/","title":"Plate subjected to a surface load","text":""},{"location":"02_examples/kirchhoffPlate/#description","title":"Description","text":"<p>Kirchhoff-type plate element is implemented in <code>iks004_kirchhoffPlate.cpp</code> using the automatic differentiation technique as commented before. The basis used for discretization is a NURBS basis from the <code>dune-iga</code> module. The problem is solved, and convergence plots are created by comparing the solutions to the available analytical solutions for the simply supported case.</p>"},{"location":"02_examples/kirchhoffPlate/#code-highlights","title":"Code highlights","text":"<p>Similar to the <code>struct</code> named <code>Solid</code> in <code>iks003_incompressible_LinearElasticity.cpp</code>, here a <code>struct</code> named <code>KirchhoffPlate</code> is created. It inherits from <code>FEBase</code> and it must be decorated with <code>AutoDiffFE</code> as well to compute the required matrices and vectors. It is constructed as shown below:</p> <pre><code>KirchhoffPlate(const BasisHandler &amp;basisHandler, const typename LocalView::Element &amp;element, double p_Emodul,\n               double p_nu, double p_thickness)\n    : Base(basisHandler, element),\n      Emodul{p_Emodul},\n      nu{p_nu},\n      thickness{p_thickness} {\n  geometry_.emplace(this-&gt;localView().element().geometry());\n}\n</code></pre> <p>It takes in the <code>p_thickness</code> parameter in addition to the ones in <code>Solid</code>. Here, the energy is calculated as:</p> <pre><code>energy += (0.5 * kappa.dot(D * kappa) - w * lambda) * geometry_-&gt;integrationElement(gp.position()) * gp.weight();\n</code></pre> <p>with <code>kappa</code> being the vector of curvature containing \\(\\kappa_{xx}, \\kappa_{yy}\\) and \\(\\kappa_{xy}\\). If the boundaries are clamped, the penalty method could be used, for example, to fix the derivatives of the displacements. Here, however, the example for the simply supported case is discussed further.</p> <p>A two-dimensional NURBS grid is created from the dune-iga module.</p> <pre><code>constexpr int griddim                                    = 2; // (1)!\nconstexpr int dimworld                                   = 2; // (2)!\nconst std::array&lt;std::vector&lt;double&gt;, griddim&gt; knotSpans = { { {0, 0, 1, 1}, {0, 0, 1, 1} } }; // (3)!\nusing ControlPoint = Dune::IGA::NURBSPatchData&lt;griddim, dimworld&gt;::ControlPointType;\nconst double Lx = 10; // (4)!\nconst double Ly = 10; // (5)!\n\nconst std::vector&lt;std::vector&lt;ControlPoint&gt;&gt; controlPoints\n    = { { {.p = {0, 0}, .w = 1}, {.p = {0, Ly}, .w = 1} },\n        { {.p = {Lx, 0}, .w = 1}, {.p = {Lx, Ly}, .w = 1} } }; // (6)!\n\nstd::array&lt;int, griddim&gt; dimsize = {2, 2}; // (7)!\n\nauto controlNet = Dune::IGA::NURBSPatchData&lt;griddim, dimworld&gt;::ControlPointNetType(dimsize, controlPoints); // (8)!\nusing Grid      = Dune::IGA::NURBSGrid&lt;griddim, dimworld&gt;;\n\nDune::IGA::NURBSPatchData&lt;griddim, dimworld&gt; patchData;\n\npatchData.knotSpans     = knotSpans; // (9)!\npatchData.degree        = {1, 1}; // (10)!\npatchData.controlPoints = controlNet; // (11)!\npatchData = Dune::IGA::degreeElevate(patchData, 0, 1); // (12)!\npatchData = Dune::IGA::degreeElevate(patchData, 1, 1); // (13)!\nGrid grid(patchData); // (14)!\n</code></pre> <ol> <li>The dimension of the grid. Here, two-dimensional.</li> <li>The dimension of the physical space in which the grid lies (the embedding space of the grid). Here, two-dimensional.</li> <li>The knot vector for the NURBS grid.</li> <li>Length of the plate</li> <li>Width of the plate</li> <li>Control points and the weights for the square plate (the control points are ordered such that all the control points for a particular    \\(x\\)-position are listed first, followed by the subsequent \\(x\\)-positions in ascending order).</li> <li>Number of control points in either direction.</li> <li>Creation of the control net.</li> <li>Binding the <code>knotSpans</code> to a particular NURBS <code>patchData</code>.</li> <li>The polynomial degree for the basis in either direction. It can also be calculated from the <code>knotSpans</code>.</li> <li>Binding the <code>controlNet</code> to a particular NURBS <code>patchData</code>.</li> <li>Elevating the polynomial degree for the <code>patchData</code> in \\(x\\)-direction (<code>0</code>) by 1.</li> <li>Elevating the polynomial degree for the <code>patchData</code> in \\(y\\)-direction (<code>1</code>) by 1.</li> <li>Creating the grid object from the patch data</li> </ol> <p>In order to obtain the convergence plots, the system is solved five times, with the refinement level increasing by 1 each time using the command <code>grid.globalRefine(1);</code>. The NURBS basis can be obtained from the freestanding functions <code>nurbs()</code>, as shown below:</p> <pre><code>auto basis = Ikarus::makeBasis(gridView, nurbs());\n</code></pre> <p>This is followed by specifying the Dirichlet boundary conditions, creating the finite elements and the assembler, solving the system of equations, and post-processing using Paraview as mentioned in the previous examples. The analytical solution for the simply supported case is adapted from Wikipedia and is also mentioned below:</p> <pre><code>auto wAna = [&amp;](auto x) {\n  double w                = 0.0;\n  const int seriesFactors = 40;\n  const double pi         = std::numbers::pi;\n  auto oddFactors\n      = std::ranges::iota_view(1, seriesFactors) | std::views::filter([](auto i) { return i % 2 != 0; });\n  for (auto m : oddFactors)\n    for (auto n : oddFactors)\n      w += sin(m * pi * x[0] / Lx) * sin(n * pi * x[1] / Ly)\n           / (m * n * Dune::power(m * m / (Lx * Lx) + n * n / (Ly * Ly), 2));\n\n  return 16 * totalLoad / (Dune::power(pi, 6) * D) * w;\n};\n</code></pre> <p>The <code>Dune::Functions::makeDiscreteGlobalBasisFunction</code> is used to create a function from the nodal finite element solution of the displacements and the NURBS basis whereas the <code>Dune::Functions::makeAnalyticGridViewFunction</code> is used to create a function by using the function to evaluate the analytical solutions and the <code>gridView</code> to get the position <code>x</code>. Local functions are then created that are used later to calculate the \\(L^2\\)-error.</p> <pre><code>auto wGlobalFunction = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;Dune::FieldVector&lt;double, 1&gt;&gt;(basis.flat(), w);\nauto wGlobalAnalyticFunction = Dune::Functions::makeAnalyticGridViewFunction(wAna, gridView);\nauto localw                  = localFunction(wGlobalFunction);\nauto localwAna               = localFunction(wGlobalAnalyticFunction);\n</code></pre> <p>The \\(L^2\\)-error is calculated by using $$ L^2\\textrm{-error} = \\frac{\\sqrt{\\sum_{ele} \\int_{\\Omega_{ele}} \\left( w_{analytical}-w_{FE} \\right)<sup>2}}{L</sup>2\\textrm{-exact}} $$ with \\(L^2\\textrm{-exact} = \\sqrt{\\sum_{ele} \\int_{\\Omega_{ele}} \\left( w_{analytical}\\right)^2}\\) as shown below:</p> <pre><code>double l2_error = 0.0;\ndouble l2_normEx = 0.0;\nfor (auto &amp;ele : elements(gridView)) {\n  localView.bind(ele);\n  localw.bind(ele);\n  localwAna.bind(ele);\n  const auto geo   = localView.element().geometry();\n  const auto &amp;rule = Dune::QuadratureRules&lt;double, 2&gt;::rule(\n      ele.type(), 2U * localView.tree().finiteElement().localBasis().order());\n  for (auto gp : rule) {\n    const auto intElement = ele.geometry().integrationElement(gp.position()) * gp.weight();\n    const auto w_ex       = localwAna(gp.position());\n    const auto w_fe       = localw(gp.position());\n    l2_error += Dune::power(w_ex - w_fe, 2) * intElement;\n    l2_normEx += w_ex * intElement;\n  }\n}\nl2_error = std::sqrt(l2_error) / std::sqrt(l2_normEx);\n</code></pre> <p>The number of degrees of freedom for each refinement level and its corresponding \\(L^2\\)-error is pushed to a vector that can be later used to create plots using the features from Matlab.</p> <pre><code>std::vector&lt;size_t&gt; dofsVec;\nstd::vector&lt;double&gt; l2Evcector;\ndofsVec.push_back(basis.flat().size());\nl2Evcector.push_back(l2_error);\n</code></pre>"},{"location":"02_examples/kirchhoffPlate/#takeaways","title":"Takeaways","text":"<ul> <li>NURBS grids can be created using the <code>dune-iga</code> module.</li> <li>The basis for the corresponding NURBS grid can be obtained using the <code>nurbs()</code> function.</li> <li>The Kirchhoff plate element can be easily implemented by evaluating the energy and using automatic differentiation methods.</li> <li>\\(L^2\\)-error can be evaluated to perform convergence studies.</li> </ul>"},{"location":"02_examples/newtonRaphsonMethod/","title":"Newton-Raphson method","text":""},{"location":"02_examples/newtonRaphsonMethod/#description","title":"Description","text":"<p><code>iks005_newtonRaphson.cpp</code> shows a basic example of the Newton-Raphson method to solve a non-linear set of equations. A function that shows the algorithm explicitly is provided, and another function which is implemented in Ikarus is demonstrated. The function that depicts the Ikarus implementation uses a non-linear operator to perform the Newton-Raphson iterations. A logger can also be subscribed to in order to observe the residual norms, for instance.</p>"},{"location":"02_examples/newtonRaphsonMethod/#code-highlights","title":"Code highlights","text":"<p>Here, the <code>main()</code> function uses two functions, namely <code>void newtonRaphsonVeryBasicExample();</code> and <code>void newtonRaphsonBasicExampleWithLogger();</code> that demonstrate the implementation of the Newton-Raphson scheme and also show the method to subscribe to loggers for information, respectively. The function, which is solved in this example, and its derivative are mentioned below:</p> <pre><code>auto f(double &amp;x) { return 0.5 * x * x + x - 2; }\nauto df(double &amp;x) { return x + 1; }\n</code></pre> <p>First, the <code>void newtonRaphsonVeryBasicExample();</code> function is described. The settings for the Newton-Raphson method are defined as:</p> <pre><code>double x               = 13; // (1)!\nconst double eps       = 1e-10; // (2)!\nconst int maxIter      = 20; // (3)!\nconst double xExpected = std::sqrt(5.0) - 1.0; // (4)!\n</code></pre> <ol> <li>Starting point for the Newton-Raphson method to find the closest root</li> <li>Tolerance level below which the iterations stop</li> <li>Maximum number of iterations</li> <li>Expected value (analytical solution)</li> </ol> <p>Functors are created then to evaluate the function to be solved for and its derivative. These are then passed to the non-linear operator as shown below:</p> <pre><code>auto fvLambda  = [&amp;](auto &amp;&amp;x) { return f(x); };\nauto dfvLambda = [&amp;](auto &amp;&amp;x) { return df(x); };\nIkarus::NonLinearOperator nonLinOp(Ikarus::functions(fvLambda, dfvLambda), Ikarus::parameter(x));\n</code></pre> <p>The standard implementation of the Newton-Raphson method is illustrated in this function, which also uses <code>nonLinOp</code>.</p> <pre><code>int iterCount = 1;\nwhile (abs(nonLinOp.value()) &gt; eps and iterCount &lt;= maxIter) {\n  x -= nonLinOp.value() / nonLinOp.derivative();\n  nonLinOp.updateAll();\n  iterCount++;\n\n  std::cout &lt;&lt; \"nonlinearOperator, value(): \" &lt;&lt; nonLinOp.value() &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"nonlinearOperator, x: \" &lt;&lt; nonLinOp.firstParameter() &lt;&lt; \"\\n\";\n}\n</code></pre> <p>One could also use the existing functionality in Ikarus to obtain a similar solution from the Newton-Raphson scheme, as depicted below:</p> <pre><code>Ikarus::NewtonRaphson nr(nonLinOp);\nnr.setup({eps, maxIter});\nconst auto solverInfo = nr.solve(x);\n\nstd::cout &lt;&lt; \"success: \" &lt;&lt; solverInfo.success &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"iterations: \" &lt;&lt; solverInfo.iterations &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"residuum: \" &lt;&lt; solverInfo.residualNorm &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"solution: \" &lt;&lt; x &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"expected solution: \" &lt;&lt; xExpected &lt;&lt; \"\\n\";\n</code></pre> <p>Further details on the non-linear solver can be found here.</p> <p>Instead of using the multiple <code>std::cout</code> statements, one can simply subscribe for the desired information using the functionalities from the observer module. This is exemplified by the function <code>void newtonRaphsonBasicExampleWithLogger();</code> and the <code>class OurFirstObserver</code>. It is also possible to subscribe to the existing non-linear solver messages mentioned here.</p> <pre><code>class OurFirstObserver : public IObserver&lt;NonLinearSolverMessages&gt; {\n public:\n  void updateImpl(NonLinearSolverMessages message) override {\n    if (message == NonLinearSolverMessages::ITERATION_STARTED) std::cout &lt;&lt; \"Iteration started.\\n\";\n  }\n};\n\nvoid newtonRaphsonBasicExampleWithLogger() {\n  double x               = 13;\n  const double eps       = 1e-10;\n  const int maxIter      = 20;\n  const double xExpected = std::sqrt(5.0) - 1.0;\n\n  auto fvLambda  = [&amp;](auto &amp;&amp;x) { return f(x); };\n  auto dfvLambda = [&amp;](auto &amp;&amp;x) { return df(x); };\n  Ikarus::NonLinearOperator nonLinOp(Ikarus::functions(fvLambda, dfvLambda), Ikarus::parameter(x));\n\n  Ikarus::NewtonRaphson nr(nonLinOp);\n  nr.setup({eps, maxIter});\n\n  auto ourSimpleObserver = std::make_shared&lt;OurFirstObserver&gt;();\n  nr.subscribe(NonLinearSolverMessages::ITERATION_STARTED, ourSimpleObserver);\n\n  const auto solverInfo = nr.solve(x);\n  if (solverInfo.success)\n    std::cout &lt;&lt; \"solution: \" &lt;&lt; x &lt;&lt; \"\\n\";\n  else\n    std::cout &lt;&lt; \"The Newton-Raphson procedure failed to converge\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"02_examples/newtonRaphsonMethod/#takeaways","title":"Takeaways","text":"<ul> <li>Functors for the function and its derivative can be used to create a simple non-linear operator.</li> <li>A <code>NewtonRaphson</code> object can be created using the non-linear operator.</li> <li>The settings for the Newton-Raphson scheme can be modified by using the <code>setup()</code> function.</li> <li>Nonlinear solver messages can be subscribed to print the desired quantities.</li> </ul>"},{"location":"02_examples/nonLinearElasticity/","title":"Non-linear Elasticity for 2D solids","text":""},{"location":"02_examples/nonLinearElasticity/#description","title":"Description","text":"<p>In <code>iks006_nonlinear2DSolid.cpp</code>, an automatic differentiation-based implementation is used to perform a non-linear analysis on a 2D block. Various methods to obtain a 2D grid via Dune are also shown in the commented section at the beginning. Python is used to provide a Neumann boundary condition, providing a demonstration for the usage of Python-based code within the Ikarus framework. The load control method is chosen as the desired control routine, and Newton-Raphson (or trust region methods) are used to solve the non-linear problem itself.</p>"},{"location":"02_examples/nonLinearElasticity/#code-highlights","title":"Code highlights","text":"<p>This example uses two macros, <code>gridType</code> and <code>solverType</code>, that are to be set as desired before executing the example. The <code>gridType</code> can be set to 0, 1, or 2, denoting an <code>ALUGrid</code>, a <code>YaspGrid</code>, and a <code>NURBSGrid</code> respectively. The <code>solverType</code> can be set to either 0 or 1 for <code>Newton-Raphson</code> and <code>Trust region</code> methods respectively.</p> <p>When <code>ALUGrid</code> is chosen, the mesh file <code>auxiliaryFiles/unstructuredTrianglesfine.msh</code> is read using <code>Dune::GmshReader</code> and is then globally refined once. The <code>YaspGrid</code> created a square block of length 1 with 10 elements in either direction. The <code>NURBSGrid</code> also creates a square block of length 1 with a polynomial degree of 2 in both directions. The block is subjected to a Neumann load on the right edge (\\(x=1\\)) that is incorporated using the dune-python interface as shown below:</p> <pre><code>Dune::BitSetVector&lt;1&gt; neumannVertices(gridView.size(2), false);\nstd::string lambdaNeumannVertices = std::string(\"lambda x: ( x[0]&gt;0.999 )\");\n\nPython::start();\nPython::Reference main = Python::import(\"__main__\");\nPython::run(\"import math\");\nPython::runStream() &lt;&lt; std::endl &lt;&lt; \"import sys\" &lt;&lt; std::endl &lt;&lt; \"import os\" &lt;&lt; std::endl;\nauto pythonNeumannVertices = Python::make_function&lt;bool&gt;(Python::evaluate(lambdaNeumannVertices));\n\nfor (auto &amp;&amp;vertex : vertices(gridView)) {\n  bool isNeumann                          = pythonNeumannVertices(vertex.geometry().corner(0));\n  neumannVertices[indexSet.index(vertex)] = isNeumann;\n}\nBoundaryPatch&lt;decltype(gridView)&gt; neumannBoundary(gridView, neumannVertices);\n</code></pre> <p>After the basis is defined, the non-linear elastic finite element is created as shown below:</p> <pre><code>auto volumeLoad = [](auto &amp;globalCoord, auto &amp;lamb) {\n  Eigen::Vector2d fext;\n  fext.setZero();\n  return fext;\n};\n\nauto neumannBoundaryLoad = [](auto &amp;globalCoord, auto &amp;lamb) {\n  Eigen::Vector2d fext;\n  fext.setZero();\n  fext[1] = lamb / 40;\n  return fext;\n};\n\nauto matParameter = Ikarus::toLamesFirstParameterAndShearModulus({.emodul = 1000, .nu = 0.3});\n\nIkarus::StVenantKirchhoff matSVK(matParameter);\nauto reducedMat = planeStress(matSVK);\n\nstd::vector&lt;Ikarus::NonLinearElastic&lt;decltype(basis), decltype(reducedMat)&gt;&gt;&gt; fes;\nfor (auto &amp;element : elements(gridView))\n  fes.emplace_back(*basis, element, reducedMat, &amp;neumannBoundary, neumannBoundaryLoad, volumeLoad);\n</code></pre> <p>The functors <code>volumeLoad</code> and <code>neumannBoundaryLoad</code> are used to obtain the external volume and surface loads acting on a particular position. We use a Saint Venant\u2013Kirchhoff material model, which we transform to a plane stress material law for our two-dimensional simulation. The line \\(y=0\\) is clamped by applying the Dirichlet boundary condition expressed below:</p> <pre><code>auto basisP = std::make_shared&lt;const decltype(basis)&gt;(basis);\nIkarus::DirichletValues dirichletValues(basisP-&gt;flat());\n\ndirichletValues.fixBoundaryDOFs([&amp;](auto &amp;dirichletFlags, auto &amp;&amp;localIndex, auto &amp;&amp;localView, auto &amp;&amp;intersection) {\n  if (std::abs(intersection.geometry().center()[1]) &lt; 1e-8) dirichletFlags[localView.index(localIndex)] = true;\n});\n</code></pre> <p>The finite element requirements are defined by using the affordance <code>Ikarus::AffordanceCollections::elastoStatics</code>. This is then used to create functors to get the stiffness matrix, residual vector, and energy value using a sparse assembler. A non-linear operator and the linear solver used by the <code>solverType</code> are defined as:</p> <pre><code>auto nonLinOp = Ikarus::NonLinearOperator(functions(energyFunction, residualFunction, KFunction), parameter(d, lambda));\nauto linSolver = Ikarus::LinearSolver(Ikarus::SolverTypeTag::sd_UmfPackLU);\n</code></pre> <p>An object for the Newton-Raphson method or the trust region method can then be defined as</p> <pre><code>#if solverType == 0\n  auto nr = Ikarus::makeNewtonRaphson(nonLinOp.subOperator&lt;1, 2&gt;(), std::move(linSolver));\n#endif\n#if solverType == 1\n  auto nr = Ikarus::makeTrustRegion(nonLinOp);\n  nr-&gt;setup({.verbosity = 1,\n             .maxiter   = 30,\n             .grad_tol  = 1e-8,\n             .corr_tol  = 1e-8,\n             .useRand   = false,\n             .rho_reg   = 1e6,\n             .Delta0    = 1});\n#endif\n</code></pre> <p>All the available output messages are subscribed to be displayed by using the following commands:</p> <pre><code>auto nonLinearSolverObserver = std::make_shared&lt;NonLinearSolverLogger&gt;();\nnr-&gt;subscribeAll(nonLinearSolverObserver);\n</code></pre> <p>The load control method is finally used as the path-following technique to solve this non-linear problem. It also subscribes to all the available information being written to the <code>vtkWriter</code>. Output files are written for the deformed configuration at every load step that can be visualized using Paraview. The load control method is executed by the following commands:</p> <pre><code>auto lc = Ikarus::LoadControl(nr, 20, {0, 2000});\nlc.subscribeAll(vtkWriter);\nlc.run();\n</code></pre> <p>For postprocessing purposes we now write our results in a different VTK File. First we take a look at the stresses, in this case the second Piola-Kirchhoff stress tensor. This quantity can be computed with the elements' <code>calculateAt()</code> function. But here we will be using a so-called <code>ResultFunction</code>. This is a helper function that gathers the results over the whole grid and can be used to generate data for a <code>VTKWriter</code>. To create this function, we can use the following helper</p> <pre><code>auto stressFunction = Ikarus::makeResultFunction&lt;ResultType::PK2Stress&gt;(assembler);\n</code></pre> <p>To add this as vertex data to the VTK file we can do the following:</p> <pre><code>Dune::VTKWriter resultWriter(gridView);\nresultWriter.addVertexData(stressFunction);\n</code></pre> <p>As this functionality only writes out the results of the <code>calculateAt()</code> function as is, we can use <code>ResultEvaluators</code> to further process our results. For example, we can use <code>ResultEvaluators::VonMises</code> to compute the Von Mises stress:</p> <pre><code>  auto vonMisesFunction\n      = Ikarus::makeResultFunction&lt;ResultType::PK2Stress&gt;(assembler, ResultEvaluators::VonMises{});\n</code></pre>"},{"location":"02_examples/nonLinearElasticity/#takeaways","title":"Takeaways","text":"<ul> <li>Grid types, finite element discretizations, and solver types are independent entities that are used to solve the problem at hand and   can be switched easily to compare various formulations.</li> <li>The dune-python interface can be used to read external codes written in Python.</li> <li>A geometrically non-linear elastic finite element can be used from the Ikarus library.</li> <li>The Newton-Raphson and trust regions methods can be used as non-linear solvers.</li> <li>The load control method is used here as the path-following technique.</li> <li>Stress results can be written to a VTK file with a <code>ResultFunction</code>.</li> </ul>"},{"location":"02_examples/vonMisesTruss/","title":"Von Mises truss calculation","text":""},{"location":"02_examples/vonMisesTruss/#description","title":"Description","text":"<p><code>iks007_vonMisesTruss.cpp</code> utilizes the tools and features mentioned in the previous examples to solve the standard Von-Mises truss example found in literature (refer to Section 2<sup>1</sup>).</p>"},{"location":"02_examples/vonMisesTruss/#code-highlights","title":"Code highlights","text":"<p>The struct named <code>Truss</code> is created such that it inherits from <code>FEBase</code>. It must be decorated with <code>AutoDiffFE</code> as well to compute the stiffness matrix and load vectors during construction. It is constructed as shown below:</p> <pre><code>Truss(const BasisHandler &amp;basisHandler, const typename LocalView::Element &amp;element, double p_EA)\n    : Base(basisHandler, element), EA{p_EA} {}\n</code></pre> <p>It takes a reference to the basis handler (<code>&amp;basisHandler</code>), the element (<code>&amp;element</code>), and the axial stiffness of the truss structure (<code>p_EA</code>) as arguments during construction.</p> <p><code>ScalarType calculateScalarImpl(const FERequirementType &amp;par, const Eigen::VectorX&lt;ScalarType&gt; &amp;dx)</code> is then defined, returning a scalar value, in this case the energy. The energy is defined as <code>0.5 * EA * sqrt(LRefsquared) * Egl * Egl</code> with <code>Egl</code> being the Green-Lagrange strain defined as</p> <pre><code>const Scalar Egl = 0.5 * (lsquared - LRefsquared) / LRefsquared;\n</code></pre> <p>The grid in this example is created explicitly. The grid is created here from the dune-foamgrid module. This allows the user to embed a one- or two-dimensional grid in a physical space of any dimension. Thus, here we embed a one-dimensional truss system in a 2D plane. The height (<code>h</code>) and length (<code>L</code>) of the truss system are defined, which is followed by the addition of the vertices and elements to create a grid as shown below:</p> <pre><code>Dune::GridFactory&lt;Dune::FoamGrid&lt;1, 2, double&gt;&gt; gridFactory;\nconst double h = 1.0;\nconst double L = 2.0;\ngridFactory.insertVertex({0, 0});\ngridFactory.insertVertex({L, h});\ngridFactory.insertVertex({2 * L, 0});\ngridFactory.insertElement(Dune::GeometryTypes::line, {0, 1});\ngridFactory.insertElement(Dune::GeometryTypes::line, {1, 2});\nauto grid     = gridFactory.createGrid();\nauto gridView = grid-&gt;leafGridView();\n</code></pre> <p>The Lagrange basis is used to approximate the displacement field. The <code>Truss</code> elements are then created, followed by the fixing of the degrees of freedom at the boundaries (<code>{0,0}</code> and <code>{2 * L,0}</code>). A vertical downward load is applied to the center node. The non-linear operator is then constructed. The Newton-Raphson method is used as the non-linear solver, and an <code>nonLinearSolverObserver</code> is created to write messages as desired by the non-linear solver. An additional <code>lvkObserver</code> is created using the <code>Ikarus::GenericControlObserver</code> feature. This observer helps to fill up the matrix <code>lambdaAndDisp</code> with the load factor <code>lambda</code> and the two unconstrained degrees of freedom whenever the solution is changed (<code>ControlMessages::SOLUTION_CHANGED</code>), which means that the Newton-Raphson method has converged to a solution. This is implemented as depicted in the following:</p> <pre><code>const int loadSteps = 10;\nEigen::Matrix3Xd lambdaAndDisp;\nlambdaAndDisp.setZero(Eigen::NoChange, loadSteps + 1);\nauto lvkObserver = std::make_shared&lt;Ikarus::GenericObserver&lt;Ikarus::ControlMessages&gt;&gt;(\n    Ikarus::ControlMessages::SOLUTION_CHANGED, [&amp;](int step) {\n      lambdaAndDisp(0, step) = lambda;\n      lambdaAndDisp(1, step) = d[2];\n      lambdaAndDisp(2, step) = d[3];\n    });\n</code></pre> <p>The load control method is used as the path-following strategy, and it is subscribed to both <code>vtkWriter</code> and <code>lvkObserver</code>. The features from Matplot++ are then used to plot the load-displacement curve from the matrix <code>lambdaAndDisp</code>.</p>"},{"location":"02_examples/vonMisesTruss/#takeaways","title":"Takeaways","text":"<ul> <li><code>Dune::FoamGrid</code> can be used to embed one or two-dimensional grid entities into a multi-dimensional physical space.</li> <li>A simple truss element can be constructed using the automatic differentiation procedure.</li> <li><code>Ikarus::GenericControlObserver</code> can be used to perform user-desired tasks at any desired point by observing a non-linear solver procedure.</li> </ul> <ol> <li> <p>R. V. Mises. \u00dcber die stabilit\u00e4tsprobleme der elastizit\u00e4tstheorie. ZAMM - Journal of Applied Mathematics and Mechanics / Zeitschrift f\u00fcr Angewandte Mathematik und Mechanik, 3(6):406\u2013422, 1923. doi:10.1002/zamm.19230030602.\u00a0\u21a9</p> </li> </ol>"},{"location":"03_contribution/buildDocumentationLocally/","title":"How to edit this documentation","text":""},{"location":"03_contribution/buildDocumentationLocally/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ikarus cloned on your computer,   see the download page.</li> </ul>"},{"location":"03_contribution/buildDocumentationLocally/#preview-the-documentation-locally","title":"Preview the documentation locally","text":"<ul> <li>Change the cmake option, for example, in Clion: Open <code>File --&gt; Settings --&gt; Build,Execution,Deployment --&gt; Cmake</code>.   Add <code>-DBUILD_DOCS=TRUE</code> to your cmake options   </li> <li>Choose target <code>localSite</code> and build it (for instance, click on the hammer)</li> </ul> <ul> <li>After a couple of seconds, build messages should appear that look similar to the picture below.   </li> <li>Click on <code>Services</code> in the footer, double-click on <code>Docker</code> and unfold <code>Containers</code>. There should be   one container with a blue box, while the other containers have a blue box with a white square inside   (see figure below). In this example, the container we are looking for is <code>elegant_bassi</code>.   The name will be different on your computer, but the relevant criterion for finding the container   is the blue box.   </li> <li>Click on the container with the blue box and navigate to <code>Port Bindings</code>.</li> <li>Add a new port by clicking on <code>+</code>, activate <code>Host port</code> under <code>Modify options</code> and enter   <code>8000</code> in both fields (see image below). Confirm with <code>OK</code>.   </li> <li>Click on <code>Save</code> in the lower right corner. This will restart the container. Messages will appear   saying that the build failed. These messages can be ignored. The build process restarts automatically.</li> <li>After a few seconds, Click on this link.</li> <li>Now you should see a live preview of the documentation in your browser.</li> <li>You can edit the documentation in CLion. <code>Ctrl</code> + <code>s</code> saves the documentation and updates it in   the browser window.</li> <li>Cancel the build process to stop the live preview. To restart the live preview, you will have to   modify the container settings again. Therefore, it is recommended to stop the live preview   only after you have finished working on the documentation.</li> </ul>"},{"location":"03_contribution/codeStyle/","title":"Code style","text":"<p>This section explains some general implementational ideas used in various parts of the code. It is dedicated to the users who would like to extend or modify the implemented functionality and/or would like to learn more about the implementation strategies and certain theoretical aspects.</p>"},{"location":"03_contribution/codeStyle/#general-remarks","title":"General remarks","text":"<ul> <li>The directories and filenames use <code>camelCase</code>.</li> <li>The source files and the header files have a <code>cpp</code> and a <code>hh</code> extension, respectively.</li> <li>A <code>clang-format</code> file is used, which needs to be executed in each extended or modified file before a PR can be merged.</li> <li>Readability and value semantics are the essence of the code.</li> <li>Classnames use <code>PascalCase</code></li> <li>Commenting within the code and the other code styles were influenced by the books by Robert C. Martin<sup>1</sup> and John K. Ousterhout<sup>2</sup>.</li> </ul> <ol> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>John K. Ousterhout. A Philosophy of Software Design. Yaknyam Press, 2021.\u00a0\u21a9</p> </li> </ol>"},{"location":"03_contribution/howToEdit/","title":"How to edit this documentation","text":""},{"location":"03_contribution/howToEdit/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ikarus cloned on your computer,   see the download page.</li> </ul>"},{"location":"03_contribution/howToEdit/#edit-a-page","title":"Edit a page","text":"<ul> <li>Open Ikarus</li> <li>Go to the folder <code>docs\\website</code></li> <li>Go to the Markdown file that corresponds to the page to be edited</li> <li>Apply your changes using any desired tool</li> <li>Create a pull request</li> <li>Once the pull request is accepted, the website is automatically updated</li> </ul>"},{"location":"03_contribution/howToEdit/#add-a-new-page","title":"Add a new page","text":"<ul> <li>Open Ikarus</li> <li>Go to the folder <code>docs\\website</code> and create a new Markdown file,   e.g. <code>MyAdditionalPage.md</code>. The new Markdown file could be added in any relevant existing folder or added to a new folder starting   with a consecutive folder number, e.g., <code>XX_myFolder</code></li> <li>Open the file <code>docs\\mkdocs.yml</code></li> <li>Find the navigation section which starts with <code># Navigation</code></li> <li>The navigation section describes the navigation on the left side of the website. Add <code>XX_myFolder/MyAdditionalPage.md</code> where you want it to appear</li> <li>Create a pull request</li> <li>Once the pull request is accepted, the website is automatically updated</li> </ul>"},{"location":"03_contribution/howToEdit/#insert-a-latex-formula","title":"Insert a LaTeX formula","text":"<p>The Markdown format:</p> <p><code>$$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$</code></p> <p>The compiled output:</p> \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\]"},{"location":"03_contribution/howToEdit/#insert-a-c-code","title":"Insert a C++ code","text":"<p>The Markdown format:</p> <pre><code>    ```cpp\n    double complicatedCalculation(double number, double anotherNumber)\n    {\n      return number*anotherNumber;\n    };\n    ```\n</code></pre> <p>The compiled output:</p> <pre><code>double complicatedCalculation(double number, double anotherNumber)\n{\n  return number*anotherNumber;\n};\n</code></pre>"},{"location":"03_contribution/howToEdit/#insert-tables-warnings-and-notes","title":"Insert tables, warnings and notes","text":"<p>Look at the Markdown file (<code>03_contribution/howToEdit.md</code>) to see how tables, warnings and notes can be inserted.</p> Grid Entity Interface <code>GridViewType leafGridView()</code> <code>GridViewType levelGridView(int level)</code> <p>Insert a warning</p> <p>Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly.</p> <p>References</p> <p>For available features in the documentation see Mkdocs-Material and Mkdocs.</p>"},{"location":"03_contribution/openTask/","title":"Open tasks","text":"<p>Thank you for your interest in contributing to this code base. The following task are open for your contributions.</p>"},{"location":"03_contribution/openTask/#local-functions","title":"Local functions","text":"<ul> <li> <p>Implementing a unit normal field function<sup>1</sup> and its derivatives w.r.t. its coefficients \\( \\boldsymbol{x}_i \\)</p> \\[ \\boldsymbol{n} = \\frac{\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2}{||\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2||}, \\quad \\text{with } \\boldsymbol{a}_{\\alpha} = \\sum_{i=1}^n N^i_{,\\alpha}(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\] <p>To implement this, see link.</p> </li> <li> <p>Support second derivatives</p> </li> <li>Add \\( \\operatorname{div} \\) and \\( \\operatorname{curl} \\) wrapper</li> </ul>"},{"location":"03_contribution/openTask/#control-routines","title":"Control routines","text":"<ul> <li>Dynamics (Explicit/ implicit time stepping)</li> </ul>"},{"location":"03_contribution/openTask/#control-routines-addons","title":"Control routines - addons","text":"<ul> <li>Extended systems</li> <li>Nonlinear dependence of \\(F_{ext}\\) on \\(\\mathbf{D}\\) and \\(\\lambda\\) for path-following techniques, see control routines.</li> </ul>"},{"location":"03_contribution/openTask/#finite-element-helper","title":"Finite element helper","text":"<ul> <li>Implement a default mass matrix</li> </ul>"},{"location":"03_contribution/openTask/#finite-elements","title":"Finite elements","text":"<ul> <li>Nonlinear Reissner-Mindlin shell <sup>2</sup></li> <li>3D-Beam</li> <li>Standard beam and plate formulations</li> <li>Add calculation of different stress measures (push-forward or pull-back of PK2 stresses or similar)</li> </ul>"},{"location":"03_contribution/openTask/#further-addons","title":"Further addons","text":"<ul> <li>Muesli</li> </ul> <p>Code style</p> <p>For details on the code style, refer link.</p> <ol> <li> <p>This is usually needed for a Kirchhoff-Love shell implementation, see <sup>3</sup>.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> <li> <p>J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering, 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013.\u00a0\u21a9</p> </li> </ol>"},{"location":"04_blog/","title":"Blog","text":""},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/","title":"Release of v0.3 (Prometheus)","text":"<p>We are happy to announce that Ikarus has made it to version 0.3. In this version, some new features are added, and maintenance-related fixes have been done by us (Tarun and Alex). We are moving forward to the first version (v1.0) release, and we consider v0.3 to be a bigger milestone.</p> <p>As this is the first blog, we would like to start by sharing the thoughts behind the reasons for creating Ikarus. Being researchers ourselves, we found it motivating to have an independent code for investigating various aspects of computational mechanics. On that note, we proceeded with the finite element approach to implement a generic code for solving partial differential equations, which was inspired by generic algorithms. Consequently, Ikarus was born, granting us the wings to perform intensive research in this field. It is basically a C++ library, providing several features to carry out finite element analysis.</p> <p>During the development phase, we were always asked two questions: \"How to use Ikarus?\" and \"Why to use Ikarus when there are so many other tools to perform a finite element analysis\"? To address such concerns, we attempted to make things easier for users in this version by automating several workflows on GitHub, updating the documentation, and adding some concepts from finite element fundamentals with relevant examples. To be specific, the major concern was easy-to-read documentation. We hope that good documentation will motivate us to make even better documentation, in the spirit of an \"inverse\" broken windows theory. A quick overview of this version is provided in the following text.</p> <p> </p> Prometheus brings fire to humanity by Heinrich F\u00fcger"},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/#workflows","title":"Workflows","text":"<p>A workflow for codespell has been created in order to have a smarter CI. This workflow is executed on GitHub after every commit is pushed. The CI has now the capability to check grammar and typographical errors in comments and variable names. The examples, which resided earlier in the repository of Ikarus, have now been moved to a new repository. The users can thereby just use Ikarus as an external finite element library by installing it, followed by the execution of their own simulations. A workflow is created that checks if all the examples are working with every commit to the <code>main</code> branch of Ikarus. This ensures the proper functioning of the existing examples in Ikarus during the development of newer features. Docker images are automatically generated as well for systems with Ikarus installed, with commits to the <code>main</code> branch. The Docker images make it even easier to use Ikarus because no additional software is required. A license statement is also added to each file, and the license files themselves are separated into a separate folder. A workflow also checks for the inclusion of the license statement in the files associated with Ikarus. Moreover, we created a workflow that automatically creates a release on GitHub and pushes it to DaRUS, enabling us to assign a DOI to the current version.</p>"},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/#finite-element-technology","title":"Finite element technology","text":"<p>A beginner to finite element technology, in the context of computational solid mechanics, always starts with simulations in the linear-elastic regime. This instilled us with the desire to incorporate this element technology into Ikarus in a sophisticated way. As a result, we implemented a template-based code that enables the users to utilize the linear-elastic finite elements in single and multi-dimensions for various geometries with lesser modifications to the code. To avoid locking characteristics, the elements can also be decorated with the enhanced assumed strain (EAS) concept. A variety of examples, including the famous Cook's membrane problem, are made available to learn the implementation styles of Ikarus. This was followed by adding path-following techniques, which use a scalar subsidiary function to also solve non-linear problems. Furthermore, an additional class was added to handle homogeneous and inhomogeneous Dirichlet boundary conditions. A set of local functions that enable efficient implementation of finite elements are also moved to a separate repository for easier code handling and faster workflow processing in Ikarus.</p>"},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/#documentation-and-social-media","title":"Documentation and social media","text":"<p>For a better understanding of Ikarus, the entire documentation has been refactored with grammatical corrections and the inclusion of relevant information while excluding the unnecessary parts. Installation instructions, blog capabilities, and brief explanations of examples are added. Additionally, the snow plug-in from Material for MkDocs is included for this release as a seasonal plug-in. Links to the Ikarus developers' social media accounts can also be found on the bottom-right side of the page. Finally, a Gitter community is formed in order to interact more with users and quickly resolve issues.</p>"},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/#what-next","title":"What next?","text":"<p>The following are some key milestones that have been completed or are planned to be released as stepping stones to version 1.0.</p> <ul> <li> <p> Workflows</p> <ul> <li> License and example checks (#107 and #114)</li> <li> Create Docker images</li> <li> Create a workflow to create a \"release\" and add a version to DaRUS</li> <li> Deploy Python bindings to PyPi and create Python bindings</li> </ul> </li> <li> <p> Finite element technology</p> <ul> <li> Linear elastic finite elements with EAS (#74)</li> <li> Path-following techniques (#80)</li> <li> Efficient implementation of non-linear elasticity</li> <li> Standard plate and beam elements</li> <li> Handling inhomogeneous Dirichlet boundary conditions in all existing solving methods</li> <li> Include a mechanical-material library</li> <li> Linear dynamics</li> <li> More supporting examples</li> </ul> </li> <li> <p> Documentation</p> <ul> <li> Improving existing documentation and describing examples of Ikarus (#106 and #125)</li> <li> Detailed explanations of examples in Ikarus</li> <li> Implementation of linear and non-linear elasticity</li> <li> Logo and gallery</li> </ul> </li> </ul>"},{"location":"04_blog/2024/01/19/release-of-v04-ganymede/","title":"Release of v0.4 (Ganymede)","text":"<p>On our journey to Ikarus v1.0, we've taken another significant step forward. Explore the latest release, v0.4 (Ganymede). This release not only focuses on refactoring various interfaces but also introduces exciting features such as Python bindings, result evaluators, the Kirchhoff-Love shell element, added support for Clang 16, and more.</p> <ul> <li> Python for accessibility, PyPi</li> <li> Docker for reproducibility and ease of use, DockerHub</li> <li> Documentation Doxygen class documentation and examples Class documentation</li> <li> Gitter chat For discussions and support, Chat</li> <li> Clang 16 Clang support for more C++ standard compliant code</li> </ul>"},{"location":"04_blog/2024/01/19/release-of-v04-ganymede/#python-bindings","title":"Python bindings","text":"<p>As mentioned in the blog post of the v0.3 (Prometheus) release, Ikarus is a C++ library for finite element analysis. In this version, we've introduced Python bindings, allowing users to work seamlessly within Python while still using Ikarus' powerful C++ backend. These bindings are now available on PyPi, making it easy to install Ikarus with <code>pip install pyikarus</code>. These Python bindings depend on other DUNE libraries because they are compiled just-in-time (JIT). The easiest way to use the Python bindings is therefore within the provided Docker images Docker image we provide. This addition aims to expand Ikarus's usage in academia for teaching purposes, providing a simpler interface for Python users. Now, Ikarus can thus be integrated with popular libraries like TensorFlow and SciPy for data-driven simulations.</p> <p> </p> The Rape of Ganymede  by Peter Paul Rubens <p> </p> Ganymede photographed by Juno in 2021. Moon of Jupiter and largest moon in the solar system."},{"location":"04_blog/2024/01/19/release-of-v04-ganymede/#finite-element-technology","title":"Finite element technology","text":"<p>While linear-elastic finite elements and geometrically non-linear elements based on automatic differentiation were already present in Ikarus, this release introduces a more explicit implementation of non-linear elements for increased efficiency. Post-processing capabilities have been enhanced with wrappers for evaluating results like Von-Mises stress, principal stresses, and other stress measures specific to different finite elements. Assemblers now allow the study of raw matrices and vectors before applying any boundary conditions. The release also integrates an interface for a material library, including material models like the St. Venant-Kirchhoff and a Neo-Hookean model. One can directly use these in the finite element analysis, even for plane stress problems, by utilizing a vanishing stress wrapper (Doxygen). Improved control loggers enable static non-linear analysis, providing relevant information to users. Additionally, a non-linear Kirchhoff-Love shell element is now available for studying thin-walled structures.</p>"},{"location":"04_blog/2024/01/19/release-of-v04-ganymede/#documentation","title":"Documentation","text":"<p>This release includes detailed documentation for all examples in <code>ikarus-examples</code> and adds Doxygen class documentation. Each class and public function now have Doxygen comment blocks that provide comprehensive descriptions.</p>"},{"location":"04_blog/2024/01/19/release-of-v04-ganymede/#miscellaneous","title":"Miscellaneous","text":"<p>In addition to the mentioned features, some miscellaneous additions have been made. Changes in the directory structure and file naming now follow the convention of using only lowercase letters.</p> <p>In addition, we've introduced Clang 16 support in this release, giving users the flexibility to choose their preferred compiler. Ikarus continues to support GCC 12, ensuring compatibility with multiple compilers.</p>"},{"location":"04_blog/2024/01/19/release-of-v04-ganymede/#conferences","title":"Conferences","text":"<p>During 2023, Ikarus gained popularity and was presented at two conferences: the 11<sup>th</sup> International Conference on Isogeometric Analysis and the Dune User Meeting 2023. A snapshot from the IGA conference is shared, where Ikarus was presented alongside the <code>dune-iga</code> module.</p> <p></p> Ikarus presented at the 11th International Conference on Isogeometric Analysis (Alex (left) and Tarun(right))"},{"location":"04_blog/2024/01/19/release-of-v04-ganymede/#what-next","title":"What next?","text":"<p>The following are some key milestones that have been completed or are planned to be released as stepping stones to version 1.0.</p> <ul> <li> <p> Workflows</p> <ul> <li> License and example checks (#107 and #114)</li> <li> Create Docker images</li> <li> Create a workflow to create a \"release\" and add a version to DaRUS</li> <li> Deploy Python bindings to PyPi and create Python bindings</li> <li> Clang 16 support (#186)</li> </ul> </li> <li> <p> Finite element technology</p> <ul> <li> Linear elastic finite elements with EAS (#74)</li> <li> Path-following techniques (#80)</li> <li> Efficient implementation of non-linear elasticity (#160)</li> <li> Wrapper to evaluate results (#165)</li> <li> Interface for a mechanical-material library (#154)</li> <li> Kirchhoff-Love shell elements (#177 and #225)</li> <li> Default adaptive step sizing and improved control loggers (#193)</li> <li> Standard plate and beam elements</li> <li> Handling inhomogeneous Dirichlet boundary conditions in all existing solving methods</li> <li> Enhance the mechanical-material library</li> <li> Linear dynamics</li> <li> Local Assemblers</li> <li> Handling of reduced matrices and vectors</li> <li> Advanced adaptive step sizing features</li> <li> Push-forward and pull-back operations for stress measures</li> <li> Advanced locking-free non-linear finite elements</li> </ul> </li> <li> <p> Documentation</p> <ul> <li> Improving existing documentation and describing examples of Ikarus (#106 and #125)</li> <li> Detailed explanations of examples in Ikarus (#140)</li> <li> Class documentation (#220)</li> <li> More Documentation for Python bindings</li> <li> Document list of dependencies</li> <li> Gallery</li> </ul> </li> </ul>"},{"location":"05_cppReferences/cppRef/","title":"C++ recommendations","text":"<p>Since Ikarus is written in C++, we summarize our recommendations to dig deeper into C++ coding on this page.</p>"},{"location":"05_cppReferences/cppRef/#best-practices","title":"Best practices","text":"<ol> <li>C++ Core Guidelines</li> <li>Jason Turner's collection of best practices</li> <li>More C++ idioms</li> </ol>"},{"location":"05_cppReferences/cppRef/#videos","title":"Videos","text":"<p>Here we collect some useful videos on general coding or coding with C++:</p> <ol> <li>Clean Code - Uncle Bob / Lesson 1 - How to write code cleanly, see also <sup>1</sup></li> <li>CppCon 2014: Herb Sutter \"Back to the Basics! Essentials of Modern C++ Style\"</li> <li>CppCon 2018: Jonathan Boccara \u201c105 STL Algorithms in Less Than an Hour\u201d - \"Almost\" all    algorithms in the STL</li> <li>Back to Basics: Object-Oriented Programming - Jon Kalb - CppCon 2019    How to do modern \"Object-Oriented Programming\" (if you really have to)</li> <li>CppCon 2021 - Back To Basics</li> <li>CppCon 2019 - Back to Basics</li> </ol>"},{"location":"05_cppReferences/cppRef/#books","title":"Books","text":"<ol> <li>[Meyers S. 1995]<sup>2</sup></li> <li>[Gamma E. et al. 1995]<sup>3</sup></li> <li>[Meyers S. 2005]<sup>4</sup></li> <li>[Reddy M. 2011]<sup>5</sup></li> <li>[Iglberger K. 2022]<sup>6</sup></li> </ol>"},{"location":"05_cppReferences/cppRef/#further-references","title":"Further references","text":"<ol> <li>Learn cpp - Lots of tutorials from beginners up to more advanced concepts</li> <li>Cppcon Videos - These videos are released after every C++ conference. For beginners, the \"Back    to basics\" track is recommended.</li> <li>Godblot - Online compiler with assembler output. It's useful to quickly determine whether something will be    fast or slow.    Furthermore, libraries like Eigen can be added. Also, any other header files found on the internet can be included with the link.</li> <li>Blog by Arthur O'Dwyer</li> </ol> <ol> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version. Pearson Education, 1995.\u00a0\u21a9</p> </li> <li> <p>Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH, 1995.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs. Pearson Education, 2005.\u00a0\u21a9</p> </li> <li> <p>Martin Reddy. API Design for C++. Elsevier, 2011.\u00a0\u21a9</p> </li> <li> <p>Klaus Iglberger. C++ Software Design: Design Principles and Patterns for High-Quality Software. O'Reilly, 2022.\u00a0\u21a9</p> </li> </ol>"},{"location":"99_Literature/99Literature/","title":"Literature","text":"<ol> <li> <p>Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal, 57(1):404\u2013428, 2019. doi:10.1137/18M1176798.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> <li> <p>J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering, 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013.\u00a0\u21a9</p> </li> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>J. C. Simo and M. S. Rifai. A class of mixed assumed strain methods and the method of incompatible modes. Int. J. Numer. Meth. Engng., 29(8):1595\u20131638, June 1990. doi:10.1002/nme.1620290802.\u00a0\u21a9</p> </li> <li> <p>U. Andelfinger and E. Ramm. EAS-elements for two-dimensional, three-dimensional, plate and shell structures and their equivalence to HR-elements. International Journal for Numerical Methods in Engineering, 36(8):1311\u20131337, 1993. doi:10.1002/nme.1620360805.\u00a0\u21a9</p> </li> <li> <p>Gerald A. Wempner. Discrete approximations related to nonlinear theories of solids. International Journal of Solids and Structures, 7(11):1581\u20131599, 1971. doi:10.1016/0020-7683(71)90038-2.\u00a0\u21a9</p> </li> <li> <p>M.A. Crisfield. A fast incremental/iterative solution procedure that handles \u201csnap-through\u201d. Computers &amp; Structures, 13(1):55\u201362, 1981. doi:10.1016/0045-7949(81)90108-5.\u00a0\u21a9</p> </li> <li> <p>E. Ramm. Strategies for Tracing the Nonlinear Response Near Limit Points. In W. Wunderlich, E. Stein, and K.-J. Bathe, editors, Nonlinear Finite Element Analysis in Structural Mechanics, pages 63\u201389. Springer Berlin Heidelberg, Berlin, Heidelberg, 1981. doi:10.1007/978-3-642-81589-8_5.\u00a0\u21a9</p> </li> <li> <p>E. Riks. The Application of Newton\u2019s Method to the Problem of Elastic Stability. Journal of Applied Mechanics, 39(4):1060\u20131065, 1972. doi:10.1115/1.3422829.\u00a0\u21a9</p> </li> <li> <p>Robert D. Cook. Improved Two-Dimensional Finite Element. J. Struct. Div., 100(9):1851\u20131863, September 1974. doi:10.1061/JSDEAG.0003877.\u00a0\u21a9</p> </li> <li> <p>J. Austin Cottrell, Thomas J. R. Hughes, and Yuri Bazilevs. Isogeometric Analysis: Toward Integration of CAD and FEA. Wiley, 2009.\u00a0\u21a9</p> </li> <li> <p>R. V. Mises. \u00dcber die stabilit\u00e4tsprobleme der elastizit\u00e4tstheorie. ZAMM - Journal of Applied Mathematics and Mechanics / Zeitschrift f\u00fcr Angewandte Mathematik und Mechanik, 3(6):406\u2013422, 1923. doi:10.1002/zamm.19230030602.\u00a0\u21a9</p> </li> <li> <p>Oliver Sander. Geodesic finite elements for cosserat rods. International Journal for Numerical Methods in Engineering, 82(13):1645\u20131670, 2010. doi:10.1002/nme.2814.\u00a0\u21a9</p> </li> <li> <p>Javier Bonet and Richard D. Wood. Nonlinear Continuum Mechanics for Finite Element Analysis. Cambridge University Press, 2<sup>nd</sup> edition, 2008. doi:https://doi.org/10.1017/CBO9780511755446.\u00a0\u21a9</p> </li> <li> <p>Andrew R. Conn, Nicholas I. M. Gould, and Philippe L. Toint. Trust Region Methods. Society for Industrial and Applied Mathematics, edition, 2000. URL: https://epubs.siam.org/doi/abs/10.1137/1.9780898719857, arXiv:https://epubs.siam.org/doi/pdf/10.1137/1.9780898719857, doi:10.1137/1.9780898719857.\u00a0\u21a9</p> </li> <li> <p>Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH, 1995.\u00a0\u21a9</p> </li> <li> <p>Martin Reddy. API Design for C++. Elsevier, 2011.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs. Pearson Education, 2005.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version. Pearson Education, 1995.\u00a0\u21a9</p> </li> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>John K. Ousterhout. A Philosophy of Software Design. Yaknyam Press, 2021.\u00a0\u21a9</p> </li> <li> <p>Klaus Iglberger. C++ Software Design: Design Principles and Patterns for High-Quality Software. O'Reilly, 2022.\u00a0\u21a9</p> </li> </ol>"},{"location":"doxygen/mainpage/","title":"Introduction","text":""},{"location":"doxygen/mainpage/#overview","title":"Overview","text":"<p>This is the class documentation for the Ikarus module. This project tries to provide an easy-to-read and an easy-to-use finite element framework. It is heavily inspired by the finite element software DUNE, the book DUNE \u2014 The Distributed and Unified Numerics Environment, deal.II and Kratos. Furthermore, it directly uses several modules from DUNE.</p> <p>\\section mods Modules The best way to start is from the page \\ref group_main \"Modules\" which gives you access to the documentation by category.</p> <p>For the license, see \\ref LICENSE.md \"License\".</p>"},{"location":"doxygen/mainpage/#how-to-cite","title":"How to cite","text":"<p>Ikarus is research software and developed at research institutions. You can cite specific releases via DaRUS. You can also cite individual code files or even lines via Software Heritage: </p> <p>If you are using Ikarus in scientific publications and in the academic context, please cite publication:</p> <p>Ikarus v0.4. </p> <pre><code>@data{darus-3303_2023,\nauthor = {M\u00fcller, Alexander and Vinod Kumar Mitruka, Tarun Kumar Mitruka and Jakob, Henrik},\npublisher = {DaRUS},\ntitle = {Ikarus v0.4},\nyear = {2024},\nversion = {V1},\ndoi = {10.18419/darus-3889},\nurl = {https://doi.org/10.18419/darus-3889}\n}\n</code></pre>"},{"location":"04_blog/archive/2024/","title":"2024","text":""},{"location":"04_blog/archive/2022/","title":"2022","text":""},{"location":"04_blog/category/release/","title":"Release","text":""},{"location":"04_blog/category/python-bindings/","title":"Python Bindings","text":""},{"location":"04_blog/category/structural-mechanics/","title":"Structural mechanics","text":""},{"location":"04_blog/category/documentation/","title":"Documentation","text":""},{"location":"04_blog/category/clang/","title":"Clang","text":""},{"location":"04_blog/category/prometheus/","title":"Prometheus","text":""},{"location":"04_blog/category/linear-elasticity/","title":"Linear elasticity","text":""},{"location":"04_blog/category/path-following/","title":"Path-following","text":""},{"location":"04_blog/category/docker-images/","title":"Docker images","text":""},{"location":"04_blog/category/licenses/","title":"Licenses","text":""}]}