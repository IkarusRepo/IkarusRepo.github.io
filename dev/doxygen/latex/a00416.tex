\hypertarget{a00416}{}\doxysection{Ikarus\+::utils Namespace Reference}
\label{a00416}\index{Ikarus::utils@{Ikarus::utils}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{a01915}{Check\+Flags}}
\begin{DoxyCompactList}\small\item\em Struct to hold flags for function checks. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01859}{Solver\+Default}}
\begin{DoxyCompactList}\small\item\em Default functor for solving operations. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01863}{Update\+Default}}
\begin{DoxyCompactList}\small\item\em Default functor for updating operations. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{a00393_ga6e36d8f5163f232e3142ecbd0575e8b4}{make\+Unique\+And\+Sort}} (std\+::ranges\+::random\+\_\+access\+\_\+range auto \&r)
\begin{DoxyCompactList}\small\item\em Sorts and removes duplicate elements from a random access range.

$\ast$. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\auto \mbox{\hyperlink{a00393_ga0ccbb016e46741bd00c69436dc11e2d0}{append\+Unique}} (std\+::ranges\+::random\+\_\+access\+\_\+range auto \&r, T \&\&v)
\begin{DoxyCompactList}\small\item\em Appends a value to the range if it is not already present. \end{DoxyCompactList}\item 
{\footnotesize template$<$class C $>$ }\\void \mbox{\hyperlink{a00393_ga2b7954c72a2393ab7494fa0b66d828cd}{print\+Content}} (C \&\&c, std\+::ostream \&os=std\+::cout)
\begin{DoxyCompactList}\small\item\em Prints the contents of a container to the specified output stream. \end{DoxyCompactList}\item 
{\footnotesize template$<$class C $>$ }\\auto \mbox{\hyperlink{a00393_ga7f597d87c8f2bcbf4afc65ebc929b680}{transform\+Value\+Range\+To\+Pointer\+Range}} (C \&cont)
\begin{DoxyCompactList}\small\item\em Transforms a value range to a pointer range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class C $>$ }\\auto \mbox{\hyperlink{a00393_ga83bd9e4f59f0aa9fadd797efefa751d9}{transform\+Pointer\+Range\+To\+Reference\+Range}} (C \&cont)
\begin{DoxyCompactList}\small\item\em Transforms a pointer range to a reference range. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\constexpr size\+\_\+t \mbox{\hyperlink{a00393_gaf75511e781bb89056badd33413222010}{find\+\_\+if}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Finds the index of the first element in the tuple satisfying a predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\bool \mbox{\hyperlink{a00393_ga33284bcf99d7d3870e0aff06f6651aa2}{none\+\_\+of}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Checks if none of the elements in the tuple satisfy a given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\bool \mbox{\hyperlink{a00393_gab6d955a70ec9215ae9a8f3841582ab49}{any\+\_\+of}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Checks if any of the elements in the tuple satisfy a given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\auto \mbox{\hyperlink{a00393_gad9f30d486a3d9151d534ec1b0fad5341}{filter}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Filters the elements of a tuple based on a given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Types$>$ }\\constexpr auto \mbox{\hyperlink{a00393_ga12de8f77a63ef488a87a5aa8536146ee}{unique}} (std\+::tuple$<$ Types... $>$ \&\&tuple)
\begin{DoxyCompactList}\small\item\em Creates a tuple with unique types from the given tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\constexpr size\+\_\+t \mbox{\hyperlink{a00393_gae9a7254f583151ee431db537c9980865}{count\+\_\+if}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Counts the number of elements in the tuple satisfying the given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\constexpr int \mbox{\hyperlink{a00393_ga62d8ab565d41e49db75f0641bcdf0740}{find\+Type\+Specialization}} ()
\begin{DoxyCompactList}\small\item\em Finds the index of the first element in the tuple that is a specialization of the given template type. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\auto \mbox{\hyperlink{a00393_ga05a5ccea0f87d41fc69956f55a2c1dbd}{get\+Specialization}} (Tuple \&\&tuple)
\begin{DoxyCompactList}\small\item\em Gets the specialization of the given template type from the tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\constexpr bool \mbox{\hyperlink{a00393_gaec2a5de0482441ef1e1c68fb7ff8a0bc}{has\+Type\+Specialization}} ()
\begin{DoxyCompactList}\small\item\em Checks if a tuple has a specialization of a template type. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\constexpr bool \mbox{\hyperlink{a00393_gadf919f3a9b0c1d50134f9d041a3ce9f7}{count\+Type\+Specialization}} ()
\begin{DoxyCompactList}\small\item\em Counts the occurrences of a specialization of a template type in a tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$int N, class Tuple $>$ }\\constexpr auto \mbox{\hyperlink{a00393_ga32de94604b9d1a7423134f33f49d613f}{make\+Tuple\+Subset}} (Tuple \&\&t)
\begin{DoxyCompactList}\small\item\em Creates a subset tuple with the first N elements from the given tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Tuple , std\+::size\+\_\+t... I$>$ }\\constexpr auto \mbox{\hyperlink{a00393_gaef801f15c9f18ae16e4241a497c33e96}{make\+Tuple\+From\+Tuple\+Indices}} (Tuple \&\&t)
\begin{DoxyCompactList}\small\item\em Creates a new tuple using indices from the original tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Types$>$ }\\auto \mbox{\hyperlink{a00416_a4c617d2458cc6d792f5ba3e6c64a0c7f}{make\+Nested\+Tuple\+Flat}} (std\+::tuple$<$ Types... $>$)
\begin{DoxyCompactList}\small\item\em Creates a flattened nested tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple $>$ }\\auto \mbox{\hyperlink{a00416_a162c64656f5917b717a6b44ebf4c9ebf}{make\+Nested\+Tuple\+Flat\+And\+Store\+References}} (Tuple \&\&tup)
\begin{DoxyCompactList}\small\item\em Creates a flattened nested tuple and stores references. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ \newline
requires traits\+::\+Pointer$<$T$>$}\\auto \& \mbox{\hyperlink{a00416_aa156028e47fc302b02a7e70dea888034}{return\+Reference\+Or\+Nullopt\+If\+Object\+Is\+Null\+Ptr}} (T v)
\begin{DoxyCompactList}\small\item\em Returns a reference or std\+::nullopt if the object is a nullptr. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Fun , typename... Vars, typename... Args, typename U , typename G , typename H $>$ }\\void \mbox{\hyperlink{a00391_ga2a6c26beeb8d52283e82939ca585dc20}{hessianN}} (const Fun \&f, const autodiff\+::\+Wrt$<$ Vars... $>$ \&wrt, const autodiff\+::\+At$<$ Args... $>$ \&at, U \&u, std\+::array$<$ G, U\+::\+Rows\+At\+Compile\+Time $>$ \&g, std\+::array$<$ H, U\+::\+Rows\+At\+Compile\+Time $>$ \&h)
\begin{DoxyCompactList}\small\item\em Computes the Hessian matrix for each parameter of a given function.

The Hessian matrix represents the second-\/order partial derivatives of the function with respect to the specified variables. \end{DoxyCompactList}\item 
std\+::tuple$<$ Dune\+::\+Functions\+::\+Polynomial$<$ double $>$, decltype(Eigen\+::seq(0, 0))$>$ \mbox{\hyperlink{a00391_ga16e7d5f51cc42190c090e727495c1609}{find\+Line\+Segment}} (const Eigen\+::\+Vector\+Xd \&x, const Eigen\+::\+Vector\+Xd \&y, int segment\+Size)
\begin{DoxyCompactList}\small\item\em Find a linear segment in a set of data points. \end{DoxyCompactList}\item 
{\footnotesize template$<$int size, typename LV $>$ }\\void \mbox{\hyperlink{a00391_gae9098182120929a0d21cff1c38f5ca84}{obtain\+Lagrange\+Global\+Node\+Positions}} (const LV \&local\+View, std\+::vector$<$ \mbox{\hyperlink{a01867}{Dune\+::\+Field\+Vector}}$<$ double, size $>$ $>$ \&lagrange\+Node\+Global\+Coords)
\begin{DoxyCompactList}\small\item\em A function to obtain the global positions of the nodes of an element with Lagrangian basis. \end{DoxyCompactList}\item 
{\footnotesize template$<$int size, typename Basis $>$ }\\auto \mbox{\hyperlink{a00391_gaa19ed04a701aaa500f7c486addae2d2e}{global\+Index\+From\+Global\+Position}} (const Basis \&basis, const \mbox{\hyperlink{a01867}{Dune\+::\+Field\+Vector}}$<$ double, size $>$ \&pos)
\begin{DoxyCompactList}\small\item\em A helper function to obtain the global index from the global positions for a Lagrange node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{a01355}{FE}} $>$ }\\auto \mbox{\hyperlink{a00391_ga30df35336d19b00bc5db2a0b52ce650e}{reference\+Element\+Sub\+Entity\+Positions}} (\mbox{\hyperlink{a01355}{FE}} \&fe, int codim)
\begin{DoxyCompactList}\small\item\em A function to obtain the local coordinates of subentities of an Finite\+Element. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{a01355}{FE}} $>$ }\\auto \mbox{\hyperlink{a00391_ga8c05dce8a66fc4efbe31674b87d18298}{reference\+Element\+Vertex\+Positions}} (\mbox{\hyperlink{a01355}{FE}} \&fe)
\begin{DoxyCompactList}\small\item\em A function to obtain the local coordinates the vertices of an Finite\+Element. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Nonlinear\+Operator , typename Update\+Type  = typename Nonlinear\+Operator\+::template Parameter\+Value$<$0$>$$>$ }\\bool \mbox{\hyperlink{a00391_gacb9e813539bfd84df99ad097cabc9de9}{check\+Gradient}} (Nonlinear\+Operator \&non\+Lin\+Op, \mbox{\hyperlink{a01915}{Check\+Flags}} check\+Flags=\mbox{\hyperlink{a01915}{Check\+Flags}}(), std\+::function$<$ void(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&, const Update\+Type \&)$>$ p\+\_\+update\+Function=\mbox{[}$\,$\mbox{]}(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&a, const Update\+Type \&b) \{ a+=b;\})
\begin{DoxyCompactList}\small\item\em Checks the gradient of a nonlinear operator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Nonlinear\+Operator , typename Update\+Type  = typename Nonlinear\+Operator\+::template Parameter\+Value$<$0$>$$>$ }\\bool \mbox{\hyperlink{a00391_ga553465359c199ef676945832587d2869}{check\+Jacobian}} (Nonlinear\+Operator \&non\+Lin\+Op, \mbox{\hyperlink{a01915}{Check\+Flags}} check\+Flags=\mbox{\hyperlink{a01915}{Check\+Flags}}(), std\+::function$<$ void(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&, const Update\+Type \&)$>$ p\+\_\+update\+Function=\mbox{[}$\,$\mbox{]}(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&a, const Update\+Type \&b) \{ a+=b;\})
\begin{DoxyCompactList}\small\item\em Checks the Jacobian of a nonlinear operator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Nonlinear\+Operator , typename Update\+Type  = typename Nonlinear\+Operator\+::template Parameter\+Value$<$0$>$$>$ }\\bool \mbox{\hyperlink{a00391_ga5d1a87964a3d6b6ddc994532e93b6798}{check\+Hessian}} (Nonlinear\+Operator \&non\+Lin\+Op, \mbox{\hyperlink{a01915}{Check\+Flags}} check\+Flags=\mbox{\hyperlink{a01915}{Check\+Flags}}(), std\+::function$<$ void(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&, const Update\+Type \&)$>$ p\+\_\+update\+Function=\mbox{[}$\,$\mbox{]}(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&a, const Update\+Type \&b) \{ a+=b;\})
\begin{DoxyCompactList}\small\item\em Checks the Hessian of a nonlinear operator. \end{DoxyCompactList}\item 
std\+::tuple$<$ Dune\+::\+Functions\+::\+Polynomial$<$ double $>$, double $>$ \mbox{\hyperlink{a00391_ga0d3a38551806e4de3ff44f311847ba51}{polyfit}} (const Eigen\+::\+Ref$<$ const Eigen\+::\+Vector\+Xd $>$ \&x, const Eigen\+::\+Ref$<$ const Eigen\+::\+Vector\+Xd $>$ \&y, int deg)
\begin{DoxyCompactList}\small\item\em Fits a polynomial of a given degree to the given data points. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T , class Tree\+Path , class Power\+Func , class Leaf\+Func $>$ }\\void \mbox{\hyperlink{a00416_a63742d75d099b93da7ddf6e78a3c1f56}{for\+Each\+Leaf\+Or\+Power\+Leaf\+Node}} (T \&\&tree, Tree\+Path \&\&tree\+Path, Power\+Func \&\&power\+Func, Leaf\+Func \&\&leaf\+Func)
\begin{DoxyCompactList}\small\item\em A function which loops over all the nodes of a tree and performs different actions for a power node (with leaf node as child) and a leaf node depending on the corresponding functor passed. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename LV , typename F , int size = LV\+::\+Element\+::\+Geometry\+::coorddimension$>$ \newline
requires (std\+::convertible\+\_\+to$<$F, std\+::function$<$bool(int, \mbox{\hyperlink{a01867}{Dune\+::\+Field\+Vector}}$<$double, size$>$ \&\&)$>$$>$)}\\void \mbox{\hyperlink{a00416_a9bfdb235951b98b7a214704baf9c6f95}{for\+Each\+Lagrange\+Node\+Position}} (const LV \&local\+View, F \&\&f)
\begin{DoxyCompactList}\small\item\em A helper function that helps in traversing over the local coordinates of an element and call a user-\/desired function. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\static constexpr bool \mbox{\hyperlink{a00393_ga62ee166e690831f40395df076e9cdddb}{count\+Type\+Specialization\+\_\+v}} = \mbox{\hyperlink{a00393_gadf919f3a9b0c1d50134f9d041a3ce9f7}{count\+Type\+Specialization}}$<$Type, Tuple$>$()
\begin{DoxyCompactList}\small\item\em Variable template for counting the occurrences of a specialization of a template type in a tuple. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{a00416_a9bfdb235951b98b7a214704baf9c6f95}\label{a00416_a9bfdb235951b98b7a214704baf9c6f95}} 
\index{Ikarus::utils@{Ikarus::utils}!forEachLagrangeNodePosition@{forEachLagrangeNodePosition}}
\index{forEachLagrangeNodePosition@{forEachLagrangeNodePosition}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{forEachLagrangeNodePosition()}{forEachLagrangeNodePosition()}}
{\footnotesize\ttfamily template$<$typename LV , typename F , int size = LV\+::\+Element\+::\+Geometry\+::coorddimension$>$ \newline
requires (std\+::convertible\+\_\+to$<$F, std\+::function$<$bool(int, \mbox{\hyperlink{a01867}{Dune\+::\+Field\+Vector}}$<$double, size$>$ \&\&)$>$$>$)\\
void Ikarus\+::utils\+::for\+Each\+Lagrange\+Node\+Position (\begin{DoxyParamCaption}\item[{const LV \&}]{local\+View,  }\item[{F \&\&}]{f }\end{DoxyParamCaption})}

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00419}{Dune}} book page 314 for details 
\end{DoxySeeAlso}

\begin{DoxyTemplParams}{Template Parameters}
{\em size} & Size of the global nodal coordinate vector \\
\hline
{\em LV} & Type of the local view \\
\hline
{\em F} & Type of the functor that traverses over the local coordinate of an element \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em local\+View} & Local view bounded to an element \\
\hline
{\em f} & A function that traverses over the local coordinate of an element \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00416_a9bfdb235951b98b7a214704baf9c6f95_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00416_a63742d75d099b93da7ddf6e78a3c1f56}\label{a00416_a63742d75d099b93da7ddf6e78a3c1f56}} 
\index{Ikarus::utils@{Ikarus::utils}!forEachLeafOrPowerLeafNode@{forEachLeafOrPowerLeafNode}}
\index{forEachLeafOrPowerLeafNode@{forEachLeafOrPowerLeafNode}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{forEachLeafOrPowerLeafNode()}{forEachLeafOrPowerLeafNode()}}
{\footnotesize\ttfamily template$<$class T , class Tree\+Path , class Power\+Func , class Leaf\+Func $>$ \\
void Ikarus\+::utils\+::for\+Each\+Leaf\+Or\+Power\+Leaf\+Node (\begin{DoxyParamCaption}\item[{T \&\&}]{tree,  }\item[{Tree\+Path \&\&}]{tree\+Path,  }\item[{Power\+Func \&\&}]{power\+Func,  }\item[{Leaf\+Func \&\&}]{leaf\+Func }\end{DoxyParamCaption})}

This function is inspired from the function Dune\+::\+Type\+Tree\+::\+Detail\+::for\+Each\+Node available in dune/typetree/traversal.\+hh


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of tree. \\
\hline
{\em Tree\+Path} & Type of the Hybrid\+Tree\+Path. \\
\hline
{\em Power\+Func} & Type of the functor called for a power node. \\
\hline
{\em Leaf\+Func} & Type of the functor called for a leaf node. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tree} & Tree whose nodes are to be looped over. \\
\hline
{\em tree\+Path} & The tree path which handles index values. \\
\hline
{\em power\+Func} & A functor to be called for a power node. \\
\hline
{\em leaf\+Func} & A functor to be called for a leaf node. \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=217pt]{a00416_a63742d75d099b93da7ddf6e78a3c1f56_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00416_a4c617d2458cc6d792f5ba3e6c64a0c7f}\label{a00416_a4c617d2458cc6d792f5ba3e6c64a0c7f}} 
\index{Ikarus::utils@{Ikarus::utils}!makeNestedTupleFlat@{makeNestedTupleFlat}}
\index{makeNestedTupleFlat@{makeNestedTupleFlat}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{makeNestedTupleFlat()}{makeNestedTupleFlat()}}
{\footnotesize\ttfamily template$<$typename... Types$>$ \\
auto Ikarus\+::utils\+::make\+Nested\+Tuple\+Flat (\begin{DoxyParamCaption}\item[{std\+::tuple$<$ Types... $>$}]{ }\end{DoxyParamCaption})}


\begin{DoxyTemplParams}{Template Parameters}
{\em Types} & Types contained in the original tuple. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
A new flattened nested tuple. 
\end{DoxyReturn}
\mbox{\Hypertarget{a00416_a162c64656f5917b717a6b44ebf4c9ebf}\label{a00416_a162c64656f5917b717a6b44ebf4c9ebf}} 
\index{Ikarus::utils@{Ikarus::utils}!makeNestedTupleFlatAndStoreReferences@{makeNestedTupleFlatAndStoreReferences}}
\index{makeNestedTupleFlatAndStoreReferences@{makeNestedTupleFlatAndStoreReferences}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{makeNestedTupleFlatAndStoreReferences()}{makeNestedTupleFlatAndStoreReferences()}}
{\footnotesize\ttfamily template$<$typename Tuple $>$ \\
auto Ikarus\+::utils\+::make\+Nested\+Tuple\+Flat\+And\+Store\+References (\begin{DoxyParamCaption}\item[{Tuple \&\&}]{tup }\end{DoxyParamCaption})}


\begin{DoxyTemplParams}{Template Parameters}
{\em Tuple} & Type of the original tuple. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tup} & The original tuple. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new tuple with stored references.
\end{DoxyReturn}
This function creates a flattened nested tuple and stores references. \mbox{\Hypertarget{a00416_aa156028e47fc302b02a7e70dea888034}\label{a00416_aa156028e47fc302b02a7e70dea888034}} 
\index{Ikarus::utils@{Ikarus::utils}!returnReferenceOrNulloptIfObjectIsNullPtr@{returnReferenceOrNulloptIfObjectIsNullPtr}}
\index{returnReferenceOrNulloptIfObjectIsNullPtr@{returnReferenceOrNulloptIfObjectIsNullPtr}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{returnReferenceOrNulloptIfObjectIsNullPtr()}{returnReferenceOrNulloptIfObjectIsNullPtr()}}
{\footnotesize\ttfamily template$<$typename T $>$ \newline
requires traits\+::\+Pointer$<$T$>$\\
auto \& Ikarus\+::utils\+::return\+Reference\+Or\+Nullopt\+If\+Object\+Is\+Null\+Ptr (\begin{DoxyParamCaption}\item[{T}]{v }\end{DoxyParamCaption})}


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of the pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em v} & Pointer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference or std\+::nullopt. 
\end{DoxyReturn}
