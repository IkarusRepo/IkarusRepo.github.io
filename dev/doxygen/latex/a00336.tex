\hypertarget{a00336}{}\doxysection{Ikarus\+::utils Namespace Reference}
\label{a00336}\index{Ikarus::utils@{Ikarus::utils}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{a01523}{Check\+Flags}}
\begin{DoxyCompactList}\small\item\em Struct to hold flags for function checks. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01483}{Load\+Default}}
\begin{DoxyCompactList}\small\item\em Empty struct representing a default load operation. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01475}{Solver\+Default}}
\begin{DoxyCompactList}\small\item\em Default functor for solving operations. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01479}{Update\+Default}}
\begin{DoxyCompactList}\small\item\em Default functor for updating operations. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{a00322_ga6e36d8f5163f232e3142ecbd0575e8b4}{make\+Unique\+And\+Sort}} (std\+::ranges\+::random\+\_\+access\+\_\+range auto \&r)
\begin{DoxyCompactList}\small\item\em Sorts and removes duplicate elements from a random access range.

$\ast$. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\auto \mbox{\hyperlink{a00322_ga0ccbb016e46741bd00c69436dc11e2d0}{append\+Unique}} (std\+::ranges\+::random\+\_\+access\+\_\+range auto \&r, T \&\&v)
\begin{DoxyCompactList}\small\item\em Appends a value to the range if it is not already present. \end{DoxyCompactList}\item 
{\footnotesize template$<$class C $>$ }\\void \mbox{\hyperlink{a00322_ga2b7954c72a2393ab7494fa0b66d828cd}{print\+Content}} (C \&\&c, std\+::ostream \&os=std\+::cout)
\begin{DoxyCompactList}\small\item\em Prints the contents of a container to the specified output stream. \end{DoxyCompactList}\item 
{\footnotesize template$<$class C $>$ }\\auto \mbox{\hyperlink{a00322_ga7f597d87c8f2bcbf4afc65ebc929b680}{transform\+Value\+Range\+To\+Pointer\+Range}} (C \&cont)
\begin{DoxyCompactList}\small\item\em Transforms a value range to a pointer range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class C $>$ }\\auto \mbox{\hyperlink{a00322_ga83bd9e4f59f0aa9fadd797efefa751d9}{transform\+Pointer\+Range\+To\+Reference\+Range}} (C \&cont)
\begin{DoxyCompactList}\small\item\em Transforms a pointer range to a reference range. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\constexpr size\+\_\+t \mbox{\hyperlink{a00322_gaf75511e781bb89056badd33413222010}{find\+\_\+if}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Finds the index of the first element in the tuple satisfying a predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\bool \mbox{\hyperlink{a00322_ga33284bcf99d7d3870e0aff06f6651aa2}{none\+\_\+of}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Checks if none of the elements in the tuple satisfy a given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\bool \mbox{\hyperlink{a00322_gab6d955a70ec9215ae9a8f3841582ab49}{any\+\_\+of}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Checks if any of the elements in the tuple satisfy a given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\auto \mbox{\hyperlink{a00322_gad9f30d486a3d9151d534ec1b0fad5341}{filter}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Filters the elements of a tuple based on a given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Types$>$ }\\constexpr auto \mbox{\hyperlink{a00322_ga12de8f77a63ef488a87a5aa8536146ee}{unique}} (std\+::tuple$<$ Types... $>$ \&\&tuple)
\begin{DoxyCompactList}\small\item\em Creates a tuple with unique types from the given tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\constexpr size\+\_\+t \mbox{\hyperlink{a00322_gae9a7254f583151ee431db537c9980865}{count\+\_\+if}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Counts the number of elements in the tuple satisfying the given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\constexpr int \mbox{\hyperlink{a00322_ga62d8ab565d41e49db75f0641bcdf0740}{find\+Type\+Specialization}} ()
\begin{DoxyCompactList}\small\item\em Finds the index of the first element in the tuple that is a specialization of the given template type. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\auto \mbox{\hyperlink{a00322_ga05a5ccea0f87d41fc69956f55a2c1dbd}{get\+Specialization}} (Tuple \&\&tuple)
\begin{DoxyCompactList}\small\item\em Gets the specialization of the given template type from the tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\constexpr bool \mbox{\hyperlink{a00322_gaec2a5de0482441ef1e1c68fb7ff8a0bc}{has\+Type\+Specialization}} ()
\begin{DoxyCompactList}\small\item\em Checks if a tuple has a specialization of a template type. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\constexpr bool \mbox{\hyperlink{a00322_gadf919f3a9b0c1d50134f9d041a3ce9f7}{count\+Type\+Specialization}} ()
\begin{DoxyCompactList}\small\item\em Counts the occurrences of a specialization of a template type in a tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$int N, class Tuple $>$ }\\constexpr auto \mbox{\hyperlink{a00322_ga32de94604b9d1a7423134f33f49d613f}{make\+Tuple\+Subset}} (Tuple \&\&t)
\begin{DoxyCompactList}\small\item\em Creates a subset tuple with the first N elements from the given tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Tuple , std\+::size\+\_\+t... I$>$ }\\constexpr auto \mbox{\hyperlink{a00322_gaef801f15c9f18ae16e4241a497c33e96}{make\+Tuple\+From\+Tuple\+Indices}} (Tuple \&\&t)
\begin{DoxyCompactList}\small\item\em Creates a new tuple using indices from the original tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Types$>$ }\\auto \mbox{\hyperlink{a00336_a4c617d2458cc6d792f5ba3e6c64a0c7f}{make\+Nested\+Tuple\+Flat}} (std\+::tuple$<$ Types... $>$)
\begin{DoxyCompactList}\small\item\em Creates a flattened nested tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple $>$ }\\auto \mbox{\hyperlink{a00336_a162c64656f5917b717a6b44ebf4c9ebf}{make\+Nested\+Tuple\+Flat\+And\+Store\+References}} (Tuple \&\&tup)
\begin{DoxyCompactList}\small\item\em Creates a flattened nested tuple and stores references. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ \newline
requires traits\+::\+Pointer$<$T$>$}\\auto \& \mbox{\hyperlink{a00336_aa156028e47fc302b02a7e70dea888034}{return\+Reference\+Or\+Nullopt\+If\+Object\+Is\+Null\+Ptr}} (T v)
\begin{DoxyCompactList}\small\item\em Returns a reference or std\+::nullopt if the object is a nullptr. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Fun , typename... Vars, typename... Args, typename U , typename G , typename H $>$ }\\void \mbox{\hyperlink{a00320_ga2a6c26beeb8d52283e82939ca585dc20}{hessianN}} (const Fun \&f, const autodiff\+::\+Wrt$<$ Vars... $>$ \&wrt, const autodiff\+::\+At$<$ Args... $>$ \&at, U \&u, std\+::array$<$ G, U\+::\+Rows\+At\+Compile\+Time $>$ \&g, std\+::array$<$ H, U\+::\+Rows\+At\+Compile\+Time $>$ \&h)
\begin{DoxyCompactList}\small\item\em Computes the Hessian matrix for each parameter of a given function.

The Hessian matrix represents the second-\/order partial derivatives of the function with respect to the specified variables. \end{DoxyCompactList}\item 
std\+::tuple$<$ Dune\+::\+Functions\+::\+Polynomial$<$ double $>$, decltype(Eigen\+::seq(0, 0))$>$ \mbox{\hyperlink{a00320_ga16e7d5f51cc42190c090e727495c1609}{find\+Line\+Segment}} (const Eigen\+::\+Vector\+Xd \&x, const Eigen\+::\+Vector\+Xd \&y, int segment\+Size)
\begin{DoxyCompactList}\small\item\em Find a linear segment in a set of data points. \end{DoxyCompactList}\item 
{\footnotesize template$<$int size, typename LV $>$ }\\void \mbox{\hyperlink{a00320_gac0aa110e209c93e655de9df0915c2fcc}{obtain\+Lagrange\+Node\+Positions}} (const LV \&local\+View, std\+::vector$<$ \mbox{\hyperlink{a01487}{Dune\+::\+Field\+Vector}}$<$ double, size $>$ $>$ \&lagrange\+Node\+Coords)
\begin{DoxyCompactList}\small\item\em A function to obtain the global positions of the nodes of an element with Lagrangian basis, see \mbox{\hyperlink{a00340}{Dune}} book page 314. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Nonlinear\+Operator , typename Update\+Type  = typename Nonlinear\+Operator\+::template Parameter\+Value$<$0$>$$>$ }\\bool \mbox{\hyperlink{a00320_gacb9e813539bfd84df99ad097cabc9de9}{check\+Gradient}} (Nonlinear\+Operator \&non\+Lin\+Op, \mbox{\hyperlink{a01523}{Check\+Flags}} check\+Flags=\mbox{\hyperlink{a01523}{Check\+Flags}}(), std\+::function$<$ void(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&, const Update\+Type \&)$>$ p\+\_\+update\+Function=\mbox{[}$\,$\mbox{]}(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&a, const Update\+Type \&b) \{ a+=b;\})
\begin{DoxyCompactList}\small\item\em Checks the gradient of a nonlinear operator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Nonlinear\+Operator , typename Update\+Type  = typename Nonlinear\+Operator\+::template Parameter\+Value$<$0$>$$>$ }\\bool \mbox{\hyperlink{a00320_ga553465359c199ef676945832587d2869}{check\+Jacobian}} (Nonlinear\+Operator \&non\+Lin\+Op, \mbox{\hyperlink{a01523}{Check\+Flags}} check\+Flags=\mbox{\hyperlink{a01523}{Check\+Flags}}(), std\+::function$<$ void(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&, const Update\+Type \&)$>$ p\+\_\+update\+Function=\mbox{[}$\,$\mbox{]}(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&a, const Update\+Type \&b) \{ a+=b;\})
\begin{DoxyCompactList}\small\item\em Checks the Jacobian of a nonlinear operator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Nonlinear\+Operator , typename Update\+Type  = typename Nonlinear\+Operator\+::template Parameter\+Value$<$0$>$$>$ }\\bool \mbox{\hyperlink{a00320_ga5d1a87964a3d6b6ddc994532e93b6798}{check\+Hessian}} (Nonlinear\+Operator \&non\+Lin\+Op, \mbox{\hyperlink{a01523}{Check\+Flags}} check\+Flags=\mbox{\hyperlink{a01523}{Check\+Flags}}(), std\+::function$<$ void(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&, const Update\+Type \&)$>$ p\+\_\+update\+Function=\mbox{[}$\,$\mbox{]}(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&a, const Update\+Type \&b) \{ a+=b;\})
\begin{DoxyCompactList}\small\item\em Checks the Hessian of a nonlinear operator. \end{DoxyCompactList}\item 
std\+::tuple$<$ Dune\+::\+Functions\+::\+Polynomial$<$ double $>$, double $>$ \mbox{\hyperlink{a00320_ga0d3a38551806e4de3ff44f311847ba51}{polyfit}} (const Eigen\+::\+Ref$<$ const Eigen\+::\+Vector\+Xd $>$ \&x, const Eigen\+::\+Ref$<$ const Eigen\+::\+Vector\+Xd $>$ \&y, int deg)
\begin{DoxyCompactList}\small\item\em Fits a polynomial of a given degree to the given data points. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T , class Tree\+Path , class Power\+Func , class Leaf\+Func $>$ }\\void \mbox{\hyperlink{a00336_a63742d75d099b93da7ddf6e78a3c1f56}{for\+Each\+Leaf\+Or\+Power\+Leaf\+Node}} (T \&\&tree, Tree\+Path \&\&tree\+Path, Power\+Func \&\&power\+Func, Leaf\+Func \&\&leaf\+Func)
\begin{DoxyCompactList}\small\item\em A function which loops over all the nodes of a tree and performs different actions for a power node (with leaf node as child) and a leaf node depending on the corresponding functor passed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\static constexpr bool \mbox{\hyperlink{a00322_ga62ee166e690831f40395df076e9cdddb}{count\+Type\+Specialization\+\_\+v}} = \mbox{\hyperlink{a00322_gadf919f3a9b0c1d50134f9d041a3ce9f7}{count\+Type\+Specialization}}$<$Type, Tuple$>$()
\begin{DoxyCompactList}\small\item\em Variable template for counting the occurrences of a specialization of a template type in a tuple. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{a00336_a63742d75d099b93da7ddf6e78a3c1f56}\label{a00336_a63742d75d099b93da7ddf6e78a3c1f56}} 
\index{Ikarus::utils@{Ikarus::utils}!forEachLeafOrPowerLeafNode@{forEachLeafOrPowerLeafNode}}
\index{forEachLeafOrPowerLeafNode@{forEachLeafOrPowerLeafNode}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{forEachLeafOrPowerLeafNode()}{forEachLeafOrPowerLeafNode()}}
{\footnotesize\ttfamily template$<$class T , class Tree\+Path , class Power\+Func , class Leaf\+Func $>$ \\
void Ikarus\+::utils\+::for\+Each\+Leaf\+Or\+Power\+Leaf\+Node (\begin{DoxyParamCaption}\item[{T \&\&}]{tree,  }\item[{Tree\+Path \&\&}]{tree\+Path,  }\item[{Power\+Func \&\&}]{power\+Func,  }\item[{Leaf\+Func \&\&}]{leaf\+Func }\end{DoxyParamCaption})}

This function is inspired from the function Dune\+::\+Type\+Tree\+::\+Detail\+::for\+Each\+Node available in dune/typetree/traversal.\+hh


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of tree. \\
\hline
{\em Tree\+Path} & Type of the Hybrid\+Tree\+Path. \\
\hline
{\em Power\+Func} & Type of the functor called for a power node. \\
\hline
{\em Leaf\+Func} & Type of the functor called for a leaf node. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tree} & Tree whose nodes are to be looped over. \\
\hline
{\em tree\+Path} & The tree path which handles index values. \\
\hline
{\em power\+Func} & A functor to be called for a power node. \\
\hline
{\em leaf\+Func} & A functor to be called for a leaf node. \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=217pt]{a00336_a63742d75d099b93da7ddf6e78a3c1f56_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00336_a4c617d2458cc6d792f5ba3e6c64a0c7f}\label{a00336_a4c617d2458cc6d792f5ba3e6c64a0c7f}} 
\index{Ikarus::utils@{Ikarus::utils}!makeNestedTupleFlat@{makeNestedTupleFlat}}
\index{makeNestedTupleFlat@{makeNestedTupleFlat}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{makeNestedTupleFlat()}{makeNestedTupleFlat()}}
{\footnotesize\ttfamily template$<$typename... Types$>$ \\
auto Ikarus\+::utils\+::make\+Nested\+Tuple\+Flat (\begin{DoxyParamCaption}\item[{std\+::tuple$<$ Types... $>$}]{ }\end{DoxyParamCaption})}


\begin{DoxyTemplParams}{Template Parameters}
{\em Types} & Types contained in the original tuple. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
A new flattened nested tuple. 
\end{DoxyReturn}
\mbox{\Hypertarget{a00336_a162c64656f5917b717a6b44ebf4c9ebf}\label{a00336_a162c64656f5917b717a6b44ebf4c9ebf}} 
\index{Ikarus::utils@{Ikarus::utils}!makeNestedTupleFlatAndStoreReferences@{makeNestedTupleFlatAndStoreReferences}}
\index{makeNestedTupleFlatAndStoreReferences@{makeNestedTupleFlatAndStoreReferences}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{makeNestedTupleFlatAndStoreReferences()}{makeNestedTupleFlatAndStoreReferences()}}
{\footnotesize\ttfamily template$<$typename Tuple $>$ \\
auto Ikarus\+::utils\+::make\+Nested\+Tuple\+Flat\+And\+Store\+References (\begin{DoxyParamCaption}\item[{Tuple \&\&}]{tup }\end{DoxyParamCaption})}


\begin{DoxyTemplParams}{Template Parameters}
{\em Tuple} & Type of the original tuple. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tup} & The original tuple. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new tuple with stored references.
\end{DoxyReturn}
This function creates a flattened nested tuple and stores references. \mbox{\Hypertarget{a00336_aa156028e47fc302b02a7e70dea888034}\label{a00336_aa156028e47fc302b02a7e70dea888034}} 
\index{Ikarus::utils@{Ikarus::utils}!returnReferenceOrNulloptIfObjectIsNullPtr@{returnReferenceOrNulloptIfObjectIsNullPtr}}
\index{returnReferenceOrNulloptIfObjectIsNullPtr@{returnReferenceOrNulloptIfObjectIsNullPtr}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{returnReferenceOrNulloptIfObjectIsNullPtr()}{returnReferenceOrNulloptIfObjectIsNullPtr()}}
{\footnotesize\ttfamily template$<$typename T $>$ \newline
requires traits\+::\+Pointer$<$T$>$\\
auto \& Ikarus\+::utils\+::return\+Reference\+Or\+Nullopt\+If\+Object\+Is\+Null\+Ptr (\begin{DoxyParamCaption}\item[{T}]{v }\end{DoxyParamCaption})}


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of the pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em v} & Pointer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference or std\+::nullopt. 
\end{DoxyReturn}
