\doxysection{Concepts}
Here is a list of all concepts with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{a02082}{Ikarus\+::\+Concepts\+::\+Adaptive\+Step\+Sizing\+Strategy}} \\*Concept to check if a type implements all the needed functions to be an adaptive step sizing method }{\pageref{a02082}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02086}{Ikarus\+::\+Concepts\+::\+Add\+Able}} \\*Concept defining the requirements for types that support addition }{\pageref{a02086}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02090}{Ikarus\+::\+Concepts\+::\+Add\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place addition }{\pageref{a02090}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02108}{Ikarus\+::\+Concepts\+::\+Autodiff\+Scalar}} \\*Concept to check if the underlying scalar type is a dual type }{\pageref{a02108}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02080}{Ikarus\+::\+Concepts\+::\+Blocked\+Index\+Basis}} \\*Concept to check if a basis uses either Blocked\+Lexicographic or Blocked\+Interleaved indexing strategy }{\pageref{a02080}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02077}{Ikarus\+::\+Concepts\+::\+Blocked\+Inter\+Leaved\+Basis}} \\*Concept to check if a basis uses Blocked\+Interleaved indexing strategy }{\pageref{a02077}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02078}{Ikarus\+::\+Concepts\+::\+Blocked\+Lexicographic\+Basis}} \\*Concept to check if a basis uses Blocked\+Lexicographic indexing strategy }{\pageref{a02078}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02106}{Ikarus\+::\+Concepts\+::\+Data\+Collector}} }{\pageref{a02106}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02068}{Ikarus\+::\+Concepts\+::\+Deviatoric\+Function}} \\*Concept to check if the underlying function is a deviatoric function }{\pageref{a02068}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02092}{Ikarus\+::\+Concepts\+::\+Divide\+Able}} \\*Concept defining the requirements for types that support division }{\pageref{a02092}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02089}{Ikarus\+::\+Concepts\+::\+Divide\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place division }{\pageref{a02089}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02079}{Ikarus\+::\+Concepts\+::\+Dune\+Local\+Basis}} \\*Concept to check if a local basis is a dune\+Local\+Basis }{\pageref{a02079}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02097}{Ikarus\+::\+Concepts\+::\+Eigen\+Matrix}} \\*Concept defining the requirements for \mbox{\hyperlink{a00427}{Eigen}} matrices. This also includes \mbox{\hyperlink{a00427}{Eigen}} vectors }{\pageref{a02097}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02096}{Ikarus\+::\+Concepts\+::\+Eigen\+Vector}} \\*Concept defining the requirements for \mbox{\hyperlink{a00427}{Eigen}} vectors }{\pageref{a02096}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02102}{Ikarus\+::\+Concepts\+::\+Flat\+Assembler}} \\*Concept representing the requirements for a Flat\+Assembler.

A type T satisfies Flat\+Assembler if it provides the necessary member functions and data types for assembling sparse matrices in a flat structure }{\pageref{a02102}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02076}{Ikarus\+::\+Concepts\+::\+Flat\+Index\+Basis}} \\*Concept to check if a basis uses Flat\+Index indexing strategy }{\pageref{a02076}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02072}{Ikarus\+::\+Concepts\+::\+Flat\+Inter\+Leaved\+Basis}} \\*Concept to check if a basis uses Flat\+Interleaved indexing strategy }{\pageref{a02072}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02075}{Ikarus\+::\+Concepts\+::\+Flat\+Lexicographic\+Basis}} \\*Concept to check if a basis uses Flat\+Lexicographic indexing strategy }{\pageref{a02075}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02100}{Ikarus\+::\+Concepts\+::\+Geometrically\+Linear\+Material}} \\*Concepts defining the requirements for a material to be geometrically linear This is the case when the corresponding strain\+Tag is linear }{\pageref{a02100}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02107}{Ikarus\+::\+Concepts\+::\+Grid\+View}} }{\pageref{a02107}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02095}{Ikarus\+::\+Concepts\+::\+Is\+Functor\+With\+Args}} \\*Concept defining the requirements for functors with arguments }{\pageref{a02095}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02098}{Ikarus\+::\+Concepts\+::\+Is\+Material}} \\*Concept defining the requirements for a material type }{\pageref{a02098}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02073}{Ikarus\+::\+Concepts\+::\+Lagrange\+Node}} \\*Concept to check if a node in a basis tree is a Lagrangian node }{\pageref{a02073}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02074}{Ikarus\+::\+Concepts\+::\+Lagrange\+Node\+Of\+Order}} }{\pageref{a02074}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02083}{Ikarus\+::\+Concepts\+::\+Linear\+Solver\+Check}} \\*Concept to check if a linear solver implements all the needed functions for given vector and matrix types }{\pageref{a02083}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02105}{Ikarus\+::\+Concepts\+::\+Matrix\+Flat\+Assembler}} \\*Concept representing the requirements for a Matrix\+Flat\+Assembler.

A type T satisfies Matrix\+Flat\+Assembler if it is a Vector\+Flat\+Assembler and if it provides the necessary matrix() member functions }{\pageref{a02105}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02085}{Ikarus\+::\+Concepts\+::\+Multiply\+Able}} \\*Concept defining the requirements for types that support multiplication }{\pageref{a02085}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02088}{Ikarus\+::\+Concepts\+::\+Multiply\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place multiplication }{\pageref{a02088}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02093}{Ikarus\+::\+Concepts\+::\+Negate\+Able}} \\*Concept defining the requirements for types that support negation }{\pageref{a02093}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02084}{Ikarus\+::\+Concepts\+::\+Non\+Linear\+Solver\+Check\+For\+Path\+Following}} \\*Concept to check if a non-\/linear solver with its non-\/linear operator satisfies requirements for path following }{\pageref{a02084}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02081}{Ikarus\+::\+Concepts\+::\+Path\+Following\+Strategy}} \\*Concept defining the requirements for a path-\/following strategy }{\pageref{a02081}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02101}{Ikarus\+::\+Concepts\+::\+Result\+Type}} \\*A concept to check if a template type satisfies the Result\+Type requirements }{\pageref{a02101}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02103}{Ikarus\+::\+Concepts\+::\+Scalar\+Flat\+Assembler}} \\*Concept representing the requirements for a Scalar\+Flat\+Assembler.

A type T satisfies Scalar\+Flat\+Assembler if it is a Flat\+Assembler and if it provides the necessary scalar() member functions }{\pageref{a02103}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02087}{Ikarus\+::\+Concepts\+::\+Substract\+Able}} \\*Concept defining the requirements for types that support subtraction }{\pageref{a02087}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02091}{Ikarus\+::\+Concepts\+::\+Substract\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place subtraction }{\pageref{a02091}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02094}{Ikarus\+::\+Concepts\+::\+Transpose\+Able}} \\*Concept defining the requirements for types that support transposition }{\pageref{a02094}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02104}{Ikarus\+::\+Concepts\+::\+Vector\+Flat\+Assembler}} \\*Concept representing the requirements for a Vector\+Flat\+Assembler.

A type T satisfies Vector\+Flat\+Assembler if it is a Scalar\+Flat\+Assembler and if it provides the necessary vector() member functions }{\pageref{a02104}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02069}{Ikarus\+::\+Concepts\+::\+Volumetric\+Function}} \\*Concept to check if the underlying function is a volumetric function }{\pageref{a02069}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02067}{Ikarus\+::\+FEAffordance}} \\*Concept to check if a given type is one of the predefined affordance enums or the Affordance\+Collection }{\pageref{a02067}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02070}{Ikarus\+::\+Materials\+::\+Correct\+Strain\+Size}} \\*Template concept for ensuring correct strain size }{\pageref{a02070}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02071}{Ikarus\+::\+MPTuple}} \\*Concept for checking if a type is a valid material parameter tuple }{\pageref{a02071}}{}
\item\contentsline{section}{\mbox{\hyperlink{a02109}{Ikarus\+::traits\+::\+Pointer}} \\*Concept to check if a type is a pointer or nullptr\+\_\+t }{\pageref{a02109}}{}
\end{DoxyCompactList}
