\hypertarget{a00047}{}\doxysection{concepts.\+hh File Reference}
\label{a00047}\index{concepts.hh@{concepts.hh}}


Several concepts.  


{\ttfamily \#include $<$concepts$>$}\newline
{\ttfamily \#include $<$type\+\_\+traits$>$}\newline
{\ttfamily \#include $<$utility$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include $<$dune/functions/functionspacebases/basistags.\+hh$>$}\newline
{\ttfamily \#include $<$dune/functions/functionspacebases/lagrangebasis.\+hh$>$}\newline
{\ttfamily \#include $<$Eigen/\+Dense$>$}\newline
{\ttfamily \#include $<$Eigen/\+Sparse$>$}\newline
{\ttfamily \#include $<$autodiff/forward/dual/dual.\+hpp$>$}\newline
{\ttfamily \#include \char`\"{}ikarus/assembler/dirichletbcenforcement.\+hh\char`\"{}}\newline
{\ttfamily \#include \char`\"{}ikarus/finiteelements/mechanics/materials/tags.\+hh\char`\"{}}\newline
{\ttfamily \#include $<$ikarus/utils/traits.\+hh$>$}\newline
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{a00396}{Eigen}}
\item 
namespace \mbox{\hyperlink{a00384}{Ikarus}}
\item 
namespace \mbox{\hyperlink{a00402}{Ikarus\+::\+Concepts}}
\end{DoxyCompactItemize}
\doxysubsection*{Concepts}
\begin{DoxyCompactItemize}
\item 
concept \mbox{\hyperlink{a01944}{Ikarus\+::\+Concepts\+::\+Flat\+Inter\+Leaved\+Basis}}
\begin{DoxyCompactList}\small\item\em Concept to check if a basis uses Flat\+Interleaved indexing strategy. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01945}{Ikarus\+::\+Concepts\+::\+Lagrange\+Node}}
\begin{DoxyCompactList}\small\item\em Concept to check if a node in a basis tree is a Lagrangian node. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01946}{Ikarus\+::\+Concepts\+::\+Lagrange\+Node\+Of\+Order}}
\item 
concept \mbox{\hyperlink{a01947}{Ikarus\+::\+Concepts\+::\+Flat\+Lexicographic\+Basis}}
\begin{DoxyCompactList}\small\item\em Concept to check if a basis uses Flat\+Lexicographic indexing strategy. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01948}{Ikarus\+::\+Concepts\+::\+Flat\+Index\+Basis}}
\begin{DoxyCompactList}\small\item\em Concept to check if a basis uses Flat\+Index indexing strategy. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01949}{Ikarus\+::\+Concepts\+::\+Blocked\+Inter\+Leaved\+Basis}}
\begin{DoxyCompactList}\small\item\em Concept to check if a basis uses Blocked\+Interleaved indexing strategy. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01950}{Ikarus\+::\+Concepts\+::\+Blocked\+Lexicographic\+Basis}}
\begin{DoxyCompactList}\small\item\em Concept to check if a basis uses Blocked\+Lexicographic indexing strategy. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01951}{Ikarus\+::\+Concepts\+::\+Dune\+Local\+Basis}}
\begin{DoxyCompactList}\small\item\em Concept to check if a local basis is a dune\+Local\+Basis. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01952}{Ikarus\+::\+Concepts\+::\+Blocked\+Index\+Basis}}
\begin{DoxyCompactList}\small\item\em Concept to check if a basis uses either Blocked\+Lexicographic or Blocked\+Interleaved indexing strategy. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01953}{Ikarus\+::\+Concepts\+::\+Path\+Following\+Strategy}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for a path-\/following strategy. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01954}{Ikarus\+::\+Concepts\+::\+Adaptive\+Step\+Sizing\+Strategy}}
\begin{DoxyCompactList}\small\item\em Concept to check if a type implements all the needed functions to be an adaptive step sizing method. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01955}{Ikarus\+::\+Concepts\+::\+Linear\+Solver\+Check}}
\begin{DoxyCompactList}\small\item\em Concept to check if a linear solver implements all the needed functions for given vector and matrix types. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01956}{Ikarus\+::\+Concepts\+::\+Non\+Linear\+Solver\+Check\+For\+Path\+Following}}
\begin{DoxyCompactList}\small\item\em Concept to check if a non-\/linear solver with its non-\/linear operator satisfies requirements for path following. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01957}{Ikarus\+::\+Concepts\+::\+Multiply\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support multiplication. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01958}{Ikarus\+::\+Concepts\+::\+Add\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support addition. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01959}{Ikarus\+::\+Concepts\+::\+Substract\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support subtraction. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01960}{Ikarus\+::\+Concepts\+::\+Multiply\+Assign\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support in-\/place multiplication. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01961}{Ikarus\+::\+Concepts\+::\+Divide\+Assign\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support in-\/place division. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01962}{Ikarus\+::\+Concepts\+::\+Add\+Assign\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support in-\/place addition. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01963}{Ikarus\+::\+Concepts\+::\+Substract\+Assign\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support in-\/place subtraction. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01964}{Ikarus\+::\+Concepts\+::\+Divide\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support division. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01965}{Ikarus\+::\+Concepts\+::\+Negate\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support negation. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01966}{Ikarus\+::\+Concepts\+::\+Transpose\+Able}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for types that support transposition. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01967}{Ikarus\+::\+Concepts\+::\+Is\+Functor\+With\+Args}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for functors with arguments. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01968}{Ikarus\+::\+Concepts\+::\+Eigen\+Vector}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for \mbox{\hyperlink{a00396}{Eigen}} vectors. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01969}{Ikarus\+::\+Concepts\+::\+Eigen\+Matrix}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for \mbox{\hyperlink{a00396}{Eigen}} matrices. This also includes \mbox{\hyperlink{a00396}{Eigen}} vectors. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01970}{Ikarus\+::\+Concepts\+::\+Is\+Material}}
\begin{DoxyCompactList}\small\item\em Concept defining the requirements for a material type. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01972}{Ikarus\+::\+Concepts\+::\+Geometrically\+Linear\+Material}}
\begin{DoxyCompactList}\small\item\em Concepts defining the requirements for a material to be geometrically linear This is the case when the corresponding strain\+Tag is linear. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01973}{Ikarus\+::\+Concepts\+::\+Result\+Type}}
\begin{DoxyCompactList}\small\item\em A concept to check if a template type satisfies the Result\+Type requirements. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01974}{Ikarus\+::\+Concepts\+::\+Flat\+Assembler}}
\begin{DoxyCompactList}\small\item\em Concept representing the requirements for a Flat\+Assembler.

A type T satisfies Flat\+Assembler if it provides the necessary member functions and data types for assembling sparse matrices in a flat structure. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01975}{Ikarus\+::\+Concepts\+::\+Scalar\+Flat\+Assembler}}
\begin{DoxyCompactList}\small\item\em Concept representing the requirements for a Scalar\+Flat\+Assembler.

A type T satisfies Scalar\+Flat\+Assembler if it is a Flat\+Assembler and if it provides the necessary scalar() member functions. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01976}{Ikarus\+::\+Concepts\+::\+Vector\+Flat\+Assembler}}
\begin{DoxyCompactList}\small\item\em Concept representing the requirements for a Vector\+Flat\+Assembler.

A type T satisfies Vector\+Flat\+Assembler if it is a Scalar\+Flat\+Assembler and if it provides the necessary vector() member functions. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01977}{Ikarus\+::\+Concepts\+::\+Matrix\+Flat\+Assembler}}
\begin{DoxyCompactList}\small\item\em Concept representing the requirements for a Matrix\+Flat\+Assembler.

A type T satisfies Matrix\+Flat\+Assembler if it is a Vector\+Flat\+Assembler and if it provides the necessary matrix() member functions. \end{DoxyCompactList}\item 
concept \mbox{\hyperlink{a01978}{Ikarus\+::\+Concepts\+::\+Data\+Collector}}
\item 
concept \mbox{\hyperlink{a01979}{Ikarus\+::\+Concepts\+::\+Grid\+View}}
\item 
concept \mbox{\hyperlink{a01980}{Ikarus\+::\+Concepts\+::\+Autodiff\+Scalar}}
\begin{DoxyCompactList}\small\item\em Concept to check if the underlying scalar type is a dual type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{a00047_ac8757039febcebb4741b376dc8258d6d}{MAKE\+\_\+\+EIGEN\+\_\+\+FIXED\+\_\+\+VECTOR\+\_\+\+CONCEPT}}(Size)
\item 
\#define \mbox{\hyperlink{a00047_a5556bdb5e6cc63333c07f9ef487fb478}{MAKE\+\_\+\+EIGEN\+\_\+\+FIXED\+\_\+\+MATRIX\+\_\+\+CONCEPT}}(Size1,  Size2)
\item 
\#define \mbox{\hyperlink{a00047_aba360f830591dbc713b7fa692d614101}{MAKE\+\_\+\+EIGEN\+\_\+\+FIXED\+\_\+\+MATRIX\+\_\+\+OR\+\_\+\+VOIGT\+\_\+\+CONCEPT}}(Size1,  Size2)
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Derived $>$ }\\auto \mbox{\hyperlink{a00384_ac2c6469be19ce4ef2e630bfa1c5a5e24}{Ikarus\+::transpose}} (const \mbox{\hyperlink{a01748}{Eigen\+::\+Eigen\+Base}}$<$ Derived $>$ \&A)
\end{DoxyCompactItemize}


\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{a00047_a5556bdb5e6cc63333c07f9ef487fb478}\label{a00047_a5556bdb5e6cc63333c07f9ef487fb478}} 
\index{concepts.hh@{concepts.hh}!MAKE\_EIGEN\_FIXED\_MATRIX\_CONCEPT@{MAKE\_EIGEN\_FIXED\_MATRIX\_CONCEPT}}
\index{MAKE\_EIGEN\_FIXED\_MATRIX\_CONCEPT@{MAKE\_EIGEN\_FIXED\_MATRIX\_CONCEPT}!concepts.hh@{concepts.hh}}
\doxysubsubsection{\texorpdfstring{MAKE\_EIGEN\_FIXED\_MATRIX\_CONCEPT}{MAKE\_EIGEN\_FIXED\_MATRIX\_CONCEPT}}
{\footnotesize\ttfamily \#define MAKE\+\_\+\+EIGEN\+\_\+\+FIXED\+\_\+\+MATRIX\+\_\+\+CONCEPT(\begin{DoxyParamCaption}\item[{}]{Size1,  }\item[{}]{Size2 }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{  \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>                                                                                         \(\backslash\)}
\DoxyCodeLine{  concept EigenMatrix\#\#Size1\#\#Size2 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(std::remove\_cvref\_t<M>::RowsAtCompileTime == Size1) and \(\backslash\)}
\DoxyCodeLine{                                      \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(std::remove\_cvref\_t<M>::ColsAtCompileTime == Size2);}

\end{DoxyCode}
\mbox{\Hypertarget{a00047_aba360f830591dbc713b7fa692d614101}\label{a00047_aba360f830591dbc713b7fa692d614101}} 
\index{concepts.hh@{concepts.hh}!MAKE\_EIGEN\_FIXED\_MATRIX\_OR\_VOIGT\_CONCEPT@{MAKE\_EIGEN\_FIXED\_MATRIX\_OR\_VOIGT\_CONCEPT}}
\index{MAKE\_EIGEN\_FIXED\_MATRIX\_OR\_VOIGT\_CONCEPT@{MAKE\_EIGEN\_FIXED\_MATRIX\_OR\_VOIGT\_CONCEPT}!concepts.hh@{concepts.hh}}
\doxysubsubsection{\texorpdfstring{MAKE\_EIGEN\_FIXED\_MATRIX\_OR\_VOIGT\_CONCEPT}{MAKE\_EIGEN\_FIXED\_MATRIX\_OR\_VOIGT\_CONCEPT}}
{\footnotesize\ttfamily \#define MAKE\+\_\+\+EIGEN\+\_\+\+FIXED\+\_\+\+MATRIX\+\_\+\+OR\+\_\+\+VOIGT\+\_\+\+CONCEPT(\begin{DoxyParamCaption}\item[{}]{Size1,  }\item[{}]{Size2 }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{  \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>                                        \(\backslash\)}
\DoxyCodeLine{  concept EigenMatrixOrVoigtNotation\#\#Size1 = EigenMatrix\#\#Size1\#\#Size1<M> or EigenVector\#\#Size2<M>;}

\end{DoxyCode}
\mbox{\Hypertarget{a00047_ac8757039febcebb4741b376dc8258d6d}\label{a00047_ac8757039febcebb4741b376dc8258d6d}} 
\index{concepts.hh@{concepts.hh}!MAKE\_EIGEN\_FIXED\_VECTOR\_CONCEPT@{MAKE\_EIGEN\_FIXED\_VECTOR\_CONCEPT}}
\index{MAKE\_EIGEN\_FIXED\_VECTOR\_CONCEPT@{MAKE\_EIGEN\_FIXED\_VECTOR\_CONCEPT}!concepts.hh@{concepts.hh}}
\doxysubsubsection{\texorpdfstring{MAKE\_EIGEN\_FIXED\_VECTOR\_CONCEPT}{MAKE\_EIGEN\_FIXED\_VECTOR\_CONCEPT}}
{\footnotesize\ttfamily \#define MAKE\+\_\+\+EIGEN\+\_\+\+FIXED\+\_\+\+VECTOR\+\_\+\+CONCEPT(\begin{DoxyParamCaption}\item[{}]{Size }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{  \textcolor{keyword}{template} <\textcolor{keyword}{typename} V>                       \(\backslash\)}
\DoxyCodeLine{  concept EigenVector\#\#Size =                 \(\backslash\)}
\DoxyCodeLine{      static\_cast<bool>(V::IsVectorAtCompileTime) and \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(V::SizeAtCompileTime == Size);}

\end{DoxyCode}
