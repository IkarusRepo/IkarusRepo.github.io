<!--
SPDX-FileCopyrightText: 2021-2025 The Ikarus Developers mueller@ibb.uni-stuttgart.de
SPDX-License-Identifier: LGPL-3.0-or-later
-->
<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.4"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="Ikarus documentation" />
    <meta property="og:image" content="https://github.com/ikarus-project/ikarus/blob/e7b4aafc04e24f41c5aa6ee0f18e105d1aebefcc/docs/website/auxiliaryImages/BigLogo.png" />
    <meta property="og:description" content="Code documentation of the open-source C++ finite element library Ikarus." />
    <meta property="og:url" content="https://github.com/ikarus-project/ikarus/main/" />
    <!-- END opengraph metadata -->
<!--    &lt;!&ndash; BEGIN twitter metadata &ndash;&gt;-->
<!--    <meta name="twitter:image:src" content="https://git.iws.uni-stuttgart.de/dumux-repositories/dumux/-/raw/8affa5aac19a76f615e74918332484e1c603c43e/doc/logo/dumux_logo_small.png" />-->
<!--    <meta name="twitter:title" content="Dumux documentation" />-->
<!--    <meta name="twitter:description" content="Code documentation of the open-source C++ porous media simulator Dumux." />-->
<!--    &lt;!&ndash; END twitter metadata &ndash;&gt;-->
<!--    &lt;!&ndash; BEGIN Google+ metadata&ndash;&gt;-->
<!--    <meta itemprop="name" content="Dumux documentation" />-->
<!--    <meta itemprop="description" content="Code documentation of the open-source C++ porous media simulator Dumux." />-->
<!--    <meta itemprop="image" content="https://git.iws.uni-stuttgart.de/dumux-repositories/dumux/-/raw/8affa5aac19a76f615e74918332484e1c603c43e/doc/logo/dumux_logo_small.png" />-->
<!--    &lt;!&ndash; END Google+ metadata &ndash;&gt;-->
    <title>ikarus: Utilities</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.init()
    </script>
    <script type="text/javascript" src="ikarus-custom.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/require']
  },
  tex: {
    macros: {    tr: "{\\mathrm{tr}\\,}",
    BC: "{\\mathbf{C}}",
    BS: "{\\mathbf{S}}",
    BE: "{\\mathbf{E}}",
    BI: "{\\mathbf{I}}",
    BBC: "{\\mathbb{C}}",
    CI: "{\\mathcal{I}}",
    de: "{\\delta}",
    Bvep: "{\\boldsymbol\\varepsilon}",
    fracpt: ["{\\frac{\\partial #1}{\\partial #2}}",2],
    },
    packages: ['base','configmacros','newcommand','require']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ikarus-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/-->
<a href="https://github.com/ikarus-project/ikarus" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!--MERMAID GRAPHS-->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<!--MERMAID GRAPHS-->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectlogo"><a href="index.html"><img alt="Logo" src="BigLogo_transparent.png" width="150px"/></a></td>
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">
                        &#160;<span id="projectnumber">version 0.4.1</span>
                    </div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a00379.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Utilities<div class="ingroups"><a class="el" href="a00365.html">Ikarus Modules</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Collection of several utilities.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Utilities:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379.svg" width="252" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01744.html">Ikarus::BasisHandler&lt; PB &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for a hierarchical basis constructed from a pre-basis.  <a href="a01744.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01800.html">Ikarus::DirichletValues&lt; B, FC &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling Dirichlet boundary conditions in <a class="el" href="a00384.html">Ikarus</a>.  <a href="a01800.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01808.html">Ikarus::FlatPreBasis&lt; PreBasis &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a PreBasis into one with flat index-merging strategyThis utility takes a pre-basis and converts recursively all index-merging strategies into their flat analog, i.e. <code>BlockedInterleaved</code> is converted into <code>FlatInterleaved</code> and <code>BlockedLexicographic</code> is transformed into <code>FlatLexicographic</code>.  <a href="a01808.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01848.html">Ikarus::NonLinearOperator&lt; TypeListOne, TypeListTwo &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a <a class="el" href="a01848.html" title="Represents a NonLinearOperator class for handling nonlinear operators.">NonLinearOperator</a> class for handling nonlinear operators.  <a href="a01848.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01776.html">Ikarus::utils::SolverDefault</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for solving operations.  <a href="a01776.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01780.html">Ikarus::utils::UpdateDefault</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for updating operations.  <a href="a01780.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga14ad7d33267cea1c93f97f3998081657"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00379.html#ga14ad7d33267cea1c93f97f3998081657">MAKE_ENUM</a>(type, ...)</td></tr>
<tr class="memdesc:ga14ad7d33267cea1c93f97f3998081657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create an enumeration with a string conversion function.The macro creates an enum class with a BEGIN and END enumerator, and provides a constexpr toString function for string conversion.  <a href="a00379.html#ga14ad7d33267cea1c93f97f3998081657">More...</a><br /></td></tr>
<tr class="separator:ga14ad7d33267cea1c93f97f3998081657"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2a6c26beeb8d52283e82939ca585dc20"><td class="memTemplParams" colspan="2">template&lt;typename Fun , typename... Vars, typename... Args, typename U , typename G , typename H &gt; </td></tr>
<tr class="memitem:ga2a6c26beeb8d52283e82939ca585dc20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga2a6c26beeb8d52283e82939ca585dc20">Ikarus::utils::hessianN</a> (const Fun &amp;f, const autodiff::Wrt&lt; Vars... &gt; &amp;wrt, const autodiff::At&lt; Args... &gt; &amp;at, U &amp;u, std::array&lt; G, U::RowsAtCompileTime &gt; &amp;g, std::array&lt; H, U::RowsAtCompileTime &gt; &amp;h)</td></tr>
<tr class="memdesc:ga2a6c26beeb8d52283e82939ca585dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Hessian matrix for each parameter of a given function.The Hessian matrix represents the second-order partial derivatives of the function with respect to the specified variables.  <a href="a00379.html#ga2a6c26beeb8d52283e82939ca585dc20">More...</a><br /></td></tr>
<tr class="separator:ga2a6c26beeb8d52283e82939ca585dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e7d5f51cc42190c090e727495c1609"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, decltype(Eigen::seq(0, 0))&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00379.html#ga16e7d5f51cc42190c090e727495c1609">Ikarus::utils::findLineSegment</a> (const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;y, int segmentSize)</td></tr>
<tr class="memdesc:ga16e7d5f51cc42190c090e727495c1609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a linear segment in a set of data points.  <a href="a00379.html#ga16e7d5f51cc42190c090e727495c1609">More...</a><br /></td></tr>
<tr class="separator:ga16e7d5f51cc42190c090e727495c1609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0728039472747184e9eb2ec0992a4a2b"><td class="memTemplParams" colspan="2">template&lt;class PreBasis &gt; </td></tr>
<tr class="memitem:ga0728039472747184e9eb2ec0992a4a2b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga0728039472747184e9eb2ec0992a4a2b">Ikarus::flatPreBasis</a> (const PreBasis &amp;preBasis)</td></tr>
<tr class="memdesc:ga0728039472747184e9eb2ec0992a4a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator function for a flatted PreBasis.  <a href="a00379.html#ga0728039472747184e9eb2ec0992a4a2b">More...</a><br /></td></tr>
<tr class="separator:ga0728039472747184e9eb2ec0992a4a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9098182120929a0d21cff1c38f5ca84"><td class="memTemplParams" colspan="2">template&lt;int size, typename LV &gt; </td></tr>
<tr class="memitem:gae9098182120929a0d21cff1c38f5ca84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gae9098182120929a0d21cff1c38f5ca84">Ikarus::utils::obtainLagrangeGlobalNodePositions</a> (const LV &amp;localView, std::vector&lt; <a class="el" href="a01784.html">Dune::FieldVector</a>&lt; double, size &gt; &gt; &amp;lagrangeNodeGlobalCoords)</td></tr>
<tr class="memdesc:gae9098182120929a0d21cff1c38f5ca84"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to obtain the global positions of the nodes of an element with Lagrangian basis.  <a href="a00379.html#gae9098182120929a0d21cff1c38f5ca84">More...</a><br /></td></tr>
<tr class="separator:gae9098182120929a0d21cff1c38f5ca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa19ed04a701aaa500f7c486addae2d2e"><td class="memTemplParams" colspan="2">template&lt;int size, typename Basis &gt; </td></tr>
<tr class="memitem:gaa19ed04a701aaa500f7c486addae2d2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gaa19ed04a701aaa500f7c486addae2d2e">Ikarus::utils::globalIndexFromGlobalPosition</a> (const Basis &amp;basis, const <a class="el" href="a01784.html">Dune::FieldVector</a>&lt; double, size &gt; &amp;pos)</td></tr>
<tr class="memdesc:gaa19ed04a701aaa500f7c486addae2d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to obtain the global index from the global positions for a Lagrange node.  <a href="a00379.html#gaa19ed04a701aaa500f7c486addae2d2e">More...</a><br /></td></tr>
<tr class="separator:gaa19ed04a701aaa500f7c486addae2d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30df35336d19b00bc5db2a0b52ce650e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="a01336.html">FE</a> &gt; </td></tr>
<tr class="memitem:ga30df35336d19b00bc5db2a0b52ce650e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga30df35336d19b00bc5db2a0b52ce650e">Ikarus::utils::referenceElementSubEntityPositions</a> (<a class="el" href="a01336.html">FE</a> &amp;fe, int codim)</td></tr>
<tr class="memdesc:ga30df35336d19b00bc5db2a0b52ce650e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to obtain the local coordinates of subentities of an FiniteElement.  <a href="a00379.html#ga30df35336d19b00bc5db2a0b52ce650e">More...</a><br /></td></tr>
<tr class="separator:ga30df35336d19b00bc5db2a0b52ce650e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c05dce8a66fc4efbe31674b87d18298"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="a01336.html">FE</a> &gt; </td></tr>
<tr class="memitem:ga8c05dce8a66fc4efbe31674b87d18298"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga8c05dce8a66fc4efbe31674b87d18298">Ikarus::utils::referenceElementVertexPositions</a> (<a class="el" href="a01336.html">FE</a> &amp;fe)</td></tr>
<tr class="memdesc:ga8c05dce8a66fc4efbe31674b87d18298"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to obtain the local coordinates the vertices of an FiniteElement.  <a href="a00379.html#ga8c05dce8a66fc4efbe31674b87d18298">More...</a><br /></td></tr>
<tr class="separator:ga8c05dce8a66fc4efbe31674b87d18298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9e813539bfd84df99ad097cabc9de9"><td class="memTemplParams" colspan="2">template&lt;typename NonlinearOperator , typename UpdateType  = typename NonlinearOperator::template ParameterValue&lt;0&gt;&gt; </td></tr>
<tr class="memitem:gacb9e813539bfd84df99ad097cabc9de9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gacb9e813539bfd84df99ad097cabc9de9">Ikarus::utils::checkGradient</a> (NonlinearOperator &amp;nonLinOp, <a class="el" href="a01832.html">CheckFlags</a> checkFlags=<a class="el" href="a01832.html">CheckFlags</a>(), std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt; p_updateFunction=[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;})</td></tr>
<tr class="memdesc:gacb9e813539bfd84df99ad097cabc9de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the gradient of a nonlinear operator.  <a href="a00379.html#gacb9e813539bfd84df99ad097cabc9de9">More...</a><br /></td></tr>
<tr class="separator:gacb9e813539bfd84df99ad097cabc9de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553465359c199ef676945832587d2869"><td class="memTemplParams" colspan="2">template&lt;typename NonlinearOperator , typename UpdateType  = typename NonlinearOperator::template ParameterValue&lt;0&gt;&gt; </td></tr>
<tr class="memitem:ga553465359c199ef676945832587d2869"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga553465359c199ef676945832587d2869">Ikarus::utils::checkJacobian</a> (NonlinearOperator &amp;nonLinOp, <a class="el" href="a01832.html">CheckFlags</a> checkFlags=<a class="el" href="a01832.html">CheckFlags</a>(), std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt; p_updateFunction=[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;})</td></tr>
<tr class="memdesc:ga553465359c199ef676945832587d2869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the Jacobian of a nonlinear operator.  <a href="a00379.html#ga553465359c199ef676945832587d2869">More...</a><br /></td></tr>
<tr class="separator:ga553465359c199ef676945832587d2869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1a87964a3d6b6ddc994532e93b6798"><td class="memTemplParams" colspan="2">template&lt;typename NonlinearOperator , typename UpdateType  = typename NonlinearOperator::template ParameterValue&lt;0&gt;&gt; </td></tr>
<tr class="memitem:ga5d1a87964a3d6b6ddc994532e93b6798"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga5d1a87964a3d6b6ddc994532e93b6798">Ikarus::utils::checkHessian</a> (NonlinearOperator &amp;nonLinOp, <a class="el" href="a01832.html">CheckFlags</a> checkFlags=<a class="el" href="a01832.html">CheckFlags</a>(), std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt; p_updateFunction=[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;})</td></tr>
<tr class="memdesc:ga5d1a87964a3d6b6ddc994532e93b6798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the Hessian of a nonlinear operator.  <a href="a00379.html#ga5d1a87964a3d6b6ddc994532e93b6798">More...</a><br /></td></tr>
<tr class="separator:ga5d1a87964a3d6b6ddc994532e93b6798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa33adfa2e95d7040a816bb2da81d275d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:gaa33adfa2e95d7040a816bb2da81d275d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gaa33adfa2e95d7040a816bb2da81d275d">Ikarus::orthonormalizeMatrixColumns</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:gaa33adfa2e95d7040a816bb2da81d275d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthonormalizes all Matrix columns using Gram-Schmidt Orthogonalization.  <a href="a00379.html#gaa33adfa2e95d7040a816bb2da81d275d">More...</a><br /></td></tr>
<tr class="separator:gaa33adfa2e95d7040a816bb2da81d275d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545d74839895f4576a3b8c97d72abefd"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga545d74839895f4576a3b8c97d72abefd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga545d74839895f4576a3b8c97d72abefd">Ikarus::viewAsFlatEigenVector</a> (Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</td></tr>
<tr class="memdesc:ga545d74839895f4576a3b8c97d72abefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">View Dune::BlockVector as an Eigen::Vector.  <a href="a00379.html#ga545d74839895f4576a3b8c97d72abefd">More...</a><br /></td></tr>
<tr class="separator:ga545d74839895f4576a3b8c97d72abefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3beeb26c911116fa02df8756214484aa"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga3beeb26c911116fa02df8756214484aa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga3beeb26c911116fa02df8756214484aa">Ikarus::viewAsFlatEigenVector</a> (const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</td></tr>
<tr class="memdesc:ga3beeb26c911116fa02df8756214484aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">View const Dune::BlockVector as an Eigen::Vector.  <a href="a00379.html#ga3beeb26c911116fa02df8756214484aa">More...</a><br /></td></tr>
<tr class="separator:ga3beeb26c911116fa02df8756214484aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9d7cf401f9f03ce1aae728c646ce178"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:gaf9d7cf401f9f03ce1aae728c646ce178"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gaf9d7cf401f9f03ce1aae728c646ce178">Ikarus::viewAsEigenMatrixAsDynFixed</a> (Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</td></tr>
<tr class="memdesc:gaf9d7cf401f9f03ce1aae728c646ce178"><td class="mdescLeft">&#160;</td><td class="mdescRight">View Dune::BlockVector as an Eigen::Matrix with dynamic rows and fixed columns depending on the size of the ValueType.  <a href="a00379.html#gaf9d7cf401f9f03ce1aae728c646ce178">More...</a><br /></td></tr>
<tr class="separator:gaf9d7cf401f9f03ce1aae728c646ce178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c6bdf14e40ee46e881f646e1c28b0d"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:gaf1c6bdf14e40ee46e881f646e1c28b0d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gaf1c6bdf14e40ee46e881f646e1c28b0d">Ikarus::viewAsEigenMatrixAsDynFixed</a> (const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</td></tr>
<tr class="memdesc:gaf1c6bdf14e40ee46e881f646e1c28b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const view Dune::BlockVector as an Eigen::Matrix with dynamic rows and fixed columns depending on the size of the ValueType.  <a href="a00379.html#gaf1c6bdf14e40ee46e881f646e1c28b0d">More...</a><br /></td></tr>
<tr class="separator:gaf1c6bdf14e40ee46e881f646e1c28b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac25618d0e7c4aece653662d2541b61ec"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:gac25618d0e7c4aece653662d2541b61ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gac25618d0e7c4aece653662d2541b61ec">Ikarus::viewAsEigenMatrixFixedDyn</a> (Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</td></tr>
<tr class="memdesc:gac25618d0e7c4aece653662d2541b61ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">View Dune::BlockVector as an Eigen::Matrix with fixed rows depending on the size of the ValueType and dynamic columns.  <a href="a00379.html#gac25618d0e7c4aece653662d2541b61ec">More...</a><br /></td></tr>
<tr class="separator:gac25618d0e7c4aece653662d2541b61ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146a052f6eb97304a8172c7b65fe70fb"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga146a052f6eb97304a8172c7b65fe70fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga146a052f6eb97304a8172c7b65fe70fb">Ikarus::viewAsEigenMatrixFixedDyn</a> (const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</td></tr>
<tr class="memdesc:ga146a052f6eb97304a8172c7b65fe70fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const view Dune::BlockVector as an Eigen::Matrix with fixed rows depending on the size of the ValueType and dynamic columns.  <a href="a00379.html#ga146a052f6eb97304a8172c7b65fe70fb">More...</a><br /></td></tr>
<tr class="separator:ga146a052f6eb97304a8172c7b65fe70fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609664964681787f2f736f772b82a01e"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; <br />
requires requires { Type::correctionSize; }</td></tr>
<tr class="memitem:ga609664964681787f2f736f772b82a01e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga609664964681787f2f736f772b82a01e">Ikarus::correctionSize</a> (const Dune::BlockVector&lt; Type &gt; &amp;a)</td></tr>
<tr class="memdesc:ga609664964681787f2f736f772b82a01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total correction size of a block vector with a Manifold as the underlying type.  <a href="a00379.html#ga609664964681787f2f736f772b82a01e">More...</a><br /></td></tr>
<tr class="separator:ga609664964681787f2f736f772b82a01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1df27a0dfa864327029cdb906a1840c"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; <br />
requires requires { Type::valueSize; }</td></tr>
<tr class="memitem:gac1df27a0dfa864327029cdb906a1840c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gac1df27a0dfa864327029cdb906a1840c">Ikarus::valueSize</a> (const Dune::BlockVector&lt; Type &gt; &amp;a)</td></tr>
<tr class="memdesc:gac1df27a0dfa864327029cdb906a1840c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total value size of a block vector with a Manifold as the underlying type.  <a href="a00379.html#gac1df27a0dfa864327029cdb906a1840c">More...</a><br /></td></tr>
<tr class="separator:gac1df27a0dfa864327029cdb906a1840c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09cedf6a65b142340c1934c987ed064c"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Derived &gt; <br />
requires (<a class="el" href="a01962.html">Ikarus::Concepts::AddAssignAble</a>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })</td></tr>
<tr class="memitem:ga09cedf6a65b142340c1934c987ed064c"><td class="memTemplItemLeft" align="right" valign="top">Dune::BlockVector&lt; Type &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga09cedf6a65b142340c1934c987ed064c">Ikarus::operator+=</a> (Dune::BlockVector&lt; Type &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</td></tr>
<tr class="memdesc:ga09cedf6a65b142340c1934c987ed064c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the += operator for Dune::BlockVector += Eigen::Vector.  <a href="a00379.html#ga09cedf6a65b142340c1934c987ed064c">More...</a><br /></td></tr>
<tr class="separator:ga09cedf6a65b142340c1934c987ed064c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c40b4eebec59eeb02294cd7cb0470c"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Derived &gt; <br />
requires (<a class="el" href="a01962.html">Ikarus::Concepts::AddAssignAble</a>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })</td></tr>
<tr class="memitem:ga90c40b4eebec59eeb02294cd7cb0470c"><td class="memTemplItemLeft" align="right" valign="top">Dune::BlockVector&lt; Type &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga90c40b4eebec59eeb02294cd7cb0470c">Ikarus::operator-=</a> (Dune::BlockVector&lt; Type &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</td></tr>
<tr class="memdesc:ga90c40b4eebec59eeb02294cd7cb0470c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the -= operator for Dune::BlockVector += Eigen::Vector.  <a href="a00379.html#ga90c40b4eebec59eeb02294cd7cb0470c">More...</a><br /></td></tr>
<tr class="separator:ga90c40b4eebec59eeb02294cd7cb0470c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada5360aeb17e59d87ae2ba82057421d"><td class="memTemplParams" colspan="2">template&lt;typename... Types, typename Derived &gt; </td></tr>
<tr class="memitem:gaada5360aeb17e59d87ae2ba82057421d"><td class="memTemplItemLeft" align="right" valign="top">Dune::TupleVector&lt; Types... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gaada5360aeb17e59d87ae2ba82057421d">Ikarus::operator+=</a> (Dune::TupleVector&lt; Types... &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</td></tr>
<tr class="memdesc:gaada5360aeb17e59d87ae2ba82057421d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the += operator for Dune::TupleVector += Eigen::Vector.  <a href="a00379.html#gaada5360aeb17e59d87ae2ba82057421d">More...</a><br /></td></tr>
<tr class="separator:gaada5360aeb17e59d87ae2ba82057421d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab36ca6a3183fb9fedbb02b3ecba736"><td class="memTemplParams" colspan="2">template&lt;typename ManifoldPoint , typename Derived &gt; <br />
requires (<a class="el" href="a01962.html">Ikarus::Concepts::AddAssignAble</a>&lt;ManifoldPoint, decltype(b.template segment&lt;ManifoldPoint::valueSize&gt;(0))&gt; and requires() { ManifoldPoint::valueSize; })</td></tr>
<tr class="memitem:gadab36ca6a3183fb9fedbb02b3ecba736"><td class="memTemplItemLeft" align="right" valign="top">Dune::BlockVector&lt; ManifoldPoint &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gadab36ca6a3183fb9fedbb02b3ecba736">Ikarus::addInEmbedding</a> (Dune::BlockVector&lt; ManifoldPoint &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</td></tr>
<tr class="memdesc:gadab36ca6a3183fb9fedbb02b3ecba736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the addition in the embedding space of a vector in the space M^n, where M is a manifold with the points of type ManifoldPoint.  <a href="a00379.html#gadab36ca6a3183fb9fedbb02b3ecba736">More...</a><br /></td></tr>
<tr class="separator:gadab36ca6a3183fb9fedbb02b3ecba736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ffc0c74dbd9aeee3e53b199a21b828c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; <br />
requires (!std::floating_point&lt;Derived&gt;)</td></tr>
<tr class="memitem:ga0ffc0c74dbd9aeee3e53b199a21b828c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga0ffc0c74dbd9aeee3e53b199a21b828c">Ikarus::norm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;v)</td></tr>
<tr class="memdesc:ga0ffc0c74dbd9aeee3e53b199a21b828c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding free norm function to <a class="el" href="a00396.html">Eigen</a> types.  <a href="a00379.html#ga0ffc0c74dbd9aeee3e53b199a21b828c">More...</a><br /></td></tr>
<tr class="separator:ga0ffc0c74dbd9aeee3e53b199a21b828c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb8dc8f6f43516dabf75155b1f22d4c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00379.html#gaceb8dc8f6f43516dabf75155b1f22d4c">Ikarus::norm</a> (const std::floating_point auto &amp;v)</td></tr>
<tr class="memdesc:gaceb8dc8f6f43516dabf75155b1f22d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper Free Function to have the same interface as for <a class="el" href="a00396.html">Eigen</a> Vector Types.  <a href="a00379.html#gaceb8dc8f6f43516dabf75155b1f22d4c">More...</a><br /></td></tr>
<tr class="separator:gaceb8dc8f6f43516dabf75155b1f22d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbc60e06e8e43a9bc14660189eb1baa1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int size&gt; </td></tr>
<tr class="memitem:gacbc60e06e8e43a9bc14660189eb1baa1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gacbc60e06e8e43a9bc14660189eb1baa1">Ikarus::operator*</a> (const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</td></tr>
<tr class="memdesc:gacbc60e06e8e43a9bc14660189eb1baa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen::DiagonalMatrix Product Missing in <a class="el" href="a00396.html">Eigen</a>.  <a href="a00379.html#gacbc60e06e8e43a9bc14660189eb1baa1">More...</a><br /></td></tr>
<tr class="separator:gacbc60e06e8e43a9bc14660189eb1baa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96968bbff353ac49f48d0aa8b9810b7a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int size&gt; </td></tr>
<tr class="memitem:ga96968bbff353ac49f48d0aa8b9810b7a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga96968bbff353ac49f48d0aa8b9810b7a">Ikarus::operator+=</a> (Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</td></tr>
<tr class="memdesc:ga96968bbff353ac49f48d0aa8b9810b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addition for Eigen::DiagonalMatrix.  <a href="a00379.html#ga96968bbff353ac49f48d0aa8b9810b7a">More...</a><br /></td></tr>
<tr class="separator:ga96968bbff353ac49f48d0aa8b9810b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098b554b29619e0cea837f3daa6e0e30"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Scalar , int size&gt; </td></tr>
<tr class="memitem:ga098b554b29619e0cea837f3daa6e0e30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga098b554b29619e0cea837f3daa6e0e30">Ikarus::operator+</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</td></tr>
<tr class="memdesc:ga098b554b29619e0cea837f3daa6e0e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen::Matrix + Eigen::DiagonalMatrix addition missing in <a class="el" href="a00396.html">Eigen</a>.  <a href="a00379.html#ga098b554b29619e0cea837f3daa6e0e30">More...</a><br /></td></tr>
<tr class="separator:ga098b554b29619e0cea837f3daa6e0e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe54695fd1436b5f2d75934a6fda8fe8"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Scalar , int size&gt; </td></tr>
<tr class="memitem:gafe54695fd1436b5f2d75934a6fda8fe8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gafe54695fd1436b5f2d75934a6fda8fe8">Ikarus::operator+</a> (const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</td></tr>
<tr class="memdesc:gafe54695fd1436b5f2d75934a6fda8fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen::DiagonalMatrix + Eigen::Matrix addition missing in <a class="el" href="a00396.html">Eigen</a>.  <a href="a00379.html#gafe54695fd1436b5f2d75934a6fda8fe8">More...</a><br /></td></tr>
<tr class="separator:gafe54695fd1436b5f2d75934a6fda8fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab6437d6235e378a6171bfffd4bf1cc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int size&gt; </td></tr>
<tr class="memitem:ga9ab6437d6235e378a6171bfffd4bf1cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga9ab6437d6235e378a6171bfffd4bf1cc">Ikarus::operator-</a> (const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a)</td></tr>
<tr class="memdesc:ga9ab6437d6235e378a6171bfffd4bf1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus for Eigen::DiagonalMatrix.  <a href="a00379.html#ga9ab6437d6235e378a6171bfffd4bf1cc">More...</a><br /></td></tr>
<tr class="separator:ga9ab6437d6235e378a6171bfffd4bf1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe1660eb760ecc49838d130ba6c6712"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Derived2 &gt; </td></tr>
<tr class="memitem:ga0fe1660eb760ecc49838d130ba6c6712"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga0fe1660eb760ecc49838d130ba6c6712">Ikarus::operator+</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;a, const Eigen::DiagonalWrapper&lt; Derived2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ga0fe1660eb760ecc49838d130ba6c6712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of Eigen::Matrix and Eigen::DiagonalWrapper.  <a href="a00379.html#ga0fe1660eb760ecc49838d130ba6c6712">More...</a><br /></td></tr>
<tr class="separator:ga0fe1660eb760ecc49838d130ba6c6712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9377cd2cf3a5ec468d140cb7063efa58"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Derived2 &gt; </td></tr>
<tr class="memitem:ga9377cd2cf3a5ec468d140cb7063efa58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga9377cd2cf3a5ec468d140cb7063efa58">Ikarus::operator+</a> (const Eigen::DiagonalWrapper&lt; Derived &gt; &amp;a, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ga9377cd2cf3a5ec468d140cb7063efa58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of Eigen::DiagonalWrapper and Eigen::Matrix.  <a href="a00379.html#ga9377cd2cf3a5ec468d140cb7063efa58">More...</a><br /></td></tr>
<tr class="separator:ga9377cd2cf3a5ec468d140cb7063efa58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2cdcc3047e59b91a4874a1355503cd5"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int size&gt; </td></tr>
<tr class="memitem:gac2cdcc3047e59b91a4874a1355503cd5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gac2cdcc3047e59b91a4874a1355503cd5">Ikarus::operator&lt;&lt;</a> (std::ostream &amp;os, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a)</td></tr>
<tr class="memdesc:gac2cdcc3047e59b91a4874a1355503cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator for Eigen::DiagonalMatrix.  <a href="a00379.html#gac2cdcc3047e59b91a4874a1355503cd5">More...</a><br /></td></tr>
<tr class="separator:gac2cdcc3047e59b91a4874a1355503cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd35ea7f69bcc71ee90ea421a1c48167"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:gabd35ea7f69bcc71ee90ea421a1c48167"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gabd35ea7f69bcc71ee90ea421a1c48167">Ikarus::sym</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:gabd35ea7f69bcc71ee90ea421a1c48167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symmetric part of a matrix.  <a href="a00379.html#gabd35ea7f69bcc71ee90ea421a1c48167">More...</a><br /></td></tr>
<tr class="separator:gabd35ea7f69bcc71ee90ea421a1c48167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1496a9776a583f8b09c4244a68453394"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ga1496a9776a583f8b09c4244a68453394"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga1496a9776a583f8b09c4244a68453394">Ikarus::skew</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:ga1496a9776a583f8b09c4244a68453394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew part of a matrix.  <a href="a00379.html#ga1496a9776a583f8b09c4244a68453394">More...</a><br /></td></tr>
<tr class="separator:ga1496a9776a583f8b09c4244a68453394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c08050aff1e3e49e58c7823ecbcc77"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ga40c08050aff1e3e49e58c7823ecbcc77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga40c08050aff1e3e49e58c7823ecbcc77">Ikarus::printForMaple</a> (const <a class="el" href="a01748.html">Eigen::EigenBase</a>&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:ga40c08050aff1e3e49e58c7823ecbcc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to print the matrix in a format that can directly be copied to Maple.  <a href="a00379.html#ga40c08050aff1e3e49e58c7823ecbcc77">More...</a><br /></td></tr>
<tr class="separator:ga40c08050aff1e3e49e58c7823ecbcc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga821ecf80e4a83241318d825f49cd79e4"><td class="memTemplParams" colspan="2">template&lt;typename FieldVectorT &gt; </td></tr>
<tr class="memitem:ga821ecf80e4a83241318d825f49cd79e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga821ecf80e4a83241318d825f49cd79e4">Ikarus::createRandomVector</a> (typename FieldVectorT::value_type lower=-1, typename FieldVectorT::value_type upper=1)</td></tr>
<tr class="memdesc:ga821ecf80e4a83241318d825f49cd79e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random vector of the specified type within a given range.  <a href="a00379.html#ga821ecf80e4a83241318d825f49cd79e4">More...</a><br /></td></tr>
<tr class="separator:ga821ecf80e4a83241318d825f49cd79e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7cb564e7fa11a403cb8439e2436205"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:gabf7cb564e7fa11a403cb8439e2436205"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; ScalarType, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#gabf7cb564e7fa11a403cb8439e2436205">Ikarus::skew</a> (const Eigen::Vector&lt; ScalarType, 3 &gt; &amp;a)</td></tr>
<tr class="memdesc:gabf7cb564e7fa11a403cb8439e2436205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create skew 3x3 matrix from 3d vector.  <a href="a00379.html#gabf7cb564e7fa11a403cb8439e2436205">More...</a><br /></td></tr>
<tr class="separator:gabf7cb564e7fa11a403cb8439e2436205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19d425a4fbc72c2ef7a97d71de9329a4"><td class="memTemplParams" colspan="2">template&lt;typename Derived , size_t sizeOfCondensedIndices&gt; </td></tr>
<tr class="memitem:ga19d425a4fbc72c2ef7a97d71de9329a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga19d425a4fbc72c2ef7a97d71de9329a4">Ikarus::staticCondensation</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;E, const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;indices)</td></tr>
<tr class="memdesc:ga19d425a4fbc72c2ef7a97d71de9329a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static condensation on a square matrix.  <a href="a00379.html#ga19d425a4fbc72c2ef7a97d71de9329a4">More...</a><br /></td></tr>
<tr class="separator:ga19d425a4fbc72c2ef7a97d71de9329a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f675229501979101656ec4dee7764d5"><td class="memTemplParams" colspan="2">template&lt;typename Derived , size_t sizeOfRemovedCols&gt; </td></tr>
<tr class="memitem:ga2f675229501979101656ec4dee7764d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga2f675229501979101656ec4dee7764d5">Ikarus::removeCol</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;E, const std::array&lt; size_t, sizeOfRemovedCols &gt; &amp;indices)</td></tr>
<tr class="memdesc:ga2f675229501979101656ec4dee7764d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified columns from a matrix.  <a href="a00379.html#ga2f675229501979101656ec4dee7764d5">More...</a><br /></td></tr>
<tr class="separator:ga2f675229501979101656ec4dee7764d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga378c5569b7b899586e7c8006fb776351"><td class="memTemplParams" colspan="2">template&lt;typename ST , typename MaterialImpl &gt; </td></tr>
<tr class="memitem:ga378c5569b7b899586e7c8006fb776351"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga378c5569b7b899586e7c8006fb776351">Ikarus::toVoigtAndMaybeReduce</a> (const Eigen::Matrix&lt; ST, 3, 3 &gt; &amp;E, const MaterialImpl &amp;material, bool isStrain=true)</td></tr>
<tr class="memdesc:ga378c5569b7b899586e7c8006fb776351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3x3 matrix to Voigt notation, possibly reducing it based on material properties.  <a href="a00379.html#ga378c5569b7b899586e7c8006fb776351">More...</a><br /></td></tr>
<tr class="separator:ga378c5569b7b899586e7c8006fb776351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30500f2c49b7d1997c7eb7b6ee90ad75"><td class="memTemplParams" colspan="2">template&lt;typename M , typename Derived &gt; </td></tr>
<tr class="memitem:ga30500f2c49b7d1997c7eb7b6ee90ad75"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga30500f2c49b7d1997c7eb7b6ee90ad75">Ikarus::enlargeIfReduced</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;E)</td></tr>
<tr class="memdesc:ga30500f2c49b7d1997c7eb7b6ee90ad75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enlarges a matrix if it reduced in the context of material laws, i.e., <a class="el" href="a01516.html" title="VanishingStress material model that enforces stress components to be zero.">VanishingStress</a> If the material is not reduced the untouched matrix is returned and rendering the function as a NoOp.  <a href="a00379.html#ga30500f2c49b7d1997c7eb7b6ee90ad75">More...</a><br /></td></tr>
<tr class="separator:ga30500f2c49b7d1997c7eb7b6ee90ad75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db6e8f04892e85e6b17e276cdbd0e54"><td class="memTemplParams" colspan="2">template&lt;typename MessageType &gt; </td></tr>
<tr class="memitem:ga5db6e8f04892e85e6b17e276cdbd0e54"><td class="memTemplItemLeft" align="right" valign="top">MessageType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga5db6e8f04892e85e6b17e276cdbd0e54">Ikarus::increment</a> (MessageType &amp;e)</td></tr>
<tr class="memdesc:ga5db6e8f04892e85e6b17e276cdbd0e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the given enum value.  <a href="a00379.html#ga5db6e8f04892e85e6b17e276cdbd0e54">More...</a><br /></td></tr>
<tr class="separator:ga5db6e8f04892e85e6b17e276cdbd0e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3a38551806e4de3ff44f311847ba51"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00379.html#ga0d3a38551806e4de3ff44f311847ba51">Ikarus::utils::polyfit</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;y, int deg)</td></tr>
<tr class="memdesc:ga0d3a38551806e4de3ff44f311847ba51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits a polynomial of a given degree to the given data points.  <a href="a00379.html#ga0d3a38551806e4de3ff44f311847ba51">More...</a><br /></td></tr>
<tr class="separator:ga0d3a38551806e4de3ff44f311847ba51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fbedbac54712740abe25ceab2990472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00379.html#ga1fbedbac54712740abe25ceab2990472">addBindingsToUtils</a> ()</td></tr>
<tr class="separator:ga1fbedbac54712740abe25ceab2990472"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8bdeefaffd49685e7dcd89f34af51d76"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga8bdeefaffd49685e7dcd89f34af51d76"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00379.html#ga8bdeefaffd49685e7dcd89f34af51d76">Ikarus::voigtNotationContainer</a> = std::get&lt;dim - 1&gt;(Impl::voigtIndices)</td></tr>
<tr class="memdesc:ga8bdeefaffd49685e7dcd89f34af51d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for Voigt notation indices based on dimension.1D: 0,0 2D: 0,0; 1,1; 0,1 3D: 0,0; 1,1; 2,2; 1,2; 0,2; 0,1.  <a href="a00379.html#ga8bdeefaffd49685e7dcd89f34af51d76">More...</a><br /></td></tr>
<tr class="separator:ga8bdeefaffd49685e7dcd89f34af51d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga14ad7d33267cea1c93f97f3998081657" name="ga14ad7d33267cea1c93f97f3998081657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14ad7d33267cea1c93f97f3998081657">&#9670;&nbsp;</a></span>MAKE_ENUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAKE_ENUM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">enum class</span> type                           \</div>
<div class="line">  {                                         \</div>
<div class="line">    BEGIN,                                  \</div>
<div class="line">    __VA_ARGS__,                            \</div>
<div class="line">    END                                     \</div>
<div class="line">  };                                        \</div>
<div class="line">  constexpr std::string <a class="code hl_function" href="a00384.html#aef80b6b5b45dcfbea4f722f51a84f53f">toString</a>(type _e) { \</div>
<div class="line">    using <span class="keyword">enum</span> type;                        \</div>
<div class="line">    switch (_e) {                           \</div>
<div class="line">      ENUM_CASE(BEGIN)                      \</div>
<div class="line">      FOR_EACH(<a class="code hl_define" href="a00005.html#a65e77c633f605712a9237282c4e12a75">ENUM_CASE</a>, __VA_ARGS__)      \</div>
<div class="line">      ENUM_CASE(END)                        \</div>
<div class="line">    }                                       \</div>
<div class="line">    __builtin_unreachable();                \</div>
<div class="line">  }</div>
<div class="ttc" id="aa00005_html_a65e77c633f605712a9237282c4e12a75"><div class="ttname"><a href="a00005.html#a65e77c633f605712a9237282c4e12a75">ENUM_CASE</a></div><div class="ttdeci">#define ENUM_CASE(name)</div><div class="ttdef"><b>Definition:</b> makeenum.hh:27</div></div>
<div class="ttc" id="aa00384_html_aef80b6b5b45dcfbea4f722f51a84f53f"><div class="ttname"><a href="a00384.html#aef80b6b5b45dcfbea4f722f51a84f53f">Ikarus::toString</a></div><div class="ttdeci">constexpr std::string toString(DBCOption _e)</div><div class="ttdef"><b>Definition:</b> dirichletbcenforcement.hh:7</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The name of the enum class. </td></tr>
    <tr><td class="paramname">...</td><td>Enumerators to be included between BEGIN and END. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1fbedbac54712740abe25ceab2990472" name="ga1fbedbac54712740abe25ceab2990472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fbedbac54712740abe25ceab2990472">&#9670;&nbsp;</a></span>addBindingsToUtils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addBindingsToUtils </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts a square 1x1, 2x2 or 3x3 matrix to a Voigt notation vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Input matrix of size (size x size). </td></tr>
    <tr><td class="paramname">isStrain</td><td>Flag indicating whether the conversion is for strain (true) or not (false) (default is true).. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with components in Voigt notation vector.</dd></dl>
<p>This function converts a square matrix to a Voigt notation vector, which contains the unique components of the input matrix.</p>
<p >The optional isStrain parameter allows the user to specify whether the conversion is intended for strain calculations. If isStrain is true, the off-diagonal components are multiplied by 2, providing the correct Voigt notation for symmetric strain tensors.</p>
<p >Converts a vector given in Voigt notation to a matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EVoigt</td><td>Voigt notation vector. </td></tr>
    <tr><td class="paramname">isStrain</td><td>Flag indicating whether the vector represents a strain (default is true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix corresponding to the vector in Voigt notation.</dd></dl>
<p>This function converts a vector given in Voigt notation to the corresponding matrix. The conversion depends on the size The parameter <code>isStrain</code> is used to determine the conversion factor for off-diagonal components, which need to be divided by 2 in the matrix representation if the quantity is a strain tensor.</p>
<p >The function requires that the size of the Voigt notation vector is valid (1, 3, or 6).</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_ga1fbedbac54712740abe25ceab2990472_icgraph.svg" width="356" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gadab36ca6a3183fb9fedbb02b3ecba736" name="gadab36ca6a3183fb9fedbb02b3ecba736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab36ca6a3183fb9fedbb02b3ecba736">&#9670;&nbsp;</a></span>addInEmbedding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ManifoldPoint , typename Derived &gt; <br />
requires (<a class="el" href="a01962.html">Ikarus::Concepts::AddAssignAble</a>&lt;ManifoldPoint, decltype(b.template segment&lt;ManifoldPoint::valueSize&gt;(0))&gt; and requires() { ManifoldPoint::valueSize; })</div>
      <table class="memname">
        <tr>
          <td class="memname">Dune::BlockVector&lt; ManifoldPoint &gt; &amp; Ikarus::addInEmbedding </td>
          <td>(</td>
          <td class="paramtype">Dune::BlockVector&lt; ManifoldPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ManifoldPoint</td><td>Manifold type. </td></tr>
    <tr><td class="paramname">Derived</td><td>ManifoldPoint of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input Dune::BlockVector. </td></tr>
    <tr><td class="paramname">b</td><td>Input Eigen::Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the modified Dune::BlockVector. </dd></dl>

</div>
</div>
<a id="gacb9e813539bfd84df99ad097cabc9de9" name="gacb9e813539bfd84df99ad097cabc9de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9e813539bfd84df99ad097cabc9de9">&#9670;&nbsp;</a></span>checkGradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NonlinearOperator , typename UpdateType  = typename NonlinearOperator::template ParameterValue&lt;0&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Ikarus::utils::checkGradient </td>
          <td>(</td>
          <td class="paramtype">NonlinearOperator &amp;&#160;</td>
          <td class="paramname"><em>nonLinOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01832.html">CheckFlags</a>&#160;</td>
          <td class="paramname"><em>checkFlags</em> = <code><a class="el" href="a01832.html">CheckFlags</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt;&#160;</td>
          <td class="paramname"><em>p_updateFunction</em> = <code>[](typename&#160;NonlinearOperator::template&#160;ParameterValue&lt;0&gt;&amp;&#160;a,&#160;const&#160;UpdateType&amp;&#160;b)&#160;{&#160;a&#160;+=&#160;b;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The checkgradient function is inspired by <a href="http://sma.epfl.ch/~nboumal/book/">http://sma.epfl.ch/~nboumal/book/</a> Chapter 4.8 and <a href="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NonlinearOperator</td><td>Type of the nonlinear operator. </td></tr>
    <tr><td class="paramname">UpdateType</td><td>Type of the update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonLinOp</td><td>The nonlinear operator. </td></tr>
    <tr><td class="paramname">checkFlags</td><td>Flags for the check. </td></tr>
    <tr><td class="paramname">p_updateFunction</td><td>Update function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the check passed, false otherwise. </dd></dl>

</div>
</div>
<a id="ga5d1a87964a3d6b6ddc994532e93b6798" name="ga5d1a87964a3d6b6ddc994532e93b6798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d1a87964a3d6b6ddc994532e93b6798">&#9670;&nbsp;</a></span>checkHessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NonlinearOperator , typename UpdateType  = typename NonlinearOperator::template ParameterValue&lt;0&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Ikarus::utils::checkHessian </td>
          <td>(</td>
          <td class="paramtype">NonlinearOperator &amp;&#160;</td>
          <td class="paramname"><em>nonLinOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01832.html">CheckFlags</a>&#160;</td>
          <td class="paramname"><em>checkFlags</em> = <code><a class="el" href="a01832.html">CheckFlags</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt;&#160;</td>
          <td class="paramname"><em>p_updateFunction</em> = <code>[](typename&#160;NonlinearOperator::template&#160;ParameterValue&lt;0&gt;&amp;&#160;a,&#160;const&#160;UpdateType&amp;&#160;b)&#160;{&#160;a&#160;+=&#160;b;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The checkHessian function is inspired by <a href="http://sma.epfl.ch/~nboumal/book/">http://sma.epfl.ch/~nboumal/book/</a> Chapter 6.8 and <a href="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkhessian.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkhessian.m</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NonlinearOperator</td><td>Type of the nonlinear operator. </td></tr>
    <tr><td class="paramname">UpdateType</td><td>Type of the update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonLinOp</td><td>The nonlinear operator. </td></tr>
    <tr><td class="paramname">checkFlags</td><td>Flags for the check. </td></tr>
    <tr><td class="paramname">p_updateFunction</td><td>Update function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the check passed, false otherwise. </dd></dl>

</div>
</div>
<a id="ga553465359c199ef676945832587d2869" name="ga553465359c199ef676945832587d2869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga553465359c199ef676945832587d2869">&#9670;&nbsp;</a></span>checkJacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NonlinearOperator , typename UpdateType  = typename NonlinearOperator::template ParameterValue&lt;0&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Ikarus::utils::checkJacobian </td>
          <td>(</td>
          <td class="paramtype">NonlinearOperator &amp;&#160;</td>
          <td class="paramname"><em>nonLinOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01832.html">CheckFlags</a>&#160;</td>
          <td class="paramname"><em>checkFlags</em> = <code><a class="el" href="a01832.html">CheckFlags</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt;&#160;</td>
          <td class="paramname"><em>p_updateFunction</em> = <code>[](typename&#160;NonlinearOperator::template&#160;ParameterValue&lt;0&gt;&amp;&#160;a,&#160;const&#160;UpdateType&amp;&#160;b)&#160;{&#160;a&#160;+=&#160;b;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The checkjacobian function is inspired by <a href="http://sma.epfl.ch/~nboumal/book/">http://sma.epfl.ch/~nboumal/book/</a> Chapter 4.8 and <a href="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NonlinearOperator</td><td>Type of the nonlinear operator. </td></tr>
    <tr><td class="paramname">UpdateType</td><td>Type of the update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonLinOp</td><td>The nonlinear operator. </td></tr>
    <tr><td class="paramname">checkFlags</td><td>Flags for the check. </td></tr>
    <tr><td class="paramname">p_updateFunction</td><td>Update function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the check passed, false otherwise. </dd></dl>

</div>
</div>
<a id="ga609664964681787f2f736f772b82a01e" name="ga609664964681787f2f736f772b82a01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga609664964681787f2f736f772b82a01e">&#9670;&nbsp;</a></span>correctionSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; <br />
requires requires { Type::correctionSize; }</div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Ikarus::correctionSize </td>
          <td>(</td>
          <td class="paramtype">const Dune::BlockVector&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Manifold type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input Dune::BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total correction size. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_ga609664964681787f2f736f772b82a01e_icgraph.svg" width="367" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ga821ecf80e4a83241318d825f49cd79e4" name="ga821ecf80e4a83241318d825f49cd79e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga821ecf80e4a83241318d825f49cd79e4">&#9670;&nbsp;</a></span>createRandomVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::createRandomVector </td>
          <td>(</td>
          <td class="paramtype">typename FieldVectorT::value_type&#160;</td>
          <td class="paramname"><em>lower</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename FieldVectorT::value_type&#160;</td>
          <td class="paramname"><em>upper</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldVectorT</td><td>The type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower</td><td>The lower bound of the random values (default is -1). </td></tr>
    <tr><td class="paramname">upper</td><td>The upper bound of the random values (default is 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random vector within the specified range. </dd></dl>

</div>
</div>
<a id="ga30500f2c49b7d1997c7eb7b6ee90ad75" name="ga30500f2c49b7d1997c7eb7b6ee90ad75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30500f2c49b7d1997c7eb7b6ee90ad75">&#9670;&nbsp;</a></span>enlargeIfReduced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) Ikarus::enlargeIfReduced </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>Type of the material. </td></tr>
    <tr><td class="paramname">Derived</td><td>Type of the input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Resulting matrix based on material properties.</dd></dl>
<p>This function takes an input matrix and, based on the material properties, either returns the original matrix (if it is not reduced) or enlarges the matrix by filling in the specified columns with zeros (if it is reduced). </p>

</div>
</div>
<a id="ga16e7d5f51cc42190c090e727495c1609" name="ga16e7d5f51cc42190c090e727495c1609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e7d5f51cc42190c090e727495c1609">&#9670;&nbsp;</a></span>findLineSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, decltype(Eigen::seq(0, 0))&gt; Ikarus::utils::findLineSegment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segmentSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >his function is inspired by the MATLAB code at: <a href="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/identify_linear_piece.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/identify_linear_piece.m</a> It is designed to find the most linear segment in a set of data points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinates of the data points. </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinates of the data points. </td></tr>
    <tr><td class="paramname">segmentSize</td><td>The size of the line segment to be identified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the polynomial representing the identified line segment and the indices of the data points in the segment. </dd></dl>

</div>
</div>
<a id="ga0728039472747184e9eb2ec0992a4a2b" name="ga0728039472747184e9eb2ec0992a4a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0728039472747184e9eb2ec0992a4a2b">&#9670;&nbsp;</a></span>flatPreBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PreBasis &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) Ikarus::flatPreBasis </td>
          <td>(</td>
          <td class="paramtype">const PreBasis &amp;&#160;</td>
          <td class="paramname"><em>preBasis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa19ed04a701aaa500f7c486addae2d2e" name="gaa19ed04a701aaa500f7c486addae2d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa19ed04a701aaa500f7c486addae2d2e">&#9670;&nbsp;</a></span>globalIndexFromGlobalPosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int size, typename Basis &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::utils::globalIndexFromGlobalPosition </td>
          <td>(</td>
          <td class="paramtype">const Basis &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01784.html">Dune::FieldVector</a>&lt; double, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">size</td><td>Size of the global nodal coordinate vector </td></tr>
    <tr><td class="paramname">Basis</td><td>Type of the basis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>The grid basis. </td></tr>
    <tr><td class="paramname">pos</td><td>Global position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global index </dd></dl>

</div>
</div>
<a id="ga2a6c26beeb8d52283e82939ca585dc20" name="ga2a6c26beeb8d52283e82939ca585dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a6c26beeb8d52283e82939ca585dc20">&#9670;&nbsp;</a></span>hessianN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fun , typename... Vars, typename... Args, typename U , typename G , typename H &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Ikarus::utils::hessianN </td>
          <td>(</td>
          <td class="paramtype">const Fun &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const autodiff::Wrt&lt; Vars... &gt; &amp;&#160;</td>
          <td class="paramname"><em>wrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const autodiff::At&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; G, U::RowsAtCompileTime &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; H, U::RowsAtCompileTime &gt; &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fun</td><td>The type of the function to be differentiated. </td></tr>
    <tr><td class="paramname">Vars</td><td>The types of the variables with respect to which the Hessian is computed. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of the arguments passed to the function. </td></tr>
    <tr><td class="paramname">U</td><td>The type representing the result of the function evaluation. </td></tr>
    <tr><td class="paramname">G</td><td>The type representing the gradient of the function. </td></tr>
    <tr><td class="paramname">H</td><td>The type representing the Hessian matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be differentiated. </td></tr>
    <tr><td class="paramname">wrt</td><td>The variables with respect to which the Hessian is computed. </td></tr>
    <tr><td class="paramname">at</td><td>The values at which the Hessian is evaluated. </td></tr>
    <tr><td class="paramname">u</td><td>The result of the function evaluation. </td></tr>
    <tr><td class="paramname">g</td><td>The gradient of the function. </td></tr>
    <tr><td class="paramname">h</td><td>The Hessian matrix (output). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5db6e8f04892e85e6b17e276cdbd0e54" name="ga5db6e8f04892e85e6b17e276cdbd0e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5db6e8f04892e85e6b17e276cdbd0e54">&#9670;&nbsp;</a></span>increment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MessageType &amp; Ikarus::increment </td>
          <td>(</td>
          <td class="paramtype">MessageType &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MessageType</td><td>The enum type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The enum value to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incremented enum value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Dune::RangeError</td><td>if trying to increment MessageType::END. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_ga5db6e8f04892e85e6b17e276cdbd0e54_icgraph.svg" width="340" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ga0ffc0c74dbd9aeee3e53b199a21b828c" name="ga0ffc0c74dbd9aeee3e53b199a21b828c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ffc0c74dbd9aeee3e53b199a21b828c">&#9670;&nbsp;</a></span>norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; <br />
requires (!std::floating_point&lt;Derived&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Norm of the matrix. </dd></dl>

</div>
</div>
<a id="gaceb8dc8f6f43516dabf75155b1f22d4c" name="gaceb8dc8f6f43516dabf75155b1f22d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb8dc8f6f43516dabf75155b1f22d4c">&#9670;&nbsp;</a></span>norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::norm </td>
          <td>(</td>
          <td class="paramtype">const std::floating_point auto &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Absolute value of the scalar. </dd></dl>

</div>
</div>
<a id="gae9098182120929a0d21cff1c38f5ca84" name="gae9098182120929a0d21cff1c38f5ca84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9098182120929a0d21cff1c38f5ca84">&#9670;&nbsp;</a></span>obtainLagrangeGlobalNodePositions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int size, typename LV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Ikarus::utils::obtainLagrangeGlobalNodePositions </td>
          <td>(</td>
          <td class="paramtype">const LV &amp;&#160;</td>
          <td class="paramname"><em>localView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a01784.html">Dune::FieldVector</a>&lt; double, size &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lagrangeNodeGlobalCoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">size</td><td>Size of the global nodal coordinate vector </td></tr>
    <tr><td class="paramname">LV</td><td>Type of the local view</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localView</td><td>Local view bounded to an element </td></tr>
    <tr><td class="paramname">lagrangeNodeGlobalCoords</td><td>A vector of global nodal coordinates to be updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbc60e06e8e43a9bc14660189eb1baa1" name="gacbc60e06e8e43a9bc14660189eb1baa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbc60e06e8e43a9bc14660189eb1baa1">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the diagonal matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input DiagonalMatrix. </td></tr>
    <tr><td class="paramname">b</td><td>Input DiagonalMatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the two DiagonalMatrices. </dd></dl>

</div>
</div>
<a id="gafe54695fd1436b5f2d75934a6fda8fe8" name="gafe54695fd1436b5f2d75934a6fda8fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe54695fd1436b5f2d75934a6fda8fe8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Scalar , int size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
    <tr><td class="paramname">Scalar</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the diagonal matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input DiagonalMatrix. </td></tr>
    <tr><td class="paramname">b</td><td>Input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the DiagonalMatrix and <a class="el" href="a00396.html">Eigen</a> matrix. </dd></dl>

</div>
</div>
<a id="ga9377cd2cf3a5ec468d140cb7063efa58" name="ga9377cd2cf3a5ec468d140cb7063efa58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9377cd2cf3a5ec468d140cb7063efa58">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DiagonalWrapper&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> DiagonalWrapper. </td></tr>
    <tr><td class="paramname">Derived2</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input <a class="el" href="a00396.html">Eigen</a> DiagonalWrapper. </td></tr>
    <tr><td class="paramname">b</td><td>Input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of DiagonalWrapper and <a class="el" href="a00396.html">Eigen</a> matrix. </dd></dl>

</div>
</div>
<a id="ga098b554b29619e0cea837f3daa6e0e30" name="ga098b554b29619e0cea837f3daa6e0e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga098b554b29619e0cea837f3daa6e0e30">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Scalar , int size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
    <tr><td class="paramname">Scalar</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the diagonal matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Input DiagonalMatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the <a class="el" href="a00396.html">Eigen</a> matrix and DiagonalMatrix. </dd></dl>

</div>
</div>
<a id="ga0fe1660eb760ecc49838d130ba6c6712" name="ga0fe1660eb760ecc49838d130ba6c6712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe1660eb760ecc49838d130ba6c6712">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DiagonalWrapper&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
    <tr><td class="paramname">Derived2</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> DiagonalWrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Input <a class="el" href="a00396.html">Eigen</a> DiagonalWrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of <a class="el" href="a00396.html">Eigen</a> matrix and DiagonalWrapper. </dd></dl>

</div>
</div>
<a id="ga09cedf6a65b142340c1934c987ed064c" name="ga09cedf6a65b142340c1934c987ed064c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09cedf6a65b142340c1934c987ed064c">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Derived &gt; <br />
requires (<a class="el" href="a01962.html">Ikarus::Concepts::AddAssignAble</a>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })</div>
      <table class="memname">
        <tr>
          <td class="memname">Dune::BlockVector&lt; Type &gt; &amp; Ikarus::operator+= </td>
          <td>(</td>
          <td class="paramtype">Dune::BlockVector&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Manifold type. </td></tr>
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input Dune::BlockVector. </td></tr>
    <tr><td class="paramname">b</td><td>Input Eigen::Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the modified Dune::BlockVector. </dd></dl>

</div>
</div>
<a id="gaada5360aeb17e59d87ae2ba82057421d" name="gaada5360aeb17e59d87ae2ba82057421d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaada5360aeb17e59d87ae2ba82057421d">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types, typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Dune::TupleVector&lt; Types... &gt; &amp; Ikarus::operator+= </td>
          <td>(</td>
          <td class="paramtype">Dune::TupleVector&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>Types of the elements in the TupleVector. </td></tr>
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input Dune::TupleVector. </td></tr>
    <tr><td class="paramname">b</td><td>Input Eigen::Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the modified Dune::TupleVector. </dd></dl>

</div>
</div>
<a id="ga96968bbff353ac49f48d0aa8b9810b7a" name="ga96968bbff353ac49f48d0aa8b9810b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96968bbff353ac49f48d0aa8b9810b7a">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::operator+= </td>
          <td>(</td>
          <td class="paramtype">Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the diagonal matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input DiagonalMatrix. </td></tr>
    <tr><td class="paramname">b</td><td>Input DiagonalMatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the modified DiagonalMatrix. </dd></dl>

</div>
</div>
<a id="ga9ab6437d6235e378a6171bfffd4bf1cc" name="ga9ab6437d6235e378a6171bfffd4bf1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ab6437d6235e378a6171bfffd4bf1cc">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::operator- </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the diagonal matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input DiagonalMatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negation of the DiagonalMatrix. </dd></dl>

</div>
</div>
<a id="ga90c40b4eebec59eeb02294cd7cb0470c" name="ga90c40b4eebec59eeb02294cd7cb0470c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90c40b4eebec59eeb02294cd7cb0470c">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Derived &gt; <br />
requires (<a class="el" href="a01962.html">Ikarus::Concepts::AddAssignAble</a>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })</div>
      <table class="memname">
        <tr>
          <td class="memname">Dune::BlockVector&lt; Type &gt; &amp; Ikarus::operator-= </td>
          <td>(</td>
          <td class="paramtype">Dune::BlockVector&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Manifold type. </td></tr>
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input Dune::BlockVector. </td></tr>
    <tr><td class="paramname">b</td><td>Input Eigen::Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the modified Dune::BlockVector. </dd></dl>

</div>
</div>
<a id="gac2cdcc3047e59b91a4874a1355503cd5" name="gac2cdcc3047e59b91a4874a1355503cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2cdcc3047e59b91a4874a1355503cd5">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Ikarus::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the diagonal matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream. </td></tr>
    <tr><td class="paramname">a</td><td>Input DiagonalMatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream. </dd></dl>

</div>
</div>
<a id="gaa33adfa2e95d7040a816bb2da81d275d" name="gaa33adfa2e95d7040a816bb2da81d275d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa33adfa2e95d7040a816bb2da81d275d">&#9670;&nbsp;</a></span>orthonormalizeMatrixColumns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::orthonormalizeMatrixColumns </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00396.html">Eigen</a> Matrix with orthonormalized columns. </dd></dl>

</div>
</div>
<a id="ga0d3a38551806e4de3ff44f311847ba51" name="ga0d3a38551806e4de3ff44f311847ba51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d3a38551806e4de3ff44f311847ba51">&#9670;&nbsp;</a></span>polyfit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, double &gt; Ikarus::utils::polyfit </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input vector of x-coordinates. </td></tr>
    <tr><td class="paramname">y</td><td>The input vector of y-coordinates. </td></tr>
    <tr><td class="paramname">deg</td><td>The degree of the polynomial to fit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;Dune::Functions::Polynomial&lt;double&gt;, double&gt; A tuple containing the fitted polynomial and the least square error. </dd></dl>

</div>
</div>
<a id="ga40c08050aff1e3e49e58c7823ecbcc77" name="ga40c08050aff1e3e49e58c7823ecbcc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40c08050aff1e3e49e58c7823ecbcc77">&#9670;&nbsp;</a></span>printForMaple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Ikarus::printForMaple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01748.html">Eigen::EigenBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>The derived type of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30df35336d19b00bc5db2a0b52ce650e" name="ga30df35336d19b00bc5db2a0b52ce650e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30df35336d19b00bc5db2a0b52ce650e">&#9670;&nbsp;</a></span>referenceElementSubEntityPositions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="a01336.html">FE</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::utils::referenceElementSubEntityPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01336.html">FE</a> &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>codim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="a01336.html" title="FE class is a base class for all finite elements.">FE</a></td><td>Type of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>finite element </td></tr>
    <tr><td class="paramname">codim</td><td>codim of requested subentity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view over the position of the subenties </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_ga30df35336d19b00bc5db2a0b52ce650e_icgraph.svg" width="434" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ga8c05dce8a66fc4efbe31674b87d18298" name="ga8c05dce8a66fc4efbe31674b87d18298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c05dce8a66fc4efbe31674b87d18298">&#9670;&nbsp;</a></span>referenceElementVertexPositions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="a01336.html">FE</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::utils::referenceElementVertexPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01336.html">FE</a> &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="a01336.html" title="FE class is a base class for all finite elements.">FE</a></td><td>Type of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga2f675229501979101656ec4dee7764d5" name="ga2f675229501979101656ec4dee7764d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f675229501979101656ec4dee7764d5">&#9670;&nbsp;</a></span>removeCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , size_t sizeOfRemovedCols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::removeCol </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; size_t, sizeOfRemovedCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the matrix. </td></tr>
    <tr><td class="paramname">sizeOfRemovedCols</td><td>Size of the columns to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">indices</td><td>Array of column indices to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting matrix after removing specified columns.</dd></dl>
<p>This function removes specified columns from a matrix. It computes the remaining columns after removing the specified indices and returns the resulting matrix. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_ga2f675229501979101656ec4dee7764d5_icgraph.svg" width="431" height="170"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ga1496a9776a583f8b09c4244a68453394" name="ga1496a9776a583f8b09c4244a68453394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1496a9776a583f8b09c4244a68453394">&#9670;&nbsp;</a></span>skew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived Ikarus::skew </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Skew part of the matrix. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_ga1496a9776a583f8b09c4244a68453394_icgraph.svg" width="591" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gabf7cb564e7fa11a403cb8439e2436205" name="gabf7cb564e7fa11a403cb8439e2436205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf7cb564e7fa11a403cb8439e2436205">&#9670;&nbsp;</a></span>skew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; ScalarType, 3, 3 &gt; Ikarus::skew </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector&lt; ScalarType, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScalarType</td><td>The type of the coordinates in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The skew matrix. </dd></dl>

</div>
</div>
<a id="ga19d425a4fbc72c2ef7a97d71de9329a4" name="ga19d425a4fbc72c2ef7a97d71de9329a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19d425a4fbc72c2ef7a97d71de9329a4">&#9670;&nbsp;</a></span>staticCondensation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , size_t sizeOfCondensedIndices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::staticCondensation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the matrix. </td></tr>
    <tr><td class="paramname">sizeOfCondensedIndices</td><td>Size of the condensed indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">indices</td><td>Array of indices to be condensed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting matrix after static condensation.</dd></dl>
<p>This function performs static condensation on a square matrix. It removes the specified indices from the matrix, computes the remaining submatrices (K11, K12, K22), and returns the result of the static condensation. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_ga19d425a4fbc72c2ef7a97d71de9329a4_icgraph.svg" width="426" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gabd35ea7f69bcc71ee90ea421a1c48167" name="gabd35ea7f69bcc71ee90ea421a1c48167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd35ea7f69bcc71ee90ea421a1c48167">&#9670;&nbsp;</a></span>sym()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived Ikarus::sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Type of the input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input <a class="el" href="a00396.html">Eigen</a> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Symmetric part of the matrix. </dd></dl>

</div>
</div>
<a id="ga378c5569b7b899586e7c8006fb776351" name="ga378c5569b7b899586e7c8006fb776351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga378c5569b7b899586e7c8006fb776351">&#9670;&nbsp;</a></span>toVoigtAndMaybeReduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST , typename MaterialImpl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::toVoigtAndMaybeReduce </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; ST, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaterialImpl &amp;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isStrain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ST</td><td>Scalar type of the matrix. </td></tr>
    <tr><td class="paramname">MaterialImpl</td><td>Type of the material implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Input 3x3 matrix. </td></tr>
    <tr><td class="paramname">material</td><td>Reference to the material implementation. </td></tr>
    <tr><td class="paramname">isStrain</td><td>Flag indicating if the matrix represents strain (default is true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting matrix in Voigt notation.</dd></dl>
<p>This function converts a 3x3 matrix to its Voigt notation. If the material is not reduced, the full Voigt notation is returned. Otherwise, the specified columns (based on material properties, such as <a class="el" href="a01516.html" title="VanishingStress material model that enforces stress components to be zero.">VanishingStress</a>) are removed, and the reduced Voigt notation is returned. </p>

</div>
</div>
<a id="gac1df27a0dfa864327029cdb906a1840c" name="gac1df27a0dfa864327029cdb906a1840c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1df27a0dfa864327029cdb906a1840c">&#9670;&nbsp;</a></span>valueSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; <br />
requires requires { Type::valueSize; }</div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Ikarus::valueSize </td>
          <td>(</td>
          <td class="paramtype">const Dune::BlockVector&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Manifold type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input Dune::BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total value size. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_gac1df27a0dfa864327029cdb906a1840c_icgraph.svg" width="370" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gaf1c6bdf14e40ee46e881f646e1c28b0d" name="gaf1c6bdf14e40ee46e881f646e1c28b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c6bdf14e40ee46e881f646e1c28b0d">&#9670;&nbsp;</a></span>viewAsEigenMatrixAsDynFixed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::viewAsEigenMatrixAsDynFixed </td>
          <td>(</td>
          <td class="paramtype">const Dune::BlockVector&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>blockedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the elements in the BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockedVector</td><td>Input Dune::BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::Map of the BlockVector as a dynamic Eigen::Matrix (const version). </dd></dl>

</div>
</div>
<a id="gaf9d7cf401f9f03ce1aae728c646ce178" name="gaf9d7cf401f9f03ce1aae728c646ce178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9d7cf401f9f03ce1aae728c646ce178">&#9670;&nbsp;</a></span>viewAsEigenMatrixAsDynFixed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::viewAsEigenMatrixAsDynFixed </td>
          <td>(</td>
          <td class="paramtype">Dune::BlockVector&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>blockedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the elements in the BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockedVector</td><td>Input Dune::BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::Map of the BlockVector as a dynamic Eigen::Matrix. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_gaf9d7cf401f9f03ce1aae728c646ce178_icgraph.svg" width="703" height="444"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ga146a052f6eb97304a8172c7b65fe70fb" name="ga146a052f6eb97304a8172c7b65fe70fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146a052f6eb97304a8172c7b65fe70fb">&#9670;&nbsp;</a></span>viewAsEigenMatrixFixedDyn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::viewAsEigenMatrixFixedDyn </td>
          <td>(</td>
          <td class="paramtype">const Dune::BlockVector&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>blockedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the elements in the BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockedVector</td><td>Input Dune::BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::Map of the BlockVector as a fixed-size Eigen::Matrix with dynamic columns (const version). </dd></dl>

</div>
</div>
<a id="gac25618d0e7c4aece653662d2541b61ec" name="gac25618d0e7c4aece653662d2541b61ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac25618d0e7c4aece653662d2541b61ec">&#9670;&nbsp;</a></span>viewAsEigenMatrixFixedDyn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::viewAsEigenMatrixFixedDyn </td>
          <td>(</td>
          <td class="paramtype">Dune::BlockVector&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>blockedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the elements in the BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockedVector</td><td>Input Dune::BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::Map of the BlockVector as a fixed-size Eigen::Matrix with dynamic columns. </dd></dl>

</div>
</div>
<a id="ga3beeb26c911116fa02df8756214484aa" name="ga3beeb26c911116fa02df8756214484aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3beeb26c911116fa02df8756214484aa">&#9670;&nbsp;</a></span>viewAsFlatEigenVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::viewAsFlatEigenVector </td>
          <td>(</td>
          <td class="paramtype">const Dune::BlockVector&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>blockedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the elements in the BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockedVector</td><td>Input Dune::BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::Map of the BlockVector as a flat Eigen::Vector (const version). </dd></dl>

</div>
</div>
<a id="ga545d74839895f4576a3b8c97d72abefd" name="ga545d74839895f4576a3b8c97d72abefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga545d74839895f4576a3b8c97d72abefd">&#9670;&nbsp;</a></span>viewAsFlatEigenVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ikarus::viewAsFlatEigenVector </td>
          <td>(</td>
          <td class="paramtype">Dune::BlockVector&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>blockedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the elements in the BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockedVector</td><td>Input Dune::BlockVector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::Map of the BlockVector as a flat Eigen::Vector. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00379_ga545d74839895f4576a3b8c97d72abefd_icgraph.svg" width="515" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga8bdeefaffd49685e7dcd89f34af51d76" name="ga8bdeefaffd49685e7dcd89f34af51d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bdeefaffd49685e7dcd89f34af51d76">&#9670;&nbsp;</a></span>voigtNotationContainer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Ikarus::voigtNotationContainer = std::get&lt;dim - 1&gt;(Impl::voigtIndices)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension for which Voigt indices are needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
SPDX-FileCopyrightText: 2021-2025 The Ikarus Developers mueller@ibb.uni-stuttgart.de
SPDX-License-Identifier: LGPL-3.0-or-later
-->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
        <li class="footer">
            &copy; Copyright 2021-<script>document.write(new Date().getFullYear())</script> <a href="https://github.com/ikarus-project/ikarus/blob/main/LICENSE.md">Ikarus project contributors</a>
            (doc pages: <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY 4.0</a> /
            code examples: <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">LGPLv3 or later</a>) &#160;
            <img class="footer" alt="Ikarus" src="BigLogo_transparent.png" height="15"/> 0.4.1
            &#160; Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
    </ul>
</div>
<!--MERMAID GRAPHS-->
<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: 'base',
        themeVariables: {
            primaryColor: '#f4f4ff',
            secondaryColor: 'rgba(244,244,255,0.9)',
            tertiaryColor: '#F9FAFC',
        },
    });
</script>
<!--MERMAID GRAPHS-->
</body>
</html>
