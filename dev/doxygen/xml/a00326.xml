<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.4" xml:lang="en-US">
  <compounddef id="a00326" kind="namespace" language="C++">
    <compoundname>Ikarus::utils</compoundname>
    <innerclass refid="a01524" prot="public">Ikarus::utils::CheckFlags</innerclass>
    <innerclass refid="a01488" prot="public">Ikarus::utils::LoadDefault</innerclass>
    <innerclass refid="a01480" prot="public">Ikarus::utils::SolverDefault</innerclass>
    <innerclass refid="a01484" prot="public">Ikarus::utils::UpdateDefault</innerclass>
      <sectiondef kind="var">
      <memberdef kind="variable" id="a00313_1ga62ee166e690831f40395df076e9cdddb" prot="public" static="yes" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool Ikarus::utils::countTypeSpecialization_v</definition>
        <argsstring></argsstring>
        <name>countTypeSpecialization_v</name>
        <qualifiedname>Ikarus::utils::countTypeSpecialization_v</qualifiedname>
        <initializer>= <ref refid="a00313_1gadf919f3a9b0c1d50134f9d041a3ce9f7" kindref="member">countTypeSpecialization</ref>&lt;Type, Tuple&gt;()</initializer>
        <briefdescription>
<para>Variable template for counting the occurrences of a specialization of a template type in a tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to count occurrences for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This variable template provides a compile-time constant for the count of occurrences of a specialization of a template type in a tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="418" column="23" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="418" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="a00313_1ga6e36d8f5163f232e3142ecbd0575e8b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Ikarus::utils::makeUniqueAndSort</definition>
        <argsstring>(std::ranges::random_access_range auto &amp;r)</argsstring>
        <name>makeUniqueAndSort</name>
        <qualifiedname>Ikarus::utils::makeUniqueAndSort</qualifiedname>
        <param>
          <type>std::ranges::random_access_range auto &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>Sorts and removes duplicate elements from a random access range.</para>
<para>*. </para>
        </briefdescription>
        <detaileddescription>
<para>This function sorts the elements of the given random access range and removes duplicate elements, leaving only unique elements in the range.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>The random access range to be modified. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="28" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="28" bodyend="31"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1ga8f6d2c90383de63c518cefeaccee76f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::appendUnique</definition>
        <argsstring>(std::ranges::random_access_range auto &amp;r, Value &amp;&amp;v)</argsstring>
        <name>appendUnique</name>
        <qualifiedname>Ikarus::utils::appendUnique</qualifiedname>
        <param>
          <type>std::ranges::random_access_range auto &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>Value &amp;&amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Appends a value to the range if it is not already present. </para>
        </briefdescription>
        <detaileddescription>
<para>This function appends a value to the given random access range only if the value is not already present in the range. It returns the index of the value in the range, whether it was added or already existed. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Value</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be appended. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>The random access range to be modified. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be appended. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The index of the value in the range. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="44" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="44" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1ga11bb80da2430170954d6b7519f9498a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Ikarus::utils::printContent</definition>
        <argsstring>(Container &amp;&amp;c, std::ostream &amp;os=std::cout)</argsstring>
        <name>printContent</name>
        <qualifiedname>Ikarus::utils::printContent</qualifiedname>
        <param>
          <type>Container &amp;&amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
          <defval>std::cout</defval>
        </param>
        <briefdescription>
<para>Prints the contents of a container to the specified output stream. </para>
        </briefdescription>
        <detaileddescription>
<para>This function prints the contents of the given container to the specified output stream.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the container to be printed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>The container whose contents will be printed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>os</parametername>
</parameternamelist>
<parameterdescription>
<para>The output stream where the contents will be printed. Default is std::cout. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="64" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="64" bodyend="66"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1ga5f3a9e195a06ac4419ccb479f8819d62" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::transformValueRangeToPointerRange</definition>
        <argsstring>(Container &amp;cont)</argsstring>
        <name>transformValueRangeToPointerRange</name>
        <qualifiedname>Ikarus::utils::transformValueRangeToPointerRange</qualifiedname>
        <param>
          <type>Container &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
<para>Transforms a value range to a pointer range. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the container containing values. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>The container whose values will be transformed to pointers. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A subrange containing pointers to the values. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="77" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="77" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1gaabfee41eeb4843cb2fa37b5f381e9fef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::transformPointerRangeToReferenceRange</definition>
        <argsstring>(Container &amp;cont)</argsstring>
        <name>transformPointerRangeToReferenceRange</name>
        <qualifiedname>Ikarus::utils::transformPointerRangeToReferenceRange</qualifiedname>
        <param>
          <type>Container &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
<para>Transforms a pointer range to a reference range. </para>
        </briefdescription>
        <detaileddescription>
<para>This function transforms a range of pointers to a range of references.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the container containing pointers. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>The container whose pointers will be transformed to references. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A subrange containing references to the pointed objects. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="92" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="92" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1gaf75511e781bb89056badd33413222010" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>constexpr size_t</type>
        <definition>constexpr size_t Ikarus::utils::find_if</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>find_if</name>
        <qualifiedname>Ikarus::utils::find_if</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Finds the index of the first element in the tuple satisfying a predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function to check each element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the first element satisfying the predicate. If no element satisfies the predicate, it returns the size of the tuple.</para>
</simplesect>
This function takes a tuple and a predicate function and finds the index of the first element in the tuple that satisfies the given predicate. It uses Dune::Hybrid::forEach to iterate through the tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="220" column="18" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="220" bodyend="233"/>
        <referencedby refid="a00313_1ga62d8ab565d41e49db75f0641bcdf0740" compoundref="a00047" startline="344" endline="347">findTypeSpecialization</referencedby>
        <referencedby refid="a00313_1gaec2a5de0482441ef1e1c68fb7ff8a0bc" compoundref="a00047" startline="383" endline="387">hasTypeSpecialization</referencedby>
        <referencedby refid="a00313_1ga33284bcf99d7d3870e0aff06f6651aa2" compoundref="a00047" startline="248" endline="250">none_of</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00313_1ga33284bcf99d7d3870e0aff06f6651aa2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::none_of</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>none_of</name>
        <qualifiedname>Ikarus::utils::none_of</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Checks if none of the elements in the tuple satisfy a given predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function to check each element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>bool True if none of the elements satisfy the predicate, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="248" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="248" bodyend="250"/>
        <referencedby refid="a00313_1gab6d955a70ec9215ae9a8f3841582ab49" compoundref="a00047" startline="265" endline="267">any_of</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00313_1gab6d955a70ec9215ae9a8f3841582ab49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::any_of</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>any_of</name>
        <qualifiedname>Ikarus::utils::any_of</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Checks if any of the elements in the tuple satisfy a given predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function to check each element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>bool True if any of the elements satisfy the predicate, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="265" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="265" bodyend="267"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1gad9f30d486a3d9151d534ec1b0fad5341" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::filter</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>filter</name>
        <qualifiedname>Ikarus::utils::filter</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Filters the elements of a tuple based on a given predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function to filter the elements. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto Tuple containing elements that satisfy the predicate.</para>
</simplesect>
This function applies the given predicate to each element of the tuple. It constructs a new tuple containing only those elements for which the predicate returns true. The resulting tuple is returned. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="284" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="284" bodyend="290"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1ga12de8f77a63ef488a87a5aa8536146ee" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Types</declname>
            <defname>Types</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto Ikarus::utils::unique</definition>
        <argsstring>(std::tuple&lt; Types... &gt; &amp;&amp;tuple)</argsstring>
        <name>unique</name>
        <qualifiedname>Ikarus::utils::unique</qualifiedname>
        <param>
          <type>std::tuple&lt; Types... &gt; &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <briefdescription>
<para>Creates a tuple with unique types from the given tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Types</parametername>
</parameternamelist>
<parameterdescription>
<para>Variadic template parameters representing types. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto Tuple with unique types.</para>
</simplesect>
This function takes a tuple and returns a new tuple containing only unique types from the input tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="304" column="16" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="304" bodyend="306"/>
        <referencedby refid="a00313_1ga6e36d8f5163f232e3142ecbd0575e8b4" compoundref="a00047" startline="28" endline="31">makeUniqueAndSort</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00313_1gae9a7254f583151ee431db537c9980865" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>constexpr size_t</type>
        <definition>constexpr size_t Ikarus::utils::count_if</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>count_if</name>
        <qualifiedname>Ikarus::utils::count_if</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Counts the number of elements in the tuple satisfying the given predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function determining whether an element satisfies the condition. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr size_t Number of elements satisfying the predicate.</para>
</simplesect>
This function counts the number of elements in the tuple that satisfy the given predicate. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="322" column="18" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="322" bodyend="329"/>
        <referencedby refid="a00313_1gadf919f3a9b0c1d50134f9d041a3ce9f7" compoundref="a00047" startline="401" endline="404">countTypeSpecialization</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00313_1ga62d8ab565d41e49db75f0641bcdf0740" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr int</type>
        <definition>constexpr int Ikarus::utils::findTypeSpecialization</definition>
        <argsstring>()</argsstring>
        <name>findTypeSpecialization</name>
        <qualifiedname>Ikarus::utils::findTypeSpecialization</qualifiedname>
        <briefdescription>
<para>Finds the index of the first element in the tuple that is a specialization of the given template type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to search for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the first specialization in the tuple</para>
</simplesect>
This function finds the index of the first element in the tuple that is a specialization of the given template type. It returns the size of the tuple if the template type is not found </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="344" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="344" bodyend="347"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1ga05a5ccea0f87d41fc69956f55a2c1dbd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::getSpecialization</definition>
        <argsstring>(Tuple &amp;&amp;tuple)</argsstring>
        <name>getSpecialization</name>
        <qualifiedname>Ikarus::utils::getSpecialization</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <briefdescription>
<para>Gets the specialization of the given template type from the tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to search for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>The tuple containing elements. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The specialization element</para>
</simplesect>
This function retrieves the specialization of a template type from the tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="362" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="362" bodyend="367"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1gaec2a5de0482441ef1e1c68fb7ff8a0bc" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool Ikarus::utils::hasTypeSpecialization</definition>
        <argsstring>()</argsstring>
        <name>hasTypeSpecialization</name>
        <qualifiedname>Ikarus::utils::hasTypeSpecialization</qualifiedname>
        <briefdescription>
<para>Checks if a tuple has a specialization of a template type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to check for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the tuple has the specialization; otherwise, false.</para>
</simplesect>
This function checks if a tuple has a specialization of a template type. It uses <computeroutput>find_if</computeroutput> to search for the type and returns true if the index is less than the tuple size; otherwise, false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="383" column="16" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="383" bodyend="387"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1gadf919f3a9b0c1d50134f9d041a3ce9f7" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool Ikarus::utils::countTypeSpecialization</definition>
        <argsstring>()</argsstring>
        <name>countTypeSpecialization</name>
        <qualifiedname>Ikarus::utils::countTypeSpecialization</qualifiedname>
        <briefdescription>
<para>Counts the occurrences of a specialization of a template type in a tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to count occurrences for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The count of occurrences of the specialization.</para>
</simplesect>
This function counts the occurrences of a specialization of a template type in a tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="401" column="16" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="401" bodyend="404"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1ga32de94604b9d1a7423134f33f49d613f" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>class Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto Ikarus::utils::makeTupleSubset</definition>
        <argsstring>(Tuple &amp;&amp;t)</argsstring>
        <name>makeTupleSubset</name>
        <qualifiedname>Ikarus::utils::makeTupleSubset</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Creates a subset tuple with the first N elements from the given tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements in the subset. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the original tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>The original tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new tuple containing the first N elements of the original tuple.</para>
</simplesect>
This function creates a subset tuple with the first N elements from the given tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="433" column="16" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="433" bodyend="438"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1gaef801f15c9f18ae16e4241a497c33e96" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple</type>
          </param>
          <param>
            <type>std::size_t...</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto Ikarus::utils::makeTupleFromTupleIndices</definition>
        <argsstring>(Tuple &amp;&amp;t)</argsstring>
        <name>makeTupleFromTupleIndices</name>
        <qualifiedname>Ikarus::utils::makeTupleFromTupleIndices</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Creates a new tuple using indices from the original tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the original tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices to include in the new tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>The original tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new tuple containing elements from the original tuple based on the specified indices.</para>
</simplesect>
This function creates a new tuple using indices from the original tuple. It uses <computeroutput>makeTupleFromTupleIndicesImpl</computeroutput> from the <computeroutput>Impl</computeroutput> namespace to implement the tuple creation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="454" column="16" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="454" bodyend="456"/>
      </memberdef>
      <memberdef kind="function" id="a00326_1a4c617d2458cc6d792f5ba3e6c64a0c7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Types</declname>
            <defname>Types</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::makeNestedTupleFlat</definition>
        <argsstring>(std::tuple&lt; Types... &gt;)</argsstring>
        <name>makeNestedTupleFlat</name>
        <qualifiedname>Ikarus::utils::makeNestedTupleFlat</qualifiedname>
        <param>
          <type>std::tuple&lt; Types... &gt;</type>
        </param>
        <briefdescription>
<para>Creates a flattened nested tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Types</parametername>
</parameternamelist>
<parameterdescription>
<para>Types contained in the original tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new flattened nested tuple. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="466" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="466" bodyend="468"/>
      </memberdef>
      <memberdef kind="function" id="a00326_1a162c64656f5917b717a6b44ebf4c9ebf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::makeNestedTupleFlatAndStoreReferences</definition>
        <argsstring>(Tuple &amp;&amp;tup)</argsstring>
        <name>makeNestedTupleFlatAndStoreReferences</name>
        <qualifiedname>Ikarus::utils::makeNestedTupleFlatAndStoreReferences</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tup</declname>
        </param>
        <briefdescription>
<para>Creates a flattened nested tuple and stores references. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the original tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tup</parametername>
</parameternamelist>
<parameterdescription>
<para>The original tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new tuple with stored references.</para>
</simplesect>
This function creates a flattened nested tuple and stores references. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="480" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="480" bodyend="487"/>
      </memberdef>
      <memberdef kind="function" id="a00326_1aa156028e47fc302b02a7e70dea888034" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>auto &amp;</type>
        <definition>auto &amp; Ikarus::utils::returnReferenceOrNulloptIfObjectIsNullPtr</definition>
        <argsstring>(T v)</argsstring>
        <name>returnReferenceOrNulloptIfObjectIsNullPtr</name>
        <qualifiedname>Ikarus::utils::returnReferenceOrNulloptIfObjectIsNullPtr</qualifiedname>
        <param>
          <type>T</type>
          <declname>v</declname>
        </param>
    <requiresclause>traits::Pointer&lt;T&gt;    </requiresclause>
        <briefdescription>
<para>Returns a reference or std::nullopt if the object is a nullptr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the pointer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference or std::nullopt. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="498" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="498" bodyend="503"/>
      </memberdef>
      <memberdef kind="function" id="a00311_1ga2a6c26beeb8d52283e82939ca585dc20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Fun</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Vars</declname>
            <defname>Vars</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>typename U</type>
          </param>
          <param>
            <type>typename G</type>
          </param>
          <param>
            <type>typename H</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Ikarus::utils::hessianN</definition>
        <argsstring>(const Fun &amp;f, const autodiff::Wrt&lt; Vars... &gt; &amp;wrt, const autodiff::At&lt; Args... &gt; &amp;at, U &amp;u, std::array&lt; G, U::RowsAtCompileTime &gt; &amp;g, std::array&lt; H, U::RowsAtCompileTime &gt; &amp;h)</argsstring>
        <name>hessianN</name>
        <qualifiedname>Ikarus::utils::hessianN</qualifiedname>
        <param>
          <type>const Fun &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>const autodiff::Wrt&lt; Vars... &gt; &amp;</type>
          <declname>wrt</declname>
        </param>
        <param>
          <type>const autodiff::At&lt; Args... &gt; &amp;</type>
          <declname>at</declname>
        </param>
        <param>
          <type>U &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>std::array&lt; G, U::RowsAtCompileTime &gt; &amp;</type>
          <declname>g</declname>
        </param>
        <param>
          <type>std::array&lt; H, U::RowsAtCompileTime &gt; &amp;</type>
          <declname>h</declname>
        </param>
        <briefdescription>
<para>Computes the Hessian matrix for each parameter of a given function.</para>
<para>The Hessian matrix represents the second-order partial derivatives of the function with respect to the specified variables. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function to be differentiated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Vars</parametername>
</parameternamelist>
<parameterdescription>
<para>The types of the variables with respect to which the Hessian is computed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>The types of the arguments passed to the function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>The type representing the result of the function evaluation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>G</parametername>
</parameternamelist>
<parameterdescription>
<para>The type representing the gradient of the function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>H</parametername>
</parameternamelist>
<parameterdescription>
<para>The type representing the Hessian matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be differentiated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wrt</parametername>
</parameternamelist>
<parameterdescription>
<para>The variables with respect to which the Hessian is computed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>at</parametername>
</parameternamelist>
<parameterdescription>
<para>The values at which the Hessian is evaluated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>u</parametername>
</parameternamelist>
<parameterdescription>
<para>The result of the function evaluation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of the function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>h</parametername>
</parameternamelist>
<parameterdescription>
<para>The Hessian matrix (output). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/autodiffhelper.hh" line="35" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/autodiffhelper.hh" bodystart="35" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="a00311_1ga16e7d5f51cc42190c090e727495c1609" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, decltype(Eigen::seq(0, 0))&gt;</type>
        <definition>std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, decltype(Eigen::seq(0, 0))&gt; Ikarus::utils::findLineSegment</definition>
        <argsstring>(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;y, int segmentSize)</argsstring>
        <name>findLineSegment</name>
        <qualifiedname>Ikarus::utils::findLineSegment</qualifiedname>
        <param>
          <type>const Eigen::VectorXd &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const Eigen::VectorXd &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>segmentSize</declname>
        </param>
        <briefdescription>
<para>Find a linear segment in a set of data points. </para>
        </briefdescription>
        <detaileddescription>
<para>his function is inspired by the MATLAB code at: <ulink url="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/identify_linear_piece.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/identify_linear_piece.m</ulink> It is designed to find the most linear segment in a set of data points</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The x-coordinates of the data points. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>The y-coordinates of the data points. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>segmentSize</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the line segment to be identified. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple containing the polynomial representing the identified line segment and the indices of the data points in the segment. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/findlinesegment.hh" line="28" column="12" declfile="/__w/ikarus/ikarus/repo/ikarus/utils/findlinesegment.hh" declline="28" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="a00311_1ga276a9de351512c4cacf6e09cad649265" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
          <param>
            <type>typename LocalView</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Ikarus::utils::obtainLagrangeNodePositions</definition>
        <argsstring>(const LocalView &amp;localView, std::vector&lt; Dune::FieldVector&lt; double, size &gt; &gt; &amp;lagrangeNodeCoords)</argsstring>
        <name>obtainLagrangeNodePositions</name>
        <qualifiedname>Ikarus::utils::obtainLagrangeNodePositions</qualifiedname>
        <param>
          <type>const LocalView &amp;</type>
          <declname>localView</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="a01368" kindref="compound">Dune::FieldVector</ref>&lt; double, size &gt; &gt; &amp;</type>
          <declname>lagrangeNodeCoords</declname>
        </param>
        <briefdescription>
<para>A function to obtain the global positions of the nodes of an element with Lagrangian basis, see <ref refid="a00321" kindref="compound">Dune</ref> book page 314. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the nodal coordinate vector </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>LocalView</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the local view</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>localView</parametername>
</parameternamelist>
<parameterdescription>
<para>Local view bounded to an element </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lagrangeNodeCoords</parametername>
</parameternamelist>
<parameterdescription>
<para>A vector of nodal coordinates to be updated </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" line="23" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" bodystart="23" bodyend="39"/>
      </memberdef>
      <memberdef kind="function" id="a00311_1gacb9e813539bfd84df99ad097cabc9de9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NonlinearOperator</type>
          </param>
          <param>
            <type>typename UpdateType</type>
            <defval>typename NonlinearOperator::template ParameterValue&lt;0&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::checkGradient</definition>
        <argsstring>(NonlinearOperator &amp;nonLinOp, CheckFlags checkFlags=CheckFlags(), std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt; p_updateFunction=[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;})</argsstring>
        <name>checkGradient</name>
        <qualifiedname>Ikarus::utils::checkGradient</qualifiedname>
        <param>
          <type>NonlinearOperator &amp;</type>
          <declname>nonLinOp</declname>
        </param>
        <param>
          <type><ref refid="a01524" kindref="compound">CheckFlags</ref></type>
          <declname>checkFlags</declname>
          <defval><ref refid="a01524" kindref="compound">CheckFlags</ref>()</defval>
        </param>
        <param>
          <type>std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt;</type>
          <declname>p_updateFunction</declname>
          <defval>[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;}</defval>
        </param>
        <briefdescription>
<para>Checks the gradient of a nonlinear operator. </para>
        </briefdescription>
        <detaileddescription>
<para>The checkgradient function is inspired by <ulink url="http://sma.epfl.ch/~nboumal/book/">http://sma.epfl.ch/~nboumal/book/</ulink> Chapter 4.8 and <ulink url="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m</ulink></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NonlinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UpdateType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinOp</parametername>
</parameternamelist>
<parameterdescription>
<para>The nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>checkFlags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags for the check. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p_updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the check passed, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" line="54" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" bodystart="54" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="a00311_1ga553465359c199ef676945832587d2869" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NonlinearOperator</type>
          </param>
          <param>
            <type>typename UpdateType</type>
            <defval>typename NonlinearOperator::template ParameterValue&lt;0&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::checkJacobian</definition>
        <argsstring>(NonlinearOperator &amp;nonLinOp, CheckFlags checkFlags=CheckFlags(), std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt; p_updateFunction=[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;})</argsstring>
        <name>checkJacobian</name>
        <qualifiedname>Ikarus::utils::checkJacobian</qualifiedname>
        <param>
          <type>NonlinearOperator &amp;</type>
          <declname>nonLinOp</declname>
        </param>
        <param>
          <type><ref refid="a01524" kindref="compound">CheckFlags</ref></type>
          <declname>checkFlags</declname>
          <defval><ref refid="a01524" kindref="compound">CheckFlags</ref>()</defval>
        </param>
        <param>
          <type>std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt;</type>
          <declname>p_updateFunction</declname>
          <defval>[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;}</defval>
        </param>
        <briefdescription>
<para>Checks the Jacobian of a nonlinear operator. </para>
        </briefdescription>
        <detaileddescription>
<para>The checkjacobian function is inspired by <ulink url="http://sma.epfl.ch/~nboumal/book/">http://sma.epfl.ch/~nboumal/book/</ulink> Chapter 4.8 and <ulink url="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m</ulink></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NonlinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UpdateType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinOp</parametername>
</parameternamelist>
<parameterdescription>
<para>The nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>checkFlags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags for the check. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p_updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the check passed, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" line="115" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" bodystart="115" bodyend="153"/>
      </memberdef>
      <memberdef kind="function" id="a00311_1ga5d1a87964a3d6b6ddc994532e93b6798" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NonlinearOperator</type>
          </param>
          <param>
            <type>typename UpdateType</type>
            <defval>typename NonlinearOperator::template ParameterValue&lt;0&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::checkHessian</definition>
        <argsstring>(NonlinearOperator &amp;nonLinOp, CheckFlags checkFlags=CheckFlags(), std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt; p_updateFunction=[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;})</argsstring>
        <name>checkHessian</name>
        <qualifiedname>Ikarus::utils::checkHessian</qualifiedname>
        <param>
          <type>NonlinearOperator &amp;</type>
          <declname>nonLinOp</declname>
        </param>
        <param>
          <type><ref refid="a01524" kindref="compound">CheckFlags</ref></type>
          <declname>checkFlags</declname>
          <defval><ref refid="a01524" kindref="compound">CheckFlags</ref>()</defval>
        </param>
        <param>
          <type>std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt;</type>
          <declname>p_updateFunction</declname>
          <defval>[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;}</defval>
        </param>
        <briefdescription>
<para>Checks the Hessian of a nonlinear operator. </para>
        </briefdescription>
        <detaileddescription>
<para>The checkHessian function is inspired by <ulink url="http://sma.epfl.ch/~nboumal/book/">http://sma.epfl.ch/~nboumal/book/</ulink> Chapter 6.8 and <ulink url="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkhessian.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkhessian.m</ulink></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NonlinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UpdateType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinOp</parametername>
</parameternamelist>
<parameterdescription>
<para>The nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>checkFlags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags for the check. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p_updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the check passed, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" line="168" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" bodystart="168" bodyend="216"/>
      </memberdef>
      <memberdef kind="function" id="a00311_1ga0d3a38551806e4de3ff44f311847ba51" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, double &gt;</type>
        <definition>std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, double &gt; Ikarus::utils::polyfit</definition>
        <argsstring>(const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;y, int deg)</argsstring>
        <name>polyfit</name>
        <qualifiedname>Ikarus::utils::polyfit</qualifiedname>
        <param>
          <type>const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>deg</declname>
        </param>
        <briefdescription>
<para>Fits a polynomial of a given degree to the given data points. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input vector of x-coordinates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>The input vector of y-coordinates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>deg</parametername>
</parameternamelist>
<parameterdescription>
<para>The degree of the polynomial to fit. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;Dune::Functions::Polynomial&lt;double&gt;, double&gt; A tuple containing the fitted polynomial and the least square error. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/polyfit.hh" line="24" column="12" declfile="/__w/ikarus/ikarus/repo/ikarus/utils/polyfit.hh" declline="24" declcolumn="12"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="17" column="1"/>
  </compounddef>
</doxygen>
