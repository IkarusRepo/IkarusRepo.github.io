<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.4" xml:lang="en-US">
  <compounddef id="a00325" kind="namespace" language="C++">
    <compoundname>Ikarus</compoundname>
    <innerclass refid="a01234" prot="public">Ikarus::AffordanceCollectionImpl</innerclass>
    <innerclass refid="a01438" prot="public">Ikarus::AlgoInfo</innerclass>
    <innerclass refid="a01210" prot="public">Ikarus::ArcLength</innerclass>
    <innerclass refid="a01222" prot="public">Ikarus::AutoDiffFE</innerclass>
    <innerclass refid="a01458" prot="public">Ikarus::Basis</innerclass>
    <innerclass refid="a01358" prot="public">Ikarus::BulkModulusAndLamesFirstParameter</innerclass>
    <innerclass refid="a01194" prot="public">Ikarus::ControlInformation</innerclass>
    <innerclass refid="a01550" prot="public">Ikarus::ControlLogger</innerclass>
    <innerclass refid="a01554" prot="public">Ikarus::ControlSubsamplingVertexVTKWriter</innerclass>
    <innerclass refid="a01366" prot="public">Ikarus::ConvertLameConstants</innerclass>
    <innerclass refid="a01334" prot="public">Ikarus::DefaultMembraneStrain</innerclass>
    <innerclass refid="a01182" prot="public">Ikarus::DenseFlatAssembler</innerclass>
    <innerclass refid="a01494" prot="public">Ikarus::DirichletValues</innerclass>
    <innerclass refid="a01218" prot="public">Ikarus::DisplacementControl</innerclass>
    <innerclass refid="a01286" prot="public">Ikarus::EnhancedAssumedStrains</innerclass>
    <innerclass refid="a01250" prot="public">Ikarus::FERequirements</innerclass>
    <innerclass refid="a01254" prot="public">Ikarus::FErequirements</innerclass>
    <innerclass refid="a01258" prot="public">Ikarus::FETraits</innerclass>
    <innerclass refid="a01166" prot="public">Ikarus::FlatAssemblerBase</innerclass>
    <innerclass refid="a01506" prot="public">Ikarus::FlatIndexMergingStrategy</innerclass>
    <innerclass refid="a01510" prot="public">Ikarus::FlatIndexMergingStrategy&lt; Dune::Functions::BasisFactory::BlockedInterleaved &gt;</innerclass>
    <innerclass refid="a01514" prot="public">Ikarus::FlatIndexMergingStrategy&lt; Dune::Functions::BasisFactory::BlockedLexicographic &gt;</innerclass>
    <innerclass refid="a01502" prot="public">Ikarus::FlatPreBasis</innerclass>
    <innerclass refid="a01518" prot="public">Ikarus::FlatPreBasis&lt; Dune::Functions::CompositePreBasis&lt; IMS, SPB... &gt; &gt;</innerclass>
    <innerclass refid="a01522" prot="public">Ikarus::FlatPreBasis&lt; Dune::Functions::PowerPreBasis&lt; IMS, SPB, C &gt; &gt;</innerclass>
    <innerclass refid="a01558" prot="public">Ikarus::GenericObserver</innerclass>
    <innerclass refid="a01530" prot="public">Ikarus::IkarusInstance</innerclass>
    <innerclass refid="a01570" prot="public">Ikarus::IObservable</innerclass>
    <innerclass refid="a01566" prot="public">Ikarus::IObserver</innerclass>
    <innerclass refid="a01290" prot="public">Ikarus::KirchhoffLoveShell</innerclass>
    <innerclass refid="a01362" prot="public">Ikarus::LamesFirstParameterAndShearModulus</innerclass>
    <innerclass refid="a01298" prot="public">Ikarus::LinearElastic</innerclass>
    <innerclass refid="a01314" prot="public">Ikarus::LinearElasticityT</innerclass>
    <innerclass refid="a01402" prot="public">Ikarus::LinearSolverTemplate</innerclass>
    <innerclass refid="a01198" prot="public">Ikarus::LoadControl</innerclass>
    <innerclass refid="a01214" prot="public">Ikarus::LoadControlSubsidiaryFunction</innerclass>
    <innerclass refid="a01310" prot="public">Ikarus::Material</innerclass>
    <innerclass refid="a01318" prot="public">Ikarus::NeoHookeT</innerclass>
    <innerclass refid="a01418" prot="public">Ikarus::NewtonRaphson</innerclass>
    <innerclass refid="a01414" prot="public">Ikarus::NewtonRaphsonSettings</innerclass>
    <innerclass refid="a01426" prot="public">Ikarus::NewtonRaphsonWithSubsidiaryFunction</innerclass>
    <innerclass refid="a01422" prot="public">Ikarus::NewtonRaphsonWithSubsidiaryFunctionSettings</innerclass>
    <innerclass refid="a01338" prot="public">Ikarus::NonLinearElastic</innerclass>
    <innerclass refid="a01542" prot="public">Ikarus::NonLinearOperator</innerclass>
    <innerclass refid="a01430" prot="public">Ikarus::NonLinearSolverInformation</innerclass>
    <innerclass refid="a01562" prot="public">Ikarus::NonLinearSolverLogger</innerclass>
    <innerclass refid="a01202" prot="public">Ikarus::PathFollowing</innerclass>
    <innerclass refid="a01226" prot="public">Ikarus::PowerBasisFE</innerclass>
    <innerclass refid="a01386" prot="public">Ikarus::ResultFunction</innerclass>
    <innerclass refid="a01170" prot="public">Ikarus::ScalarAssembler</innerclass>
    <innerclass refid="a01230" prot="public">Ikarus::ScalarFieldFE</innerclass>
    <innerclass refid="a01178" prot="public">Ikarus::SparseFlatAssembler</innerclass>
    <innerclass refid="a01442" prot="public">Ikarus::Stats</innerclass>
    <innerclass refid="a01322" prot="public">Ikarus::StVenantKirchhoffT</innerclass>
    <innerclass refid="a01206" prot="public">Ikarus::SubsidiaryArgs</innerclass>
    <innerclass refid="a01302" prot="public">Ikarus::Traction</innerclass>
    <innerclass refid="a01446" prot="public">Ikarus::TrustRegion</innerclass>
    <innerclass refid="a01434" prot="public">Ikarus::TrustRegionSettings</innerclass>
    <innerclass refid="a01330" prot="public">Ikarus::VanishingStress</innerclass>
    <innerclass refid="a01174" prot="public">Ikarus::VectorFlatAssembler</innerclass>
    <innerclass refid="a01306" prot="public">Ikarus::Volume</innerclass>
    <innerclass refid="a01350" prot="public">Ikarus::YoungsModulusAndBulkModulus</innerclass>
    <innerclass refid="a01354" prot="public">Ikarus::YoungsModulusAndLamesFirstParameter</innerclass>
    <innerclass refid="a01342" prot="public">Ikarus::YoungsModulusAndPoissonsRatio</innerclass>
    <innerclass refid="a01346" prot="public">Ikarus::YoungsModulusAndShearModulus</innerclass>
    <innernamespace refid="a00326">Ikarus::AdaptiveStepSizing</innernamespace>
    <innernamespace refid="a00329">Ikarus::AffordanceCollections</innernamespace>
    <innernamespace refid="a00338">Ikarus::Concepts</innernamespace>
    <innernamespace refid="a00330">Ikarus::EAS</innernamespace>
    <innernamespace refid="a00328">Ikarus::FEHelper</innernamespace>
    <innernamespace refid="a00340">Ikarus::plot</innernamespace>
    <innernamespace refid="a00335">Ikarus::Python</innernamespace>
    <innernamespace refid="a00332">Ikarus::ResultEvaluators</innernamespace>
    <innernamespace refid="a00342">Ikarus::traits</innernamespace>
    <innernamespace refid="a00336">Ikarus::utils</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="a00311_1ga8a33210894e12be4feb3d96fdfde215c" prot="public" static="no" strong="yes">
        <type></type>
        <name>ScalarAffordances</name>
        <qualifiedname>Ikarus::ScalarAffordances</qualifiedname>
        <enumvalue id="a00311_1gga8a33210894e12be4feb3d96fdfde215ca19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga8a33210894e12be4feb3d96fdfde215ca9a280b29988e2eac8c0767e0fcefb49c" prot="public">
          <name>noAffordance</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga8a33210894e12be4feb3d96fdfde215ca814f34f472acef493e9ecf0ffccdcae6" prot="public">
          <name>mechanicalPotentialEnergy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga8a33210894e12be4feb3d96fdfde215cae45c0886135e58c01a313bda2d69e29a" prot="public">
          <name>microMagneticPotentialEnergy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga8a33210894e12be4feb3d96fdfde215cab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the scalar affordance. </para>
        </briefdescription>
        <detaileddescription>
<para>ScalarAffordances </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="34" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="34" bodyend="34"/>
      </memberdef>
      <memberdef kind="enum" id="a00311_1ga122268ff4d2c0beee58799d85ba5e52a" prot="public" static="no" strong="yes">
        <type></type>
        <name>VectorAffordances</name>
        <qualifiedname>Ikarus::VectorAffordances</qualifiedname>
        <enumvalue id="a00311_1gga122268ff4d2c0beee58799d85ba5e52aa19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga122268ff4d2c0beee58799d85ba5e52aa9a280b29988e2eac8c0767e0fcefb49c" prot="public">
          <name>noAffordance</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga122268ff4d2c0beee58799d85ba5e52aa2c05161a7e67e946ddc889571aac4e89" prot="public">
          <name>forces</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga122268ff4d2c0beee58799d85ba5e52aa3cc975e7798ac76d6af4f624e23c6ddc" prot="public">
          <name>microMagneticForces</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga122268ff4d2c0beee58799d85ba5e52aab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the vector affordance. </para>
        </briefdescription>
        <detaileddescription>
<para>VectorAffordances </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="45" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="45" bodyend="45"/>
      </memberdef>
      <memberdef kind="enum" id="a00311_1ga52cb89165daabb500f6e2eb68ddd76ee" prot="public" static="no" strong="yes">
        <type></type>
        <name>MatrixAffordances</name>
        <qualifiedname>Ikarus::MatrixAffordances</qualifiedname>
        <enumvalue id="a00311_1gga52cb89165daabb500f6e2eb68ddd76eea19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga52cb89165daabb500f6e2eb68ddd76eea9a280b29988e2eac8c0767e0fcefb49c" prot="public">
          <name>noAffordance</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga52cb89165daabb500f6e2eb68ddd76eea086e8b527490b8abe606a8dd76586ab1" prot="public">
          <name>stiffness</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga52cb89165daabb500f6e2eb68ddd76eea3a130b44dd6ff9351e7734ac33096b62" prot="public">
          <name>materialstiffness</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga52cb89165daabb500f6e2eb68ddd76eeae15aaa3bcdfc63653ecc7de3f1d4794b" prot="public">
          <name>geometricstiffness</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga52cb89165daabb500f6e2eb68ddd76eeadaa7ff7d704732b763943e3355764532" prot="public">
          <name>stiffnessdiffBucklingVector</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga52cb89165daabb500f6e2eb68ddd76eea1b0fce0a361af9d6e59694b4c51524f9" prot="public">
          <name>microMagneticHessian</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga52cb89165daabb500f6e2eb68ddd76eead90ccffa01275a7a7795fb6d1274e75f" prot="public">
          <name>mass</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00311_1gga52cb89165daabb500f6e2eb68ddd76eeab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the matrix affordance. </para>
        </briefdescription>
        <detaileddescription>
<para>MatrixAffordances </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="60" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="60" bodyend="60"/>
      </memberdef>
      <memberdef kind="enum" id="a00312_1ga0c1577fd05efee8475b0f7fef795bbbe" prot="public" static="no" strong="yes">
        <type></type>
        <name>FEParameter</name>
        <qualifiedname>Ikarus::FEParameter</qualifiedname>
        <enumvalue id="a00312_1gga0c1577fd05efee8475b0f7fef795bbbea19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga0c1577fd05efee8475b0f7fef795bbbea298c62e2f9918b280f40eb210c44fdbe" prot="public">
          <name>noParameter</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga0c1577fd05efee8475b0f7fef795bbbeaf72bac0ac84c0315e7bcbb8aa84b2ff8" prot="public">
          <name>loadfactor</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga0c1577fd05efee8475b0f7fef795bbbea07cc694b9b3fc636710fa08b6922c42b" prot="public">
          <name>time</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga0c1577fd05efee8475b0f7fef795bbbeab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the FE parameter. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="71" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="71" bodyend="71"/>
      </memberdef>
      <memberdef kind="enum" id="a00312_1gaea763c94a1cecbeefc4f8661debcc5a3" prot="public" static="no" strong="yes">
        <type></type>
        <name>FESolutions</name>
        <qualifiedname>Ikarus::FESolutions</qualifiedname>
        <enumvalue id="a00312_1ggaea763c94a1cecbeefc4f8661debcc5a3a19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1ggaea763c94a1cecbeefc4f8661debcc5a3a2100a151ce2773b3467509ae085aa505" prot="public">
          <name>noSolution</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1ggaea763c94a1cecbeefc4f8661debcc5a3a0c2d35f5f278a229db5ba41d40120f1c" prot="public">
          <name>displacement</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1ggaea763c94a1cecbeefc4f8661debcc5a3aac1a453d0cdc1f19d9479ccfaa8b082c" prot="public">
          <name>velocity</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1ggaea763c94a1cecbeefc4f8661debcc5a3a3d4e992d8d8a7d848724aa26ed7f4176" prot="public">
          <name>director</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1ggaea763c94a1cecbeefc4f8661debcc5a3a58edccca94b76e0355ed45da28ece7ff" prot="public">
          <name>magnetizationAndVectorPotential</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1ggaea763c94a1cecbeefc4f8661debcc5a3ab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the solutions vectors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="84" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="84" bodyend="84"/>
      </memberdef>
      <memberdef kind="enum" id="a00312_1ga531be167e924b749eb8b4ccc7f1c18c9" prot="public" static="no" strong="yes">
        <type></type>
        <name>ResultType</name>
        <qualifiedname>Ikarus::ResultType</qualifiedname>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9a19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9ad2859ebb97e0012ad38b47dca4f85713" prot="public">
          <name>noType</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9ae32847e757c83ed980680fa215e356f7" prot="public">
          <name>magnetization</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9a92145c4b71bfe6ec078933e495fccd77" prot="public">
          <name>gradientNormOfMagnetization</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9a0b3e1fbd405fc1a6535e5514b0ba70a7" prot="public">
          <name>vectorPotential</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9a8475b505cc04610acbb7381506b3e65d" prot="public">
          <name>divergenceOfVectorPotential</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9a4c7528492cfffa1e4a34304fe5710566" prot="public">
          <name>BField</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9a1183c16939e5fc77a54cda60df89ec2f" prot="public">
          <name>HField</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9a823b6a2b943cfaf747fe3b45bd1a5f02" prot="public">
          <name>cauchyStress</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9afa06a140291f2b4bc25c81e5e6bac241" prot="public">
          <name>PK2Stress</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9ad8cbb8fe32024cc3f1376a24d27aeae7" prot="public">
          <name>linearStress</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9a3d4e992d8d8a7d848724aa26ed7f4176" prot="public">
          <name>director</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00312_1gga531be167e924b749eb8b4ccc7f1c18c9ab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the result request. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="103" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="103" bodyend="103"/>
      </memberdef>
      <memberdef kind="enum" id="a00314_1gacef1e451de1a99845c59d7391064fb8f" prot="public" static="no" strong="yes">
        <type></type>
        <name>StrainTags</name>
        <qualifiedname>Ikarus::StrainTags</qualifiedname>
        <enumvalue id="a00314_1ggacef1e451de1a99845c59d7391064fb8fa19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1ggacef1e451de1a99845c59d7391064fb8fa9a932b3cb396238423eb2f33ec17d6aa" prot="public">
          <name>linear</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1ggacef1e451de1a99845c59d7391064fb8fa61fc106262d2e2049866894bb4f862a5" prot="public">
          <name>deformationGradient</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1ggacef1e451de1a99845c59d7391064fb8fa0eb1f1f7a6a355c2f4260b74c21d80f3" prot="public">
          <name>displacementGradient</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1ggacef1e451de1a99845c59d7391064fb8faca3f1e4bb21fd00a3d29c5d8aff8e11e" prot="public">
          <name>greenLagrangian</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1ggacef1e451de1a99845c59d7391064fb8faea40a9960a7a89c4f366beeab85d07d2" prot="public">
          <name>rightCauchyGreenTensor</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1ggacef1e451de1a99845c59d7391064fb8fab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the passed strain. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="19" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="19" bodyend="19"/>
      </memberdef>
      <memberdef kind="enum" id="a00314_1ga70b4ce43c53cc5e949d49919f437501e" prot="public" static="no" strong="yes">
        <type></type>
        <name>StressTags</name>
        <qualifiedname>Ikarus::StressTags</qualifiedname>
        <enumvalue id="a00314_1gga70b4ce43c53cc5e949d49919f437501ea19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga70b4ce43c53cc5e949d49919f437501ea9a932b3cb396238423eb2f33ec17d6aa" prot="public">
          <name>linear</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga70b4ce43c53cc5e949d49919f437501eab13248d68ac5516c015337b68346fc21" prot="public">
          <name>PK2</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga70b4ce43c53cc5e949d49919f437501eac34dd77ffb9238275b93ea1897664a7e" prot="public">
          <name>PK1</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga70b4ce43c53cc5e949d49919f437501ea2ee21c55474972b3e65b31a6b0b57dc8" prot="public">
          <name>Cauchy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga70b4ce43c53cc5e949d49919f437501eadb46969ba633ea08a9181d8eb6218ba9" prot="public">
          <name>Kirchhoff</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga70b4ce43c53cc5e949d49919f437501eab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the computed stresses. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="26" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="26" bodyend="26"/>
      </memberdef>
      <memberdef kind="enum" id="a00314_1ga05ac785124262c1e323d2f937d520a1b" prot="public" static="no" strong="yes">
        <type></type>
        <name>TangentModuliTags</name>
        <qualifiedname>Ikarus::TangentModuliTags</qualifiedname>
        <enumvalue id="a00314_1gga05ac785124262c1e323d2f937d520a1ba19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga05ac785124262c1e323d2f937d520a1bad92a8333dd3ccb895cc65f7455b71206" prot="public">
          <name>Material</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga05ac785124262c1e323d2f937d520a1ba33d7f1ec5fe18e7ba799474138e71504" prot="public">
          <name>Spatial</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga05ac785124262c1e323d2f937d520a1ba331d16a2885c7f82ba949f286f48143d" prot="public">
          <name>TwoPoint</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00314_1gga05ac785124262c1e323d2f937d520a1bab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the computed tangent moduli. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="33" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="33" bodyend="33"/>
      </memberdef>
      <memberdef kind="enum" id="a00325_1a731a9ee6621f91193c15f31b9a399906" prot="public" static="no" strong="yes">
        <type></type>
        <name>SolverTypeTag</name>
        <qualifiedname>Ikarus::SolverTypeTag</qualifiedname>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a334c4a4c42fdb79d7ebc3e73b517e6f8" prot="public">
          <name>none</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a43e7ad1498548ecfbe9359418877c793" prot="public">
          <name>si_ConjugateGradient</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a64a3b585d23ed07479c1452d49f397bb" prot="public">
          <name>si_LeastSquaresConjugateGradient</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a3ba09bd833aa666cbeca9bfd4a33be6f" prot="public">
          <name>si_BiCGSTAB</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906acd4c06ca3bfe2246c9ec45bee84b5852" prot="public">
          <name>sd_SimplicialLLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906af493d8a2d2d89f06181e77bc79cabf1c" prot="public">
          <name>sd_SimplicialLDLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906ae7cfd15be408672026faa788c0c112e5" prot="public">
          <name>sd_SparseLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a259246f1b3299da36945e32f5660bebd" prot="public">
          <name>sd_SparseQR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a286dc99776bcd1ea313e669aa17b3236" prot="public">
          <name>sd_CholmodSupernodalLLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906afe6a46ed15566813699daa9c9cbf85d5" prot="public">
          <name>sd_UmfPackLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906aa8fe11042608f12d110c154033361fcc" prot="public">
          <name>sd_SuperLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a97eafebe024f68db956c95519ddf66f2" prot="public">
          <name>d_PartialPivLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a4c20d1c5006d9987b894313a4af5de6e" prot="public">
          <name>d_FullPivLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a290d38c1d75cda978733c7ee8266e16e" prot="public">
          <name>d_HouseholderQR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906af66de0478863779eca4d9e7dcf39c59a" prot="public">
          <name>d_ColPivHouseholderQR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a9be60de1df84a8b371f0ad372aba4582" prot="public">
          <name>d_FullPivHouseholderQR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906ae1f5f0486da0c6645a75c3df39d8d942" prot="public">
          <name>d_CompleteOrthogonalDecomposition</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906a40c05e324bcfe6242fddbef28720e86a" prot="public">
          <name>d_LLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a731a9ee6621f91193c15f31b9a399906ad495de2cc8831501954c24afe8688190" prot="public">
          <name>d_LDLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration representing different solver types. </para>
        </briefdescription>
        <detaileddescription>
<para>The prefix s and d stand for sparse and dense solvers and the second prefix i and d stand for iterative or direct solvers for the sparse case </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" line="27" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" bodystart="28" bodyend="48"/>
      </memberdef>
      <memberdef kind="enum" id="a00325_1a4763ca5888a027ed9b8d965d67cbb9ab" prot="public" static="no" strong="yes">
        <type></type>
        <name>MatrixTypeTag</name>
        <qualifiedname>Ikarus::MatrixTypeTag</qualifiedname>
        <enumvalue id="a00325_1a4763ca5888a027ed9b8d965d67cbb9aba9a71a13863c84ba34fc41595fc2ee0c6" prot="public">
          <name>Dense</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1a4763ca5888a027ed9b8d965d67cbb9aba7407fb7e6a4df6392aaabd2368157312" prot="public">
          <name>Sparse</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration representing different matrix types (Dense or Sparse). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" line="54" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" bodystart="55" bodyend="58"/>
      </memberdef>
      <memberdef kind="enum" id="a00325_1ace28d4868cfc647491f7938f04ef6c66" prot="public" static="no" strong="yes">
        <type></type>
        <name>PreConditioner</name>
        <qualifiedname>Ikarus::PreConditioner</qualifiedname>
        <enumvalue id="a00325_1ace28d4868cfc647491f7938f04ef6c66a7a24b184ba388b8e327feb98dbe168ff" prot="public">
          <name>IncompleteCholesky</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1ace28d4868cfc647491f7938f04ef6c66a7a93111b975ec3c3824eab230f3ec608" prot="public">
          <name>IdentityPreconditioner</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1ace28d4868cfc647491f7938f04ef6c66a3c6b5404db3b7bf45a0302f376a53afc" prot="public">
          <name>DiagonalPreconditioner</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration of available preconditioners for the trust region solver. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" line="33" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" bodystart="34" bodyend="38"/>
      </memberdef>
      <memberdef kind="enum" id="a00325_1abd5d0cf356d1ae81f6ee827b0f47c674" prot="public" static="no" strong="yes">
        <type></type>
        <name>StopReason</name>
        <qualifiedname>Ikarus::StopReason</qualifiedname>
        <enumvalue id="a00325_1abd5d0cf356d1ae81f6ee827b0f47c674a0c4f44592a7ae85baf42cb3fb4a5a3d1" prot="public">
          <name>gradientNormTolReached</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1abd5d0cf356d1ae81f6ee827b0f47c674ad1c6a6016de417acc66b5ac44a1fdca3" prot="public">
          <name>correctionNormTolReached</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1abd5d0cf356d1ae81f6ee827b0f47c674ad205528fe2a4412b89626ff7eee936f9" prot="public">
          <name>maximumTimeReached</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1abd5d0cf356d1ae81f6ee827b0f47c674a5ed07f9461b91dd3a6ba961a0ed5c8fe" prot="public">
          <name>maximumIterationsReached</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00325_1abd5d0cf356d1ae81f6ee827b0f47c674a8d2fa9685be8b8f8994bd8a73bfa8c9f" prot="public">
          <name>dontStop</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration of reasons for stopping the <ref refid="a01446" kindref="compound">TrustRegion</ref> solver. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" line="63" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" bodystart="64" bodyend="70"/>
      </memberdef>
      <memberdef kind="enum" id="a00319_1ga35fa62fd2d4186a9750af3d0692f2893" prot="public" static="no" strong="yes">
        <type></type>
        <name>ControlMessages</name>
        <qualifiedname>Ikarus::ControlMessages</qualifiedname>
        <enumvalue id="a00319_1gga35fa62fd2d4186a9750af3d0692f2893a19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga35fa62fd2d4186a9750af3d0692f2893a3fbccdb8d4ddfe10b3c9ee45ed07aad0" prot="public">
          <name>CONTROL_STARTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga35fa62fd2d4186a9750af3d0692f2893a1c32d268de88f801deb25166d98a3938" prot="public">
          <name>CONTROL_ENDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga35fa62fd2d4186a9750af3d0692f2893a18e0c9ecde68d13f1d2608dd1a180945" prot="public">
          <name>STEP_STARTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga35fa62fd2d4186a9750af3d0692f2893ae2b2386af3d7379bd2ddde735d5867b2" prot="public">
          <name>STEP_ENDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga35fa62fd2d4186a9750af3d0692f2893a0d30d757bf062e88728ebe7f8e2b2577" prot="public">
          <name>SOLUTION_CHANGED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga35fa62fd2d4186a9750af3d0692f2893ab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enum class defining control-routine-related messages. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/observer/observermessages.hh" line="16" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/observer/observermessages.hh" bodystart="17" bodyend="25"/>
      </memberdef>
      <memberdef kind="enum" id="a00319_1ga662b2b6a80547adf4b9ce8b30d87fab5" prot="public" static="no" strong="yes">
        <type></type>
        <name>NonLinearSolverMessages</name>
        <qualifiedname>Ikarus::NonLinearSolverMessages</qualifiedname>
        <enumvalue id="a00319_1gga662b2b6a80547adf4b9ce8b30d87fab5a19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga662b2b6a80547adf4b9ce8b30d87fab5afaee4ca3c30ee18148ce3ada37466498" prot="public">
          <name>INIT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga662b2b6a80547adf4b9ce8b30d87fab5afdb2cb9832d112cd92fb2cda8879c3b4" prot="public">
          <name>ITERATION_STARTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga662b2b6a80547adf4b9ce8b30d87fab5a073d71a89cce6d4b9775987fdbb22815" prot="public">
          <name>ITERATION_ENDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga662b2b6a80547adf4b9ce8b30d87fab5a721c68980ba6c47122945477a56d7a14" prot="public">
          <name>RESIDUALNORM_UPDATED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga662b2b6a80547adf4b9ce8b30d87fab5a07a63a77745ab72a7e89fb22a8bcfd78" prot="public">
          <name>CORRECTIONNORM_UPDATED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga662b2b6a80547adf4b9ce8b30d87fab5a0d30d757bf062e88728ebe7f8e2b2577" prot="public">
          <name>SOLUTION_CHANGED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga662b2b6a80547adf4b9ce8b30d87fab5a15380ac35d47cdbcbd64aada4bc21931" prot="public">
          <name>FINISHED_SUCESSFULLY</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00319_1gga662b2b6a80547adf4b9ce8b30d87fab5ab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enum class defining non-linear solver-related messages. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/observer/observermessages.hh" line="31" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/observer/observermessages.hh" bodystart="32" bodyend="42"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="a00325_1a5b06e456a4b64c291dedbcf428026ba7" prot="public" static="no">
        <type><ref refid="a01314" kindref="compound">LinearElasticityT</ref>&lt; double &gt;</type>
        <definition>using Ikarus::LinearElasticity = typedef LinearElasticityT&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>LinearElasticity</name>
        <qualifiedname>Ikarus::LinearElasticity</qualifiedname>
        <briefdescription>
<para>Convenience typedef for LinearElasticity with double as ScalarType. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/linearelasticity.hh" line="128" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/linearelasticity.hh" bodystart="128" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="a00325_1ab764233e8704d8d4462d202a362892c8" prot="public" static="no">
        <type><ref refid="a01318" kindref="compound">NeoHookeT</ref>&lt; double &gt;</type>
        <definition>using Ikarus::NeoHooke = typedef NeoHookeT&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>NeoHooke</name>
        <qualifiedname>Ikarus::NeoHooke</qualifiedname>
        <briefdescription>
<para>Alias for <ref refid="a01318" kindref="compound">NeoHookeT</ref> with double as the default scalar type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/neohooke.hh" line="143" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/neohooke.hh" bodystart="143" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="a00325_1a965823ec0538ab6b5bdf7f69c33f3910" prot="public" static="no">
        <type><ref refid="a01322" kindref="compound">StVenantKirchhoffT</ref>&lt; double &gt;</type>
        <definition>using Ikarus::StVenantKirchhoff = typedef StVenantKirchhoffT&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>StVenantKirchhoff</name>
        <qualifiedname>Ikarus::StVenantKirchhoff</qualifiedname>
        <briefdescription>
<para>Alias for <ref refid="a01322" kindref="compound">StVenantKirchhoffT</ref> with double as the default scalar type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/svk.hh" line="177" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/svk.hh" bodystart="177" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="a00325_1a2afda25e777ed3a794da319ba535b87b" prot="public" static="no">
        <type><ref refid="a01402" kindref="compound">LinearSolverTemplate</ref>&lt; double &gt;</type>
        <definition>using Ikarus::LinearSolver = typedef LinearSolverTemplate&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>LinearSolver</name>
        <qualifiedname>Ikarus::LinearSolver</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" line="245" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" bodystart="245" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="a00325_1a98cbe3aef4b3238ea7de77ee9c4c19ac" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class PreBasis</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="a01502" kindref="compound">FlatPreBasis</ref>&lt; PreBasis &gt;::type</type>
        <definition>using Ikarus::FlatPreBasis_t = typedef typename FlatPreBasis&lt;PreBasis&gt;::type</definition>
        <argsstring></argsstring>
        <name>FlatPreBasis_t</name>
        <qualifiedname>Ikarus::FlatPreBasis_t</qualifiedname>
        <briefdescription>
<para>Type alias for flatted PreBasis. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" line="53" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" bodystart="53" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="a00325_1a8d0ca59930b7ae15351497bd14319d1d" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00311_1ga122268ff4d2c0beee58799d85ba5e52a" kindref="member">VectorAffordances</ref></type>
        <definition>constexpr VectorAffordances Ikarus::forces</definition>
        <argsstring></argsstring>
        <name>forces</name>
        <qualifiedname>Ikarus::forces</qualifiedname>
        <initializer>= VectorAffordances::forces</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="126" column="36" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="126" bodyend="-1"/>
        <referencedby refid="a00281_1a0e4f7cface71bec1c24bbed3aaa798d8" compoundref="a00281" startline="35" endline="139">PYBIND11_MODULE</referencedby>
      </memberdef>
      <memberdef kind="variable" id="a00325_1a5185740b975fb7539a6e07553a061b26" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00311_1ga52cb89165daabb500f6e2eb68ddd76ee" kindref="member">MatrixAffordances</ref></type>
        <definition>constexpr MatrixAffordances Ikarus::stiffness</definition>
        <argsstring></argsstring>
        <name>stiffness</name>
        <qualifiedname>Ikarus::stiffness</qualifiedname>
        <initializer>= MatrixAffordances::stiffness</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="128" column="36" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="128" bodyend="-1"/>
        <referencedby refid="a00281_1a0e4f7cface71bec1c24bbed3aaa798d8" compoundref="a00281" startline="35" endline="139">PYBIND11_MODULE</referencedby>
      </memberdef>
      <memberdef kind="variable" id="a00325_1a8191d0e317e1bea2a35d6c8a8f20750f" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00311_1ga52cb89165daabb500f6e2eb68ddd76ee" kindref="member">MatrixAffordances</ref></type>
        <definition>constexpr MatrixAffordances Ikarus::stiffnessdiffBucklingVector</definition>
        <argsstring></argsstring>
        <name>stiffnessdiffBucklingVector</name>
        <qualifiedname>Ikarus::stiffnessdiffBucklingVector</qualifiedname>
        <initializer>= MatrixAffordances::stiffnessdiffBucklingVector</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="129" column="36" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="129" bodyend="-1"/>
        <referencedby refid="a00281_1a0e4f7cface71bec1c24bbed3aaa798d8" compoundref="a00281" startline="35" endline="139">PYBIND11_MODULE</referencedby>
      </memberdef>
      <memberdef kind="variable" id="a00325_1a7e05e861b25ca636c1ccba4b8d2a3831" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00311_1ga52cb89165daabb500f6e2eb68ddd76ee" kindref="member">MatrixAffordances</ref></type>
        <definition>constexpr MatrixAffordances Ikarus::mass</definition>
        <argsstring></argsstring>
        <name>mass</name>
        <qualifiedname>Ikarus::mass</qualifiedname>
        <initializer>= MatrixAffordances::mass</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="130" column="36" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="130" bodyend="-1"/>
        <referencedby refid="a00281_1a0e4f7cface71bec1c24bbed3aaa798d8" compoundref="a00281" startline="35" endline="139">PYBIND11_MODULE</referencedby>
      </memberdef>
      <memberdef kind="variable" id="a00325_1a64dfa264a039267932c6c99eb66ae98e" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00311_1ga8a33210894e12be4feb3d96fdfde215c" kindref="member">ScalarAffordances</ref></type>
        <definition>constexpr ScalarAffordances Ikarus::potentialEnergy</definition>
        <argsstring></argsstring>
        <name>potentialEnergy</name>
        <qualifiedname>Ikarus::potentialEnergy</qualifiedname>
        <initializer>= <ref refid="a00311_1gga8a33210894e12be4feb3d96fdfde215ca814f34f472acef493e9ecf0ffccdcae6" kindref="member">ScalarAffordances::mechanicalPotentialEnergy</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="132" column="36" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="132" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="a00320_1ga8bdeefaffd49685e7dcd89f34af51d76" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto Ikarus::voigtNotationContainer</definition>
        <argsstring></argsstring>
        <name>voigtNotationContainer</name>
        <qualifiedname>Ikarus::voigtNotationContainer</qualifiedname>
        <initializer>= std::get&lt;dim - 1&gt;(Impl::voigtIndices)</initializer>
        <briefdescription>
<para>Container for Voigt notation indices based on dimension.</para>
<para>1D: 0,0 2D: 0,0; 1,1; 0,1 3D: 0,0; 1,1; 2,2; 1,2; 0,2; 0,1. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>The dimension for which Voigt indices are needed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="483" column="16" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="483" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="a00325_1a0853622412d4cedc078b81ba454eb250" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(ScalarAffordances _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00311_1ga8a33210894e12be4feb3d96fdfde215c" kindref="member">ScalarAffordances</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="34" column="55" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="34" bodyend="34"/>
        <referencedby refid="a01250_1a6a1c765d729145258fab79b29f20450c" compoundref="a00206" startline="240" endline="251">Ikarus::FERequirements&lt; SV, PM &gt;::getGlobalSolution</referencedby>
        <referencedby refid="a01250_1a451f4d103d32aa85b43b059642832cb2" compoundref="a00206" startline="263" endline="271">Ikarus::FERequirements&lt; SV, PM &gt;::getParameter</referencedby>
        <referencedby refid="a01386_1a8be0f4769c4f515b64805b77b0146ae4" compoundref="a00179" startline="97" endline="102">Ikarus::ResultFunction&lt; FE, resType, UserFunction &gt;::name</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00325_1aea6d8dd57847aa02cfe354d03fb33873" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(VectorAffordances _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00311_1ga122268ff4d2c0beee58799d85ba5e52a" kindref="member">VectorAffordances</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="45" column="55" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="45" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a6f0494a69387bbaac5cef6eb94ce5e60" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(MatrixAffordances _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00311_1ga52cb89165daabb500f6e2eb68ddd76ee" kindref="member">MatrixAffordances</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="60" column="55" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="60" bodyend="60"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a2b95b51e82bcb7c8990ff20bd8273ebf" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(FEParameter _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00312_1ga0c1577fd05efee8475b0f7fef795bbbe" kindref="member">FEParameter</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="71" column="49" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="71" bodyend="71"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1ad313676e121358d0076db4f79fbce4be" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(FESolutions _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00312_1gaea763c94a1cecbeefc4f8661debcc5a3" kindref="member">FESolutions</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="84" column="49" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="84" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a3c879db4909a24c05893eaf7da23bae1" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(ResultType _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00312_1ga531be167e924b749eb8b4ccc7f1c18c9" kindref="member">ResultType</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="103" column="48" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="103" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1ab6a92f48acd6be62f36b7f499491fc8a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MAT</type>
          </param>
          <param>
            <type>typename S</type>
          </param>
        </templateparamlist>
        <type>consteval bool</type>
        <definition>consteval bool Ikarus::hasCorrectSize</definition>
        <argsstring>()</argsstring>
        <name>hasCorrectSize</name>
        <qualifiedname>Ikarus::hasCorrectSize</qualifiedname>
        <briefdescription>
<para>Template function for checking if the strain size is correct. </para>
        </briefdescription>
        <detaileddescription>
<para>The given strain quantity has to be a Eigen::Vector6 or a Eigen::Matrix3</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MAT</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the material. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>S</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the strains. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/interface.hh" line="38" column="16" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/interface.hh" bodystart="38" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1gad5aa30fe829c7316a0a744b3438609f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>StrainTags</type>
            <declname>tag</declname>
            <defname>tag</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::createGreenLagrangianStrains</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;eMB)</argsstring>
        <name>createGreenLagrangianStrains</name>
        <qualifiedname>Ikarus::createGreenLagrangianStrains</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>eMB</declname>
        </param>
        <briefdescription>
<para>Create Green-Lagrangian strain based on the input. </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates Green-Lagrangian strains based on the input strain matrix. What to do is decided by the provided strain tag</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eMB</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00333" kindref="compound">Eigen</ref> matrix representing the input strain. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The Green-Lagrangian strains matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" line="46" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" bodystart="46" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1ga5293eb09f12e4a45a7aa19a3403a73d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>StrainTags</type>
            <declname>tag</declname>
            <defname>tag</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::createDeformationGradient</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;eMB)</argsstring>
        <name>createDeformationGradient</name>
        <qualifiedname>Ikarus::createDeformationGradient</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>eMB</declname>
        </param>
        <briefdescription>
<para>Create the deformation gradient based on the input. </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates deformation gradient based on the input strain matrix. What to do is decided by the provided strain tag</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eMB</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00333" kindref="compound">Eigen</ref> matrix representing the input strain. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The deformation gradient matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" line="71" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" bodystart="71" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1gae53e0e7999f565fc94610d1c4ede0d16" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>StrainTags</type>
            <declname>tag</declname>
            <defname>tag</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::createRightCauchyGreen</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;eMB)</argsstring>
        <name>createRightCauchyGreen</name>
        <qualifiedname>Ikarus::createRightCauchyGreen</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>eMB</declname>
        </param>
        <briefdescription>
<para>Create right Cauchy-Green tensor based on the input. </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates Right Cauchy-Green tensor based on the input strain matrix. What to do is decided by the provided strain tag</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eMB</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00333" kindref="compound">Eigen</ref> matrix representing the input strain. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The Right Cauchy-Green tensor matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" line="102" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" bodystart="102" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="a00313_1gae9c00f19ce473d7183c87aa84b247f88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>StrainTags</type>
            <declname>from</declname>
            <defname>from</defname>
          </param>
          <param>
            <type>StrainTags</type>
            <declname>to</declname>
            <defname>to</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::transformStrain</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;eRaw)</argsstring>
        <name>transformStrain</name>
        <qualifiedname>Ikarus::transformStrain</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>eRaw</declname>
        </param>
        <briefdescription>
<para>Transform strain from one type to another. </para>
        </briefdescription>
        <detaileddescription>
<para>This function transforms one strain component matrix from one type to another, based on the provided strain tags</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>from</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the source strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>to</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the target strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eRaw</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00333" kindref="compound">Eigen</ref> matrix representing the input strain. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The transformed strain matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" line="132" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" bodystart="132" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1aabe2255ec3392fe00a383dd05d7dfe8a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(StrainTags _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00314_1gacef1e451de1a99845c59d7391064fb8f" kindref="member">StrainTags</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="19" column="48" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="19" bodyend="19"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a31d0fcb0973be69c8c36cc4cbcb70c11" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(StressTags _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00314_1ga70b4ce43c53cc5e949d49919f437501e" kindref="member">StressTags</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="26" column="48" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="26" bodyend="26"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a1146e010b8f52fa9a883f064b3aa389a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(TangentModuliTags _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00314_1ga05ac785124262c1e323d2f937d520a1b" kindref="member">TangentModuliTags</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="33" column="55" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="33" bodyend="33"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a317c0a50c0a7d482e2a20d8146e08df8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Impl::StressIndexPair...</type>
            <declname>stressIndexPair</declname>
            <defname>stressIndexPair</defname>
          </param>
          <param>
            <type>typename MaterialImpl</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeVanishingStress</definition>
        <argsstring>(MaterialImpl mat, typename MaterialImpl::ScalarType p_tol=1e-12)</argsstring>
        <name>makeVanishingStress</name>
        <qualifiedname>Ikarus::makeVanishingStress</qualifiedname>
        <param>
          <type>MaterialImpl</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>typename MaterialImpl::ScalarType</type>
          <declname>p_tol</declname>
          <defval>1e-12</defval>
        </param>
        <briefdescription>
<para>Factory function to create a <ref refid="a01330" kindref="compound">VanishingStress</ref> material with specified stress indices. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>stressIndexPair</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of StressIndexPair representing fixed stress components. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MaterialImpl</parametername>
</parameternamelist>
<parameterdescription>
<para>The underlying material model. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mat</parametername>
</parameternamelist>
<parameterdescription>
<para>The underlying material model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p_tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Tolerance for stress reduction. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="a01330" kindref="compound">VanishingStress</ref> The created <ref refid="a01330" kindref="compound">VanishingStress</ref> material. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/vanishingstress.hh" line="277" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/vanishingstress.hh" bodystart="277" bodyend="279"/>
        <referencedby refid="a00325_1a9b582bcc3c887a57428b25984bc6f7ac" compoundref="a00233" startline="316" endline="318">beamMaterial</referencedby>
        <referencedby refid="a00325_1ad43f50b1b1c3410c4a0c547be7ada4a0" compoundref="a00233" startline="289" endline="292">planeStress</referencedby>
        <referencedby refid="a00325_1a9a1d1c81201b4c4c8cbee139df43b5d6" compoundref="a00233" startline="303" endline="305">shellMaterial</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00325_1ad43f50b1b1c3410c4a0c547be7ada4a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MaterialImpl</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::planeStress</definition>
        <argsstring>(const MaterialImpl &amp;mat, typename MaterialImpl::ScalarType tol=1e-8)</argsstring>
        <name>planeStress</name>
        <qualifiedname>Ikarus::planeStress</qualifiedname>
        <param>
          <type>const MaterialImpl &amp;</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>typename MaterialImpl::ScalarType</type>
          <declname>tol</declname>
          <defval>1e-8</defval>
        </param>
        <briefdescription>
<para>Factory function to create a <ref refid="a01330" kindref="compound">VanishingStress</ref> material for plane stress conditions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MaterialImpl</parametername>
</parameternamelist>
<parameterdescription>
<para>The underlying material model. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mat</parametername>
</parameternamelist>
<parameterdescription>
<para>The underlying material model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Tolerance for stress reduction. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="a01330" kindref="compound">VanishingStress</ref> The created <ref refid="a01330" kindref="compound">VanishingStress</ref> material for plane stress. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/vanishingstress.hh" line="289" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/vanishingstress.hh" bodystart="289" bodyend="292"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a9a1d1c81201b4c4c8cbee139df43b5d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MaterialImpl</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::shellMaterial</definition>
        <argsstring>(const MaterialImpl &amp;mat, typename MaterialImpl::ScalarType tol=1e-8)</argsstring>
        <name>shellMaterial</name>
        <qualifiedname>Ikarus::shellMaterial</qualifiedname>
        <param>
          <type>const MaterialImpl &amp;</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>typename MaterialImpl::ScalarType</type>
          <declname>tol</declname>
          <defval>1e-8</defval>
        </param>
        <briefdescription>
<para>Factory function to create a <ref refid="a01330" kindref="compound">VanishingStress</ref> material for a shell material with zero normal stress condition. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MaterialImpl</parametername>
</parameternamelist>
<parameterdescription>
<para>The underlying material model. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mat</parametername>
</parameternamelist>
<parameterdescription>
<para>The underlying material model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Tolerance for stress reduction. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="a01330" kindref="compound">VanishingStress</ref> The created <ref refid="a01330" kindref="compound">VanishingStress</ref> material for plane stress. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/vanishingstress.hh" line="303" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/vanishingstress.hh" bodystart="303" bodyend="305"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a9b582bcc3c887a57428b25984bc6f7ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MaterialImpl</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::beamMaterial</definition>
        <argsstring>(const MaterialImpl &amp;mat, typename MaterialImpl::ScalarType tol=1e-8)</argsstring>
        <name>beamMaterial</name>
        <qualifiedname>Ikarus::beamMaterial</qualifiedname>
        <param>
          <type>const MaterialImpl &amp;</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>typename MaterialImpl::ScalarType</type>
          <declname>tol</declname>
          <defval>1e-8</defval>
        </param>
        <briefdescription>
<para>Factory function to create a <ref refid="a01330" kindref="compound">VanishingStress</ref> material for a beam material with two zero normal stress condition. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MaterialImpl</parametername>
</parameternamelist>
<parameterdescription>
<para>The underlying material model. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mat</parametername>
</parameternamelist>
<parameterdescription>
<para>The underlying material model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p_tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Tolerance for stress reduction. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="a01330" kindref="compound">VanishingStress</ref> The created <ref refid="a01330" kindref="compound">VanishingStress</ref> material for plane stress. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/vanishingstress.hh" line="316" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/vanishingstress.hh" bodystart="316" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a90678a80e6b2b4849072623df02dae58" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d Ikarus::planeStressLinearElasticMaterialTangent</definition>
        <argsstring>(double E, double nu)</argsstring>
        <name>planeStressLinearElasticMaterialTangent</name>
        <qualifiedname>Ikarus::planeStressLinearElasticMaterialTangent</qualifiedname>
        <param>
          <type>double</type>
          <declname>E</declname>
        </param>
        <param>
          <type>double</type>
          <declname>nu</declname>
        </param>
        <briefdescription>
<para>Computes the plane stress linear elastic material tangent matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Young&apos;s modulus. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nu</parametername>
</parameternamelist>
<parameterdescription>
<para>Poisson&apos;s ratio. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>3x3 material tangent matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="23" column="24" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="23" bodyend="31"/>
        <referencedby refid="a01298_1a32ffbf97a5709decb3db826952ae1df5" compoundref="a02455" startline="139" endline="144">Ikarus::LinearElastic&lt; B, FER, useEigenRef &gt;::materialTangent</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00325_1ab859759a8309b785e7872d8360171030" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Matrix&lt; double, 6, 6 &gt;</type>
        <definition>Eigen::Matrix&lt; double, 6, 6 &gt; Ikarus::linearElasticMaterialTangent3D</definition>
        <argsstring>(double E, double nu)</argsstring>
        <name>linearElasticMaterialTangent3D</name>
        <qualifiedname>Ikarus::linearElasticMaterialTangent3D</qualifiedname>
        <param>
          <type>double</type>
          <declname>E</declname>
        </param>
        <param>
          <type>double</type>
          <declname>nu</declname>
        </param>
        <briefdescription>
<para>Computes the 3D linear elastic material tangent matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Young&apos;s modulus. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nu</parametername>
</parameternamelist>
<parameterdescription>
<para>Poisson&apos;s ratio. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>6x6 material tangent matrix. Structure representing Young&apos;s modulus and Poisson&apos;s ratio. see <ulink url="https://en.wikipedia.org/wiki/Lam%C3%A9_parameters">https://en.wikipedia.org/wiki/Lam%C3%A9_parameters</ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="40" column="22" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="40" bodyend="-1"/>
        <referencedby refid="a01298_1a32ffbf97a5709decb3db826952ae1df5" compoundref="a02455" startline="139" endline="144">Ikarus::LinearElastic&lt; B, FER, useEigenRef &gt;::materialTangent</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00325_1a5e27551f9edaebc557108aa164899b54" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01366" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01342" kindref="compound">YoungsModulusAndPoissonsRatio</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; YoungsModulusAndPoissonsRatio &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const YoungsModulusAndPoissonsRatio &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01342" kindref="compound">YoungsModulusAndPoissonsRatio</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="280" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="280" bodyend="283"/>
        <referencedby refid="a00325_1a32940ef922d090491ffcaa9bf2a44aef" compoundref="a00257" startline="307" endline="312">toLamesFirstParameterAndShearModulus</referencedby>
        <referencedby refid="a00325_1a4161393d679e5ec44806e6e911e26dee" compoundref="a00257" startline="320" endline="325">toYoungsModulusAndPoissonsRatio</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00325_1a6a85c01d9e8f0e2adff8035087485109" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01366" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01346" kindref="compound">YoungsModulusAndShearModulus</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; YoungsModulusAndShearModulus &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const YoungsModulusAndShearModulus &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01346" kindref="compound">YoungsModulusAndShearModulus</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="284" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="284" bodyend="287"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1ad80fc80be73cb847542e1b7c5bde5af6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01366" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01350" kindref="compound">YoungsModulusAndBulkModulus</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; YoungsModulusAndBulkModulus &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const YoungsModulusAndBulkModulus &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01350" kindref="compound">YoungsModulusAndBulkModulus</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="288" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="288" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1aec5648541007a5e5bb89c1f64ec2da92" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01366" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01362" kindref="compound">LamesFirstParameterAndShearModulus</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; LamesFirstParameterAndShearModulus &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const LamesFirstParameterAndShearModulus &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01362" kindref="compound">LamesFirstParameterAndShearModulus</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="292" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="292" bodyend="295"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a8c72e37743694391da18e64618a7c799" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01366" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01358" kindref="compound">BulkModulusAndLamesFirstParameter</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; BulkModulusAndLamesFirstParameter &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const BulkModulusAndLamesFirstParameter &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01358" kindref="compound">BulkModulusAndLamesFirstParameter</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="296" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="296" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a32940ef922d090491ffcaa9bf2a44aef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::toLamesFirstParameterAndShearModulus</definition>
        <argsstring>(const YoungsModulusAndPoissonsRatio &amp;matParameter)</argsstring>
        <name>toLamesFirstParameterAndShearModulus</name>
        <qualifiedname>Ikarus::toLamesFirstParameterAndShearModulus</qualifiedname>
        <param>
          <type>const <ref refid="a01342" kindref="compound">YoungsModulusAndPoissonsRatio</ref> &amp;</type>
          <declname>matParameter</declname>
        </param>
        <briefdescription>
<para>Converts Young&apos;s modulus and Poisson&apos;s ratio to Lame&apos;s first parameter and shear modulus. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>matParameter</parametername>
</parameternamelist>
<parameterdescription>
<para>Young&apos;s modulus and Poisson&apos;s ratio. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Lame&apos;s first parameter and shear modulus. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="307" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="307" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a4161393d679e5ec44806e6e911e26dee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::toYoungsModulusAndPoissonsRatio</definition>
        <argsstring>(const LamesFirstParameterAndShearModulus &amp;matParameter)</argsstring>
        <name>toYoungsModulusAndPoissonsRatio</name>
        <qualifiedname>Ikarus::toYoungsModulusAndPoissonsRatio</qualifiedname>
        <param>
          <type>const <ref refid="a01362" kindref="compound">LamesFirstParameterAndShearModulus</ref> &amp;</type>
          <declname>matParameter</declname>
        </param>
        <briefdescription>
<para>Converts Lame&apos;s first parameter and shear modulus to Young&apos;s modulus and Poisson&apos;s ratio. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>matParameter</parametername>
</parameternamelist>
<parameterdescription>
<para>Lame&apos;s first parameter and shear modulus. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Young&apos;s modulus and Poisson&apos;s ratio. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="320" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="320" bodyend="325"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1afa463e708cffd14133ff65ffa366e329" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>typename LS</type>
            <defval>utils::SolverDefault</defval>
          </param>
          <param>
            <type>typename UF</type>
            <defval>utils::UpdateDefault</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeNewtonRaphson</definition>
        <argsstring>(const NLO &amp;nonLinearOperator, LS &amp;&amp;linearSolver={}, UF &amp;&amp;updateFunction={})</argsstring>
        <name>makeNewtonRaphson</name>
        <qualifiedname>Ikarus::makeNewtonRaphson</qualifiedname>
        <param>
          <type>const NLO &amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
        <param>
          <type>LS &amp;&amp;</type>
          <declname>linearSolver</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>UF &amp;&amp;</type>
          <declname>updateFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Function to create a <ref refid="a01418" kindref="compound">NewtonRaphson</ref> solver instance. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NLO</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>LS</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the linear solver used internally (default is SolverDefault). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UF</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>linearSolver</parametername>
</parameternamelist>
<parameterdescription>
<para>Linear solver used internally (default is SolverDefault). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Shared pointer to the <ref refid="a01418" kindref="compound">NewtonRaphson</ref> solver instance. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphson.hh" line="161" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphson.hh" bodystart="161" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1ade2a979ee79a657c6ab7530ee203056f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>typename LS</type>
            <defval>utils::SolverDefault</defval>
          </param>
          <param>
            <type>typename UF</type>
            <defval>utils::UpdateDefault</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeNewtonRaphsonWithSubsidiaryFunction</definition>
        <argsstring>(const NLO &amp;nonLinearOperator, LS &amp;&amp;linearSolver={}, UF &amp;&amp;updateFunction={})</argsstring>
        <name>makeNewtonRaphsonWithSubsidiaryFunction</name>
        <qualifiedname>Ikarus::makeNewtonRaphsonWithSubsidiaryFunction</qualifiedname>
        <param>
          <type>const NLO &amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
        <param>
          <type>LS &amp;&amp;</type>
          <declname>linearSolver</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>UF &amp;&amp;</type>
          <declname>updateFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Function to create a <ref refid="a01418" kindref="compound">NewtonRaphson</ref> with subsidiary function solver instance. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NLO</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>LS</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the linear solver used internally (default is SolverDefault). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UF</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>linearSolver</parametername>
</parameternamelist>
<parameterdescription>
<para>Linear solver used internally (default is SolverDefault). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Shared pointer to the <ref refid="a01418" kindref="compound">NewtonRaphson</ref> solver instance. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphsonwithscalarsubsidiaryfunction.hh" line="215" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphsonwithscalarsubsidiaryfunction.hh" bodystart="215" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a547326eb09552d3d1fed0830d0e2d269" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>PreConditioner</type>
            <declname>preConditioner</declname>
            <defname>preConditioner</defname>
            <defval>PreConditioner::IncompleteCholesky</defval>
          </param>
          <param>
            <type>typename UF</type>
            <defval>utils::UpdateDefault</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeTrustRegion</definition>
        <argsstring>(const NLO &amp;nonLinearOperator, UF &amp;&amp;updateFunction={})</argsstring>
        <name>makeTrustRegion</name>
        <qualifiedname>Ikarus::makeTrustRegion</qualifiedname>
        <param>
          <type>const NLO &amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
        <param>
          <type>UF &amp;&amp;</type>
          <declname>updateFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Creates an instance of the <ref refid="a01446" kindref="compound">TrustRegion</ref> solver. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NLO</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>preConditioner</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the preconditioner used internally (default is IncompleteCholesky). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UF</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Shared pointer to the <ref refid="a01446" kindref="compound">TrustRegion</ref> solver instance. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" line="488" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" bodystart="488" bodyend="490"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a9acabb8291c86afe74e8617830e033de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GV</type>
          </param>
          <param>
            <type>typename PBF</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeBasis</definition>
        <argsstring>(const GV &amp;gv, const PBF &amp;pb)</argsstring>
        <name>makeBasis</name>
        <qualifiedname>Ikarus::makeBasis</qualifiedname>
        <param>
          <type>const GV &amp;</type>
          <declname>gv</declname>
        </param>
        <param>
          <type>const PBF &amp;</type>
          <declname>pb</declname>
        </param>
        <briefdescription>
<para>Factory function to create a <ref refid="a01458" kindref="compound">Basis</ref> object. </para>
        </briefdescription>
        <detaileddescription>
<para>Factory function that creates a <ref refid="a01458" kindref="compound">Basis</ref> object from a given grid view and pre-basis factory.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>GV</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the grid view. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PBF</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the pre-basis factory function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>gv</parametername>
</parameternamelist>
<parameterdescription>
<para>The grid view. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pb</parametername>
</parameternamelist>
<parameterdescription>
<para>The pre-basis factory function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="a01458" kindref="compound">Basis</ref> object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/basis.hh" line="109" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/basis.hh" bodystart="109" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1aa8350697b25edf5034483b28fb0c3f76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PB</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeBasis</definition>
        <argsstring>(const Dune::Functions::DefaultGlobalBasis&lt; PB &gt; &amp;gb)</argsstring>
        <name>makeBasis</name>
        <qualifiedname>Ikarus::makeBasis</qualifiedname>
        <param>
          <type>const Dune::Functions::DefaultGlobalBasis&lt; PB &gt; &amp;</type>
          <declname>gb</declname>
        </param>
        <briefdescription>
<para>Factory function to create a <ref refid="a01458" kindref="compound">Basis</ref> object from a DefaultGlobalBasis. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PB</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the pre-basis associated with the DefaultGlobalBasis. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>gb</parametername>
</parameternamelist>
<parameterdescription>
<para>The DefaultGlobalBasis. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="a01458" kindref="compound">Basis</ref> object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/basis.hh" line="123" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/basis.hh" bodystart="123" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1ac2c6469be19ce4ef2e630bfa1c5a5e24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::transpose</definition>
        <argsstring>(const Eigen::EigenBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>transpose</name>
        <qualifiedname>Ikarus::transpose</qualifiedname>
        <param>
          <type>const <ref refid="a01462" kindref="compound">Eigen::EigenBase</ref>&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/concepts.hh" line="33" column="6" declfile="/__w/ikarus/ikarus/repo/ikarus/utils/concepts.hh" declline="33" declcolumn="6"/>
        <referencedby refid="a01290_1adef9992c1720510edd81557fda7cfa20" compoundref="a02449" startline="421" endline="440">Ikarus::KirchhoffLoveShell&lt; B, FER, useEigenRef &gt;::bopBending</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00325_1a0fdba7f3ebe4bf1ada6618f450b50221" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type><ref refid="a01370" kindref="compound">Dune::FieldVector</ref>&lt; ST, size &gt;</type>
        <definition>Dune::FieldVector&lt; ST, size &gt; Ikarus::toDune</definition>
        <argsstring>(const Eigen::Vector&lt; ST, size &gt; &amp;vec)</argsstring>
        <name>toDune</name>
        <qualifiedname>Ikarus::toDune</qualifiedname>
        <param>
          <type>const Eigen::Vector&lt; ST, size &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>Create Eigen::Vector to <ref refid="a01370" kindref="compound">Dune::FieldVector</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the vectors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the vectors. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>The Eigen::Vector to be converted. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Dune::FieldVector&lt;ST, size&gt; representing the converted vector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="30" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="30" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a4e9e21776afdaaa93c4a9d19554976fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>rows</declname>
            <defname>rows</defname>
          </param>
        </templateparamlist>
        <type><ref refid="a01370" kindref="compound">Dune::FieldVector</ref>&lt; ST, rows &gt;</type>
        <definition>Dune::FieldVector&lt; ST, rows &gt; Ikarus::toDune</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, rows, 0 &gt; &amp;vec)</argsstring>
        <name>toDune</name>
        <qualifiedname>Ikarus::toDune</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, rows, 0 &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>Convert Eigen::Matrix to <ref refid="a01370" kindref="compound">Dune::FieldVector</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>The matrix has fixed row size. The matrix needs to have a single column. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the vectors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rows</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of rows in the matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>The Eigen::Matrix to be converted. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Dune::FieldVector&lt;ST, rows&gt; representing the converted matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="47" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="47" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a83633e77ee5a35cb31a7cd2f02aedb7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>rows</declname>
            <defname>rows</defname>
          </param>
          <param>
            <type>int</type>
            <declname>cols</declname>
            <defname>cols</defname>
          </param>
        </templateparamlist>
        <type>Dune::FieldMatrix&lt; ST, rows, cols &gt;</type>
        <definition>Dune::FieldMatrix&lt; ST, rows, cols &gt; Ikarus::toDune</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, rows, cols &gt; &amp;mat)</argsstring>
        <name>toDune</name>
        <qualifiedname>Ikarus::toDune</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, rows, cols &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
<para>Convert Eigen::Matrix to Dune::FieldMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para>The matrix has fixed rows and column size <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rows</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of rows in the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cols</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of columns in the matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mat</parametername>
</parameternamelist>
<parameterdescription>
<para>The Eigen::Matrix to be converted. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Dune::FieldMatrix&lt;ST, rows, cols&gt; representing the converted matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="66" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="66" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1aaa7e8e9b8bd8247afecc24cdd54ec658" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; const Eigen::Vector&lt; ST, size &gt; &gt;</type>
        <definition>Eigen::Map&lt; const Eigen::Vector&lt; ST, size &gt; &gt; Ikarus::toEigenMap</definition>
        <argsstring>(const Dune::FieldVector&lt; ST, size &gt; &amp;vec)</argsstring>
        <name>toEigenMap</name>
        <qualifiedname>Ikarus::toEigenMap</qualifiedname>
        <param>
          <type>const <ref refid="a01370" kindref="compound">Dune::FieldVector</ref>&lt; ST, size &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>View a <ref refid="a01370" kindref="compound">Dune::FieldVector</ref> as an Eigen::Vector using Map, no copies take place. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="a01370" kindref="compound">Dune::FieldVector</ref> to be viewed as Eigen::Vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map&lt;const Eigen::Vector&lt;ST, size&gt;&gt; representing the viewed vector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="83" column="12" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="83" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1aaac71220182c301ee8c864f2a507c3db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; Eigen::Vector&lt; ST, size &gt; &gt;</type>
        <definition>Eigen::Map&lt; Eigen::Vector&lt; ST, size &gt; &gt; Ikarus::toEigenMap</definition>
        <argsstring>(Dune::FieldVector&lt; ST, size &gt; &amp;vec)</argsstring>
        <name>toEigenMap</name>
        <qualifiedname>Ikarus::toEigenMap</qualifiedname>
        <param>
          <type><ref refid="a01370" kindref="compound">Dune::FieldVector</ref>&lt; ST, size &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>View a constant <ref refid="a01370" kindref="compound">Dune::FieldVector</ref> as a constant Eigen::Vector, no copies take place. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="a01370" kindref="compound">Dune::FieldVector</ref> to be viewed as Eigen::Vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map&lt;Eigen::Vector&lt;ST, size&gt;&gt; representing the viewed vector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="95" column="12" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="95" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga0728039472747184e9eb2ec0992a4a2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PreBasis</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::flatPreBasis</definition>
        <argsstring>(const PreBasis &amp;preBasis)</argsstring>
        <name>flatPreBasis</name>
        <qualifiedname>Ikarus::flatPreBasis</qualifiedname>
        <param>
          <type>const PreBasis &amp;</type>
          <declname>preBasis</declname>
        </param>
        <briefdescription>
<para>Generator function for a flatted PreBasis. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" line="110" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" bodystart="110" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1ac8243891c1b961e50a066140ab79a142" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Ikarus::init</definition>
        <argsstring>(int argc, char **argv, bool enableFileLogger=true)</argsstring>
        <name>init</name>
        <qualifiedname>Ikarus::init</qualifiedname>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>enableFileLogger</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Initializes the <ref refid="a00325" kindref="compound">Ikarus</ref> framework. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of command-line arguments. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>The command-line arguments. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>enableFileLogger</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether to enable the file logger. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
<para><ulink url="https://patorjk.com/software/taag/#p=testall&amp;f=Univers&amp;t=IKARUS">https://patorjk.com/software/taag/#p=testall&amp;f=Univers&amp;t=IKARUS</ulink> (font: Lean)</para>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/init.hh" line="82" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/init.hh" bodystart="82" bodyend="107"/>
        <referencedby refid="a00281_1a0e4f7cface71bec1c24bbed3aaa798d8" compoundref="a00281" startline="35" endline="139">PYBIND11_MODULE</referencedby>
        <referencedby refid="a00317_1ga3792308fbe7fa149d290329ed46c5bb9" compoundref="a02467" startline="37" endline="52">Ikarus::Python::registerBasis</referencedby>
        <referencedby refid="a00335_1a331fd78be5a4155963abe5829282c8f1" compoundref="a00140" startline="17" endline="30">Ikarus::Python::registerBoundaryPatch</referencedby>
        <referencedby refid="a00317_1ga39b6df6adfe4858b13ac71f5830f29f6" compoundref="a02473" startline="49" endline="112">Ikarus::Python::registerDirichletValues</referencedby>
        <referencedby refid="a00317_1ga40f83e4d7b90006b1019add3b1b218b5" compoundref="a00158" startline="45" endline="134">Ikarus::Python::registerElement</referencedby>
        <referencedby refid="a00317_1ga31d84874c3995448666f6a1e070647d2" compoundref="a02452" startline="45" endline="72">Ikarus::Python::registerKirchhoffLoveShell</referencedby>
        <referencedby refid="a00335_1a4124469fcacfc527cb971b40fe86e244" compoundref="a02464" startline="24" endline="114">Ikarus::Python::registerNonLinearElastic</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00320_1gaa33adfa2e95d7040a816bb2da81d275d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::orthonormalizeMatrixColumns</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>orthonormalizeMatrixColumns</name>
        <qualifiedname>Ikarus::orthonormalizeMatrixColumns</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Orthonormalizes all Matrix columns using Gram-Schmidt Orthogonalization. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input matrix.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>The input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="a00333" kindref="compound">Eigen</ref> Matrix with orthonormalized columns. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="35" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="35" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga545d74839895f4576a3b8c97d72abefd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsFlatEigenVector</definition>
        <argsstring>(Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsFlatEigenVector</name>
        <qualifiedname>Ikarus::viewAsFlatEigenVector</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View Dune::BlockVector as an Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a flat Eigen::Vector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="57" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="57" bodyend="62"/>
        <referencedby refid="a01286_1a362c0e974d3441af17e9d4594ce4eb84" compoundref="a00221" startline="164" endline="198">Ikarus::EnhancedAssumedStrains&lt; DFE &gt;::calculateAt</referencedby>
        <referencedby refid="a01286_1a24d232578192661667e78c555dc5b7b3" compoundref="a00221" startline="258" endline="298">Ikarus::EnhancedAssumedStrains&lt; DFE &gt;::calculateVectorImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga3beeb26c911116fa02df8756214484aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsFlatEigenVector</definition>
        <argsstring>(const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsFlatEigenVector</name>
        <qualifiedname>Ikarus::viewAsFlatEigenVector</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View const Dune::BlockVector as an Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a flat Eigen::Vector (const version). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="72" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="72" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gaf9d7cf401f9f03ce1aae728c646ce178" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixAsDynFixed</definition>
        <argsstring>(Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixAsDynFixed</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixAsDynFixed</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View Dune::BlockVector as an Eigen::Matrix with dynamic rows and fixed columns depending on the size of the ValueType. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a dynamic Eigen::Matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="88" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="88" bodyend="93"/>
        <referencedby refid="a01290_1a994624bc06728e1a33adcb3723f4ee8e" compoundref="a02449" startline="230" endline="264">Ikarus::KirchhoffLoveShell&lt; B, FER, useEigenRef &gt;::computeMaterialAndStrains</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00320_1gaf1c6bdf14e40ee46e881f646e1c28b0d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixAsDynFixed</definition>
        <argsstring>(const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixAsDynFixed</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixAsDynFixed</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>Const view Dune::BlockVector as an Eigen::Matrix with dynamic rows and fixed columns depending on the size of the ValueType. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a dynamic Eigen::Matrix (const version). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="104" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="104" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gac25618d0e7c4aece653662d2541b61ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixFixedDyn</definition>
        <argsstring>(Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixFixedDyn</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixFixedDyn</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View Dune::BlockVector as an Eigen::Matrix with fixed rows depending on the size of the ValueType and dynamic columns. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a fixed-size Eigen::Matrix with dynamic columns. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="120" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="120" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga146a052f6eb97304a8172c7b65fe70fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixFixedDyn</definition>
        <argsstring>(const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixFixedDyn</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixFixedDyn</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>Const view Dune::BlockVector as an Eigen::Matrix with fixed rows depending on the size of the ValueType and dynamic columns. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a fixed-size Eigen::Matrix with dynamic columns (const version). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="135" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="135" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga609664964681787f2f736f772b82a01e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t Ikarus::correctionSize</definition>
        <argsstring>(const Dune::BlockVector&lt; Type &gt; &amp;a)</argsstring>
        <name>correctionSize</name>
        <qualifiedname>Ikarus::correctionSize</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
    <requiresclause>requires { Type::correctionSize; }    </requiresclause>
        <briefdescription>
<para>Returns the total correction size of a block vector with a Manifold as the underlying type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Total correction size. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="150" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="150" bodyend="154"/>
        <referencedby refid="a00320_1ga609664964681787f2f736f772b82a01e" compoundref="a00062" startline="150" endline="154">correctionSize</referencedby>
        <referencedby refid="a00320_1ga09cedf6a65b142340c1934c987ed064c" compoundref="a00062" startline="180" endline="188">operator+=</referencedby>
        <referencedby refid="a00320_1ga90c40b4eebec59eeb02294cd7cb0470c" compoundref="a00062" startline="200" endline="205">operator-=</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00320_1gac1df27a0dfa864327029cdb906a1840c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t Ikarus::valueSize</definition>
        <argsstring>(const Dune::BlockVector&lt; Type &gt; &amp;a)</argsstring>
        <name>valueSize</name>
        <qualifiedname>Ikarus::valueSize</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
    <requiresclause>requires { Type::valueSize; }    </requiresclause>
        <briefdescription>
<para>Returns the total value size of a block vector with a Manifold as the underlying type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Total value size. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="164" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="164" bodyend="168"/>
        <referencedby refid="a00320_1gadab36ca6a3183fb9fedbb02b3ecba736" compoundref="a00062" startline="239" endline="248">addInEmbedding</referencedby>
        <referencedby refid="a00320_1gac1df27a0dfa864327029cdb906a1840c" compoundref="a00062" startline="164" endline="168">valueSize</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga09cedf6a65b142340c1934c987ed064c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
        <definition>Dune::BlockVector&lt; Type &gt; &amp; Ikarus::operator+=</definition>
        <argsstring>(Dune::BlockVector&lt; Type &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator+=</name>
        <qualifiedname>Ikarus::operator+=</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
    <requiresclause>(<ref refid="a01638" kindref="compound">Ikarus::Concepts::AddAssignAble</ref>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })    </requiresclause>
        <briefdescription>
<para>Enables the += operator for Dune::BlockVector += Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::BlockVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="180" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="180" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga90c40b4eebec59eeb02294cd7cb0470c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
        <definition>Dune::BlockVector&lt; Type &gt; &amp; Ikarus::operator-=</definition>
        <argsstring>(Dune::BlockVector&lt; Type &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator-=</name>
        <qualifiedname>Ikarus::operator-=</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
    <requiresclause>(<ref refid="a01638" kindref="compound">Ikarus::Concepts::AddAssignAble</ref>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })    </requiresclause>
        <briefdescription>
<para>Enables the -= operator for Dune::BlockVector += Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::BlockVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="200" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="200" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gaada5360aeb17e59d87ae2ba82057421d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Types</declname>
            <defname>Types</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::TupleVector&lt; Types... &gt; &amp;</type>
        <definition>Dune::TupleVector&lt; Types... &gt; &amp; Ikarus::operator+=</definition>
        <argsstring>(Dune::TupleVector&lt; Types... &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator+=</name>
        <qualifiedname>Ikarus::operator+=</qualifiedname>
        <param>
          <type>Dune::TupleVector&lt; Types... &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Enables the += operator for Dune::TupleVector += Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Types</parametername>
</parameternamelist>
<parameterdescription>
<para>Types of the elements in the TupleVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::TupleVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::TupleVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="217" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="217" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gadab36ca6a3183fb9fedbb02b3ecba736" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ManifoldPoint</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::BlockVector&lt; ManifoldPoint &gt; &amp;</type>
        <definition>Dune::BlockVector&lt; ManifoldPoint &gt; &amp; Ikarus::addInEmbedding</definition>
        <argsstring>(Dune::BlockVector&lt; ManifoldPoint &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>addInEmbedding</name>
        <qualifiedname>Ikarus::addInEmbedding</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ManifoldPoint &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
    <requiresclause>(<ref refid="a01638" kindref="compound">Ikarus::Concepts::AddAssignAble</ref>&lt;ManifoldPoint, decltype(b.template segment&lt;ManifoldPoint::valueSize&gt;(0))&gt; and requires() { ManifoldPoint::valueSize; })    </requiresclause>
        <briefdescription>
<para>Enables the addition in the embedding space of a vector in the space M^n, where M is a manifold with the points of type ManifoldPoint. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ManifoldPoint</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>ManifoldPoint of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::BlockVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="239" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="239" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga0ffc0c74dbd9aeee3e53b199a21b828c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::norm</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;v)</argsstring>
        <name>norm</name>
        <qualifiedname>Ikarus::norm</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>v</declname>
        </param>
    <requiresclause>(!std::floating_point&lt;Derived&gt;)    </requiresclause>
        <briefdescription>
<para>Adding free norm function to <ref refid="a00333" kindref="compound">Eigen</ref> types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Norm of the matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="259" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="259" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gaceb8dc8f6f43516dabf75155b1f22d4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::norm</definition>
        <argsstring>(const std::floating_point auto &amp;v)</argsstring>
        <name>norm</name>
        <qualifiedname>Ikarus::norm</qualifiedname>
        <param>
          <type>const std::floating_point auto &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Helper Free Function to have the same interface as for <ref refid="a00333" kindref="compound">Eigen</ref> Vector Types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>Input scalar. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Absolute value of the scalar. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="269" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="269" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gacbc60e06e8e43a9bc14660189eb1baa1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator*</definition>
        <argsstring>(const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</argsstring>
        <name>operator*</name>
        <qualifiedname>Ikarus::operator*</qualifiedname>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Eigen::DiagonalMatrix Product Missing in <ref refid="a00333" kindref="compound">Eigen</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Product of the two DiagonalMatrices. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="281" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="281" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga96968bbff353ac49f48d0aa8b9810b7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+=</definition>
        <argsstring>(Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</argsstring>
        <name>operator+=</name>
        <qualifiedname>Ikarus::operator+=</qualifiedname>
        <param>
          <type>Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>In-place addition for Eigen::DiagonalMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified DiagonalMatrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="295" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="295" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga098b554b29619e0cea837f3daa6e0e30" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Eigen::Matrix + Eigen::DiagonalMatrix addition missing in <ref refid="a00333" kindref="compound">Eigen</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of the <ref refid="a00333" kindref="compound">Eigen</ref> matrix and DiagonalMatrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="311" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="311" bodyend="315"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gafe54695fd1436b5f2d75934a6fda8fe8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Eigen::DiagonalMatrix + Eigen::Matrix addition missing in <ref refid="a00333" kindref="compound">Eigen</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of the DiagonalMatrix and <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="328" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="328" bodyend="330"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga9ab6437d6235e378a6171bfffd4bf1cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator-</definition>
        <argsstring>(const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a)</argsstring>
        <name>operator-</name>
        <qualifiedname>Ikarus::operator-</qualifiedname>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Unary minus for Eigen::DiagonalMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Negation of the DiagonalMatrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="341" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="341" bodyend="343"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga0fe1660eb760ecc49838d130ba6c6712" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Derived2</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;a, const Eigen::DiagonalWrapper&lt; Derived2 &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalWrapper&lt; Derived2 &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Addition of Eigen::Matrix and Eigen::DiagonalWrapper. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived2</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of <ref refid="a00333" kindref="compound">Eigen</ref> matrix and DiagonalWrapper. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="355" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="355" bodyend="359"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga9377cd2cf3a5ec468d140cb7063efa58" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Derived2</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::DiagonalWrapper&lt; Derived &gt; &amp;a, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::DiagonalWrapper&lt; Derived &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived2 &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Addition of Eigen::DiagonalWrapper and Eigen::Matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived2</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of DiagonalWrapper and <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="371" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="371" bodyend="373"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gac2cdcc3047e59b91a4874a1355503cd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; Ikarus::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>Ikarus::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Output stream operator for Eigen::DiagonalMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>os</parametername>
</parameternamelist>
<parameterdescription>
<para>Output stream. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the output stream. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="385" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="385" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gabd35ea7f69bcc71ee90ea421a1c48167" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Derived</type>
        <definition>Derived Ikarus::sym</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>sym</name>
        <qualifiedname>Ikarus::sym</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the symmetric part of a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Symmetric part of the matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="398" column="9" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="398" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga1496a9776a583f8b09c4244a68453394" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Derived</type>
        <definition>Derived Ikarus::skew</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>skew</name>
        <qualifiedname>Ikarus::skew</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the skew part of a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Skew part of the matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="410" column="9" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="410" bodyend="412"/>
        <referencedby refid="a01290_1a470610d359a9dd69415d9957505f594b" compoundref="a02449" startline="375" endline="418">Ikarus::KirchhoffLoveShell&lt; B, FER, useEigenRef &gt;::kgBending</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga40c08050aff1e3e49e58c7823ecbcc77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Ikarus::printForMaple</definition>
        <argsstring>(const Eigen::EigenBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>printForMaple</name>
        <qualifiedname>Ikarus::printForMaple</qualifiedname>
        <param>
          <type>const <ref refid="a01462" kindref="compound">Eigen::EigenBase</ref>&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Method to print the matrix in a format that can directly be copied to Maple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>The derived type of the matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>The input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="421" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="421" bodyend="433"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga821ecf80e4a83241318d825f49cd79e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FieldVectorT</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::createRandomVector</definition>
        <argsstring>(typename FieldVectorT::value_type lower=-1, typename FieldVectorT::value_type upper=1)</argsstring>
        <name>createRandomVector</name>
        <qualifiedname>Ikarus::createRandomVector</qualifiedname>
        <param>
          <type>typename FieldVectorT::value_type</type>
          <declname>lower</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>typename FieldVectorT::value_type</type>
          <declname>upper</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Creates a random vector of the specified type within a given range. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>FieldVectorT</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lower</parametername>
</parameternamelist>
<parameterdescription>
<para>The lower bound of the random values (default is -1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>upper</parametername>
</parameternamelist>
<parameterdescription>
<para>The upper bound of the random values (default is 1). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A random vector within the specified range. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="444" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="444" bodyend="452"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1gabf7cb564e7fa11a403cb8439e2436205" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; ScalarType, 3, 3 &gt;</type>
        <definition>Eigen::Matrix&lt; ScalarType, 3, 3 &gt; Ikarus::skew</definition>
        <argsstring>(const Eigen::Vector&lt; ScalarType, 3 &gt; &amp;a)</argsstring>
        <name>skew</name>
        <qualifiedname>Ikarus::skew</qualifiedname>
        <param>
          <type>const Eigen::Vector&lt; ScalarType, 3 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Create skew 3x3 matrix from 3d vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the coordinates in the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The skew matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="462" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="462" bodyend="466"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga19d425a4fbc72c2ef7a97d71de9329a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>size_t</type>
            <declname>sizeOfCondensedIndices</declname>
            <defname>sizeOfCondensedIndices</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::staticCondensation</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E, const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;indices)</argsstring>
        <name>staticCondensation</name>
        <qualifiedname>Ikarus::staticCondensation</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Performs static condensation on a square matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizeOfCondensedIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the condensed indices. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>indices</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of indices to be condensed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting matrix after static condensation.</para>
</simplesect>
This function performs static condensation on a square matrix. It removes the specified indices from the matrix, computes the remaining submatrices (K11, K12, K22), and returns the result of the static condensation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="498" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="498" bodyend="511"/>
        <referencedby refid="a01330_1acdd8f1a651ee1e15647ec146f981040d" compoundref="a00233" startline="164" endline="171">Ikarus::VanishingStress&lt; stressIndexPair, MI &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga2f675229501979101656ec4dee7764d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>size_t</type>
            <declname>sizeOfRemovedCols</declname>
            <defname>sizeOfRemovedCols</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::removeCol</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E, const std::array&lt; size_t, sizeOfRemovedCols &gt; &amp;indices)</argsstring>
        <name>removeCol</name>
        <qualifiedname>Ikarus::removeCol</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const std::array&lt; size_t, sizeOfRemovedCols &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Removes specified columns from a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizeOfRemovedCols</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the columns to be removed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>indices</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of column indices to be removed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting matrix after removing specified columns.</para>
</simplesect>
This function removes specified columns from a matrix. It computes the remaining columns after removing the specified indices and returns the resulting matrix. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="526" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="526" bodyend="535"/>
        <referencedby refid="a01330_1abdfa744589b54cc5c943d781c73359f0" compoundref="a00233" startline="146" endline="154">Ikarus::VanishingStress&lt; stressIndexPair, MI &gt;::stressesImpl</referencedby>
        <referencedby refid="a00320_1ga378c5569b7b899586e7c8006fb776351" compoundref="a00062" startline="552" endline="565">toVoigtAndMaybeReduce</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga378c5569b7b899586e7c8006fb776351" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>typename MaterialImpl</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::toVoigtAndMaybeReduce</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, 3, 3 &gt; &amp;E, const MaterialImpl &amp;material, bool isStrain=true)</argsstring>
        <name>toVoigtAndMaybeReduce</name>
        <qualifiedname>Ikarus::toVoigtAndMaybeReduce</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, 3, 3 &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const MaterialImpl &amp;</type>
          <declname>material</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isStrain</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Converts a 3x3 matrix to Voigt notation, possibly reducing it based on material properties. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MaterialImpl</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the material implementation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input 3x3 matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>material</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to the material implementation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isStrain</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating if the matrix represents strain (default is true). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting matrix in Voigt notation.</para>
</simplesect>
This function converts a 3x3 matrix to its Voigt notation. If the material is not reduced, the full Voigt notation is returned. Otherwise, the specified columns (based on material properties, such as <ref refid="a01330" kindref="compound">VanishingStress</ref>) are removed, and the reduced Voigt notation is returned. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="552" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="552" bodyend="565"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga30500f2c49b7d1997c7eb7b6ee90ad75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename M</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::enlargeIfReduced</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E)</argsstring>
        <name>enlargeIfReduced</name>
        <qualifiedname>Ikarus::enlargeIfReduced</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <briefdescription>
<para>Enlarges a matrix if it reduced in the context of material laws, i.e., <ref refid="a01330" kindref="compound">VanishingStress</ref> If the material is not reduced the untouched matrix is returned and rendering the function as a NoOp. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>M</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the material. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto Resulting matrix based on material properties.</para>
</simplesect>
This function takes an input matrix and, based on the material properties, either returns the original matrix (if it is not reduced) or enlarges the matrix by filling in the specified columns with zeros (if it is reduced). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="580" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="580" bodyend="605"/>
      </memberdef>
      <memberdef kind="function" id="a00320_1ga5db6e8f04892e85e6b17e276cdbd0e54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MessageType</type>
          </param>
        </templateparamlist>
        <type>MessageType &amp;</type>
        <definition>MessageType &amp; Ikarus::increment</definition>
        <argsstring>(MessageType &amp;e)</argsstring>
        <name>increment</name>
        <qualifiedname>Ikarus::increment</qualifiedname>
        <param>
          <type>MessageType &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Increments the given enum value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MessageType</parametername>
</parameternamelist>
<parameterdescription>
<para>The enum type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>The enum value to increment. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The incremented enum value. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>Dune::RangeError</parametername>
</parameternamelist>
<parameterdescription>
<para>if trying to increment MessageType::END. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/makeenum.hh" line="68" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/makeenum.hh" bodystart="68" bodyend="74"/>
        <referencedby refid="a01570_1ac8058d5b1ebb462a10712ba598154e23" compoundref="a00128" startline="131" endline="134">Ikarus::IObservable&lt; MessageType &gt;::IObservable</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00325_1ae55d4d0c3478ab3ecf54ce905ddf223b" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr T</type>
        <definition>constexpr T Ikarus::ct_sqrt</definition>
        <argsstring>(T x)</argsstring>
        <name>ct_sqrt</name>
        <qualifiedname>Ikarus::ct_sqrt</qualifiedname>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
    <requiresclause>std::integral&lt;T&gt;    </requiresclause>
        <briefdescription>
<para>Compile-time square root for integer types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The integral type for which square root is calculated. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value for which square root is calculated. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr T The calculated square root. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/math.hh" line="47" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/math.hh" bodystart="47" bodyend="49"/>
        <referencedby refid="a00321_1ga106e11a950fe2545890e811d2e9545fd" compoundref="a00020" startline="256" endline="270">fromVoigt</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00325_1ac00abda505aa8ccc73ce59afd165ce49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::parameter</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>parameter</name>
        <qualifiedname>Ikarus::parameter</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Creates a Parameter object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument types. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>The tuple of arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto The Parameter object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" line="115" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" bodystart="115" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1ab787b670f0d338c870988f417cf85f76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::functions</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>functions</name>
        <qualifiedname>Ikarus::functions</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Creates a Functions object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument types. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>The tuple of arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto The Functions object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" line="127" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" bodystart="127" bodyend="129"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a5357efca8ce4f70831d107f93f2cda1d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>DerivativeArgs</declname>
            <defname>DerivativeArgs</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>ParameterArgs</declname>
            <defname>ParameterArgs</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::initResults</definition>
        <argsstring>(const Impl::Functions&lt; DerivativeArgs... &gt; &amp;derivativesFunctions, const Impl::Parameter&lt; ParameterArgs... &gt; &amp;parameter)</argsstring>
        <name>initResults</name>
        <qualifiedname>Ikarus::initResults</qualifiedname>
        <param>
          <type>const Impl::Functions&lt; DerivativeArgs... &gt; &amp;</type>
          <declname>derivativesFunctions</declname>
        </param>
        <param>
          <type>const Impl::Parameter&lt; ParameterArgs... &gt; &amp;</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Initializes the results for functions and parameters. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DerivativeArgs</parametername>
</parameternamelist>
<parameterdescription>
<para>The types of derivative arguments. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ParameterArgs</parametername>
</parameternamelist>
<parameterdescription>
<para>The types of parameter arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>derivativesFunctions</parametername>
</parameternamelist>
<parameterdescription>
<para>The Functions object for derivative arguments. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parameter</parametername>
</parameternamelist>
<parameterdescription>
<para>The Parameter object for parameter arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto The initialized results. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" line="141" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" bodystart="141" bodyend="146"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a839e2d8a648318c584c66024e62ddd91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class BaseQuadrature</type>
          </param>
          <param>
            <type>class Quadrature</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::tensorProductQuadrature</definition>
        <argsstring>(const BaseQuadrature &amp;baseQuad, const Quadrature &amp;onedQuad)</argsstring>
        <name>tensorProductQuadrature</name>
        <qualifiedname>Ikarus::tensorProductQuadrature</qualifiedname>
        <param>
          <type>const BaseQuadrature &amp;</type>
          <declname>baseQuad</declname>
        </param>
        <param>
          <type>const Quadrature &amp;</type>
          <declname>onedQuad</declname>
        </param>
        <briefdescription>
<para>Computes the tensor product quadrature rule using a base and one-dimensional quadrature rule. </para>
        </briefdescription>
        <detaileddescription>
<para>This function constructs a tensor product quadrature rule by combining a base quadrature rule and a one-dimensional quadrature rule. It iterates over the points of the base quadrature and combines them with each point of the one-dimensional quadrature.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>BaseQuadrature</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the base quadrature. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Quadrature</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the one-dimensional quadrature.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>baseQuad</parametername>
</parameternamelist>
<parameterdescription>
<para>The base quadrature rule. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>onedQuad</parametername>
</parameternamelist>
<parameterdescription>
<para>The one-dimensional quadrature rule.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Dune::QuadratureRule&lt;double, BaseQuadrature::d + 1&gt; - Tensor product quadrature rule. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorproductquadrule.hh" line="29" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorproductquadrule.hh" bodystart="29" bodyend="48"/>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga5cfd9d098384fb067d897b3c0499b447" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>auto</type>
            <declname>rank</declname>
            <defname>rank</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Tensor&lt; typename Derived::Scalar, rank &gt;</type>
        <definition>Eigen::Tensor&lt; typename Derived::Scalar, rank &gt; Ikarus::tensorView</definition>
        <argsstring>(const Eigen::EigenBase&lt; Derived &gt; &amp;matrix, const std::array&lt; T, rank &gt; &amp;dims)</argsstring>
        <name>tensorView</name>
        <qualifiedname>Ikarus::tensorView</qualifiedname>
        <param>
          <type>const <ref refid="a01462" kindref="compound">Eigen::EigenBase</ref>&lt; Derived &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type>const std::array&lt; T, rank &gt; &amp;</type>
          <declname>dims</declname>
        </param>
        <briefdescription>
<para>View an <ref refid="a00333" kindref="compound">Eigen</ref> matrix as an <ref refid="a00333" kindref="compound">Eigen</ref> Tensor with specified dimensions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00333" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rank</parametername>
</parameternamelist>
<parameterdescription>
<para>Rank of the resulting Tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00333" kindref="compound">Eigen</ref> matrix to be cast. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimensions of the resulting Tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Tensor&lt;typename Derived::Scalar, rank&gt; The casted <ref refid="a00333" kindref="compound">Eigen</ref> Tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="32" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="32" bodyend="37"/>
        <referencedby refid="a01290_1a8276e3a39ed9d5ef3ff6c6bbff0cc236" compoundref="a02449" startline="442" endline="453">Ikarus::KirchhoffLoveShell&lt; B, FER, useEigenRef &gt;::materialTangent</referencedby>
        <referencedby refid="a01318_1a4a0fcea9a714d1a6d4cb3aa691f5596d" compoundref="a00245" startline="110" endline="124">Ikarus::NeoHookeT&lt; ST &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00321_1gab2cea9ac847cc3635812467c9d96ceb4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::dyadic</definition>
        <argsstring>(const auto &amp;A_ij, const auto &amp;B_kl)</argsstring>
        <name>dyadic</name>
        <qualifiedname>Ikarus::dyadic</qualifiedname>
        <param>
          <type>const auto &amp;</type>
          <declname>A_ij</declname>
        </param>
        <param>
          <type>const auto &amp;</type>
          <declname>B_kl</declname>
        </param>
        <briefdescription>
<para>Computes the dyadic product of two <ref refid="a00333" kindref="compound">Eigen</ref> tensors. </para>
        </briefdescription>
        <detaileddescription>
<para>The components of the result read <formula id="33">\[ \CI_{ijkl} = A_{ij}B_{kl}. \]</formula></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A_ij</parametername>
</parameternamelist>
<parameterdescription>
<para>First tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_kl</parametername>
</parameternamelist>
<parameterdescription>
<para>Second tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting tensor after the dyadic product. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="47" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="47" bodyend="50"/>
        <referencedby refid="a01290_1a8276e3a39ed9d5ef3ff6c6bbff0cc236" compoundref="a02449" startline="442" endline="453">Ikarus::KirchhoffLoveShell&lt; B, FER, useEigenRef &gt;::materialTangent</referencedby>
        <referencedby refid="a01318_1a4a0fcea9a714d1a6d4cb3aa691f5596d" compoundref="a00245" startline="110" endline="124">Ikarus::NeoHookeT&lt; ST &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga1c9618ef351cd986d4f64fde7f52e860" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
            <defval>double</defval>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
            <defval>3</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::symmetricIdentityFourthOrder</definition>
        <argsstring>()</argsstring>
        <name>symmetricIdentityFourthOrder</name>
        <qualifiedname>Ikarus::symmetricIdentityFourthOrder</qualifiedname>
        <briefdescription>
<para>Generates a symmetric identity fourth-order tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension of the tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Symmetric identity fourth-order tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="60" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="60" bodyend="68"/>
        <referencedby refid="a01322_1a9cad76128962f632ae742e8769b9803e" compoundref="a00236" startline="143" endline="158">Ikarus::StVenantKirchhoffT&lt; ST &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga2368a572348c410fd7e7deb6c6e3964a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
            <defval>double</defval>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
            <defval>3</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::symmetricFourthOrder</definition>
        <argsstring>(const auto &amp;A, const auto &amp;B)</argsstring>
        <name>symmetricFourthOrder</name>
        <qualifiedname>Ikarus::symmetricFourthOrder</qualifiedname>
        <param>
          <type>const auto &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const auto &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Generates a symmetric fourth-order tensor based on two second-order input tensors. </para>
        </briefdescription>
        <detaileddescription>
<para>The components of the result read <formula id="34">\[ \CI_{ijkl} = \frac{1}{2} \left(A_{ik}B_{jl}+A_{il}B_{jk} \right) .
\]</formula> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the tensors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension of the tensors. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>First tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Second tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Symmetric fourth-order tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="82" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="82" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="a00321_1gadb08b6f9cc40847b70286dc314a23000" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
            <defval>double</defval>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
            <defval>3</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::identityFourthOrder</definition>
        <argsstring>()</argsstring>
        <name>identityFourthOrder</name>
        <qualifiedname>Ikarus::identityFourthOrder</qualifiedname>
        <briefdescription>
<para>Generates an identity fourth-order tensor. </para>
        </briefdescription>
        <detaileddescription>
<para>The components of the result read <formula id="35">\[ \CI_{ijkl} = \de_{ij}\de_{kl}. \]</formula> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension of the tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Identity fourth-order tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="101" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="101" bodyend="108"/>
        <referencedby refid="a01322_1a9cad76128962f632ae742e8769b9803e" compoundref="a00236" startline="143" endline="158">Ikarus::StVenantKirchhoffT&lt; ST &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga8fa2b440586483c1ee0f9b90b9081da2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename AType</type>
          </param>
          <param>
            <type>typename BType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::fourthOrderIKJL</definition>
        <argsstring>(const Eigen::MatrixBase&lt; AType &gt; &amp;A, const Eigen::MatrixBase&lt; BType &gt; &amp;B)</argsstring>
        <name>fourthOrderIKJL</name>
        <qualifiedname>Ikarus::fourthOrderIKJL</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; AType &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; BType &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Computes the IKJL product of two matrices. </para>
        </briefdescription>
        <detaileddescription>
<para>The components of the result read <formula id="36">\[ \CI_{ijkl} = A_{ik}B_{jl}, \]</formula> which simply swaps the inner slots <computeroutput>j</computeroutput>and <computeroutput>k</computeroutput> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>AType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the first matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the second matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>First matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Second matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting tensor of the IKJL product. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="122" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="122" bodyend="134"/>
        <referencedby refid="a01318_1a4a0fcea9a714d1a6d4cb3aa691f5596d" compoundref="a00245" startline="110" endline="124">Ikarus::NeoHookeT&lt; ST &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00321_1gaea03dbfcd8f85ef7af004c7e09244aa9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
          </param>
          <param>
            <type>long int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::symTwoSlots</definition>
        <argsstring>(const Eigen::TensorFixedSize&lt; ScalarType, Eigen::Sizes&lt; dim, dim, dim, dim &gt; &gt; &amp;t, const std::array&lt; size_t, 2 &gt; &amp;slots)</argsstring>
        <name>symTwoSlots</name>
        <qualifiedname>Ikarus::symTwoSlots</qualifiedname>
        <param>
          <type>const Eigen::TensorFixedSize&lt; ScalarType, Eigen::Sizes&lt; dim, dim, dim, dim &gt; &gt; &amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const std::array&lt; size_t, 2 &gt; &amp;</type>
          <declname>slots</declname>
        </param>
        <briefdescription>
<para>Creates a symmetric fourth-order tensor in the two specified slots of the input tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>slots</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices of the slots to be swapped. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Fourth-order Tensor which is symmetric in the given slots. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="145" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="145" bodyend="151"/>
        <referencedby refid="a01318_1a4a0fcea9a714d1a6d4cb3aa691f5596d" compoundref="a00245" startline="110" endline="124">Ikarus::NeoHookeT&lt; ST &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga4304655095296ce9283e012587817a51" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>constexpr Eigen::Index</type>
        <definition>constexpr Eigen::Index Ikarus::toVoigt</definition>
        <argsstring>(Eigen::Index i, Eigen::Index j) noexcept</argsstring>
        <name>toVoigt</name>
        <qualifiedname>Ikarus::toVoigt</qualifiedname>
        <param>
          <type>Eigen::Index</type>
          <declname>i</declname>
        </param>
        <param>
          <type>Eigen::Index</type>
          <declname>j</declname>
        </param>
        <briefdescription>
<para>Converts 2D indices to Voigt notation index. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>Row index. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>j</parametername>
</parameternamelist>
<parameterdescription>
<para>Column index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Index Voigt notation index.</para>
</simplesect>
This function converts 2D indices (i, j) to a Voigt notation index. The Voigt notation is used to represent the six unique components of a symmetric 3x3 matrix in a one-dimensional array.</para>
<para>If the input indices are not within the valid range (0, 1, 2), an assertion failure is triggered. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="166" column="24" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="166" bodyend="177"/>
        <referencedby refid="a01338_1a765f9740fe927b34ab4d0add274be811" compoundref="a02461" startline="257" endline="269">Ikarus::NonLinearElastic&lt; B, MAT, FER, useEigenRef &gt;::calculateAt</referencedby>
        <referencedby refid="a01290_1a994624bc06728e1a33adcb3723f4ee8e" compoundref="a02449" startline="230" endline="264">Ikarus::KirchhoffLoveShell&lt; B, FER, useEigenRef &gt;::computeMaterialAndStrains</referencedby>
        <referencedby refid="a01290_1a8276e3a39ed9d5ef3ff6c6bbff0cc236" compoundref="a02449" startline="442" endline="453">Ikarus::KirchhoffLoveShell&lt; B, FER, useEigenRef &gt;::materialTangent</referencedby>
        <referencedby refid="a01310_1ab2015ecf069d4d5022852d7cfc62c689" compoundref="a00230" startline="118" endline="129">Ikarus::Material&lt; MI &gt;::storedEnergy</referencedby>
        <referencedby refid="a01310_1ae47b0b923d01f3f2abcf5d3fd5ff04bc" compoundref="a00230" startline="142" endline="150">Ikarus::Material&lt; MI &gt;::stresses</referencedby>
        <referencedby refid="a01310_1a2d9d9509fa8bbdc909868c8fd0dfe5fd" compoundref="a00230" startline="163" endline="171">Ikarus::Material&lt; MI &gt;::tangentModuli</referencedby>
        <referencedby refid="a00321_1ga8777400d7d11c49d46f3c6be2698722e" compoundref="a00020" startline="194" endline="202">toVoigt</referencedby>
        <referencedby refid="a00320_1ga378c5569b7b899586e7c8006fb776351" compoundref="a00062" startline="552" endline="565">toVoigtAndMaybeReduce</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga8777400d7d11c49d46f3c6be2698722e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
            <defval>double</defval>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; ScalarType, 6, 6 &gt;</type>
        <definition>Eigen::Matrix&lt; ScalarType, 6, 6 &gt; Ikarus::toVoigt</definition>
        <argsstring>(const Eigen::TensorFixedSize&lt; ScalarType, Eigen::Sizes&lt; 3, 3, 3, 3 &gt; &gt; &amp;ft)</argsstring>
        <name>toVoigt</name>
        <qualifiedname>Ikarus::toVoigt</qualifiedname>
        <param>
          <type>const Eigen::TensorFixedSize&lt; ScalarType, Eigen::Sizes&lt; 3, 3, 3, 3 &gt; &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <briefdescription>
<para>Converts a fourth-order tensor of fixed size 3x3x3x3 to a Voigt notation matrix of size 6x6. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type of the tensor elements. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>Fourth-order tensor . </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Voigt notation matrix.</para>
</simplesect>
This function converts a fourth-order tensor to a Voigt notation matrix, which is a symmetric 6x6 matrix containing the unique components of the input tensor. The mapping from the tensor indices to the Voigt notation indices is performed by the toVoigt function.</para>
<para><simplesect kind="remark"><para>The current implementation does not take advantage of this symmetry. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="194" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="194" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga7a49f3cfec729ac9991cc595bac37a94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
          <param>
            <type>int</type>
            <declname>Options</declname>
            <defname>Options</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::toVoigt</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, size, size, Options, size, size &gt; &amp;E, bool isStrain=true)</argsstring>
        <name>toVoigt</name>
        <qualifiedname>Ikarus::toVoigt</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, size, size, Options, size, size &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isStrain</declname>
          <defval>true</defval>
        </param>
    <requiresclause>(size &gt; 0 and size &lt;= 3)    </requiresclause>
        <briefdescription>
<para>Converts a square 2x2 or 3x3 matrix to a Voigt notation vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type of the matrix elements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows and columns of the square matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Options</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00333" kindref="compound">Eigen</ref> matrix options. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix of size (size x size). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isStrain</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether the conversion is for strain (true) or not (false). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Vector with components in Voigt notation vector.</para>
</simplesect>
This function converts a square matrix to a Voigt notation vector, which contains the unique components of the input matrix. The mapping from the matrix indices to the Voigt notation indices is performed by the toVoigt function.</para>
<para>The optional isStrain parameter allows the user to specify whether the conversion is intended for strain calculations. If isStrain is true, the off-diagonal components are multiplied by 2, providing the correct Voigt notation for symmetric strain tensors. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="224" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="224" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga106e11a950fe2545890e811d2e9545fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::fromVoigt</definition>
        <argsstring>(const Eigen::Vector&lt; ST, size &gt; &amp;EVoigt, bool isStrain=true)</argsstring>
        <name>fromVoigt</name>
        <qualifiedname>Ikarus::fromVoigt</qualifiedname>
        <param>
          <type>const Eigen::Vector&lt; ST, size &gt; &amp;</type>
          <declname>EVoigt</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isStrain</declname>
          <defval>true</defval>
        </param>
    <requiresclause>(size == 1 or size == 3 or size == 6)    </requiresclause>
        <briefdescription>
<para>Converts a vector given in Voigt notation to a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type of the vector elements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the Voigt notation vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>EVoigt</parametername>
</parameternamelist>
<parameterdescription>
<para>Voigt notation vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isStrain</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether the vector represents a strain (default is true). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Matrix corresponding to the vector in Voigt notation.</para>
</simplesect>
This function converts a vector given in Voigt notation to the corresponding matrix. The conversion depends on the size The parameter <computeroutput>isStrain</computeroutput> is used to determine the conversion factor for off-diagonal components, which need to be divided by 2 in the matrix representation if the quantity is a strain tensor.</para>
<para>The function requires that the size of the Voigt notation vector is valid (1, 3, or 6). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="256" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="256" bodyend="270"/>
        <referencedby refid="a00321_1ga0afe53095f875017b5673a42e13e6f5a" compoundref="a00020" startline="312" endline="323">fromVoigt</referencedby>
        <referencedby refid="a01330_1abdfa744589b54cc5c943d781c73359f0" compoundref="a00233" startline="146" endline="154">Ikarus::VanishingStress&lt; stressIndexPair, MI &gt;::stressesImpl</referencedby>
        <referencedby refid="a01330_1acdd8f1a651ee1e15647ec146f981040d" compoundref="a00233" startline="164" endline="171">Ikarus::VanishingStress&lt; stressIndexPair, MI &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga518e0394f7c90dbe798b6cb8d757b822" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::array&lt; size_t, 2 &gt;</type>
        <definition>constexpr std::array&lt; size_t, 2 &gt; Ikarus::fromVoigt</definition>
        <argsstring>(size_t i)</argsstring>
        <name>fromVoigt</name>
        <qualifiedname>Ikarus::fromVoigt</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>Converts a Voigt notation index to matrix indices. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>Voigt notation index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Matrix indices corresponding to the Voigt notation index.</para>
</simplesect>
This function converts a Voigt notation index to the corresponding matrix indices. The mapping is based on the assumption that the Voigt notation indices 0, 1, and 2 represent the diagonal components <computeroutput>00</computeroutput>, <computeroutput>11</computeroutput>, and <computeroutput>22</computeroutput>, respectively. The remaining Voigt notation indices (3, 4, and 5) correspond to the off-diagonal components (<computeroutput>12</computeroutput> and <computeroutput>21</computeroutput>, <computeroutput>02</computeroutput> and <computeroutput>20</computeroutput>, <computeroutput>01</computeroutput> and <computeroutput>10</computeroutput>).</para>
<para>The function asserts that the input index is within the valid range for Voigt notation (0 to 5). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="285" column="22" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="285" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="a00321_1ga0afe53095f875017b5673a42e13e6f5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::fromVoigt</definition>
        <argsstring>(const Eigen::Matrix&lt; ScalarType, 6, 6 &gt; &amp;CVoigt)</argsstring>
        <name>fromVoigt</name>
        <qualifiedname>Ikarus::fromVoigt</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ScalarType, 6, 6 &gt; &amp;</type>
          <declname>CVoigt</declname>
        </param>
        <briefdescription>
<para>Converts a matrix in Voigt notation to a Fourth-order tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type of the matrix elements. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>CVoigt</parametername>
</parameternamelist>
<parameterdescription>
<para>Voigt notation matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Fourth-order tensor corresponding to the matrix in Voigt notation.</para>
</simplesect>
This function converts a Voigt notation matrix to the corresponding 4th-order tensor. The function uses the <computeroutput>fromVoigt</computeroutput> function to map matrix indices to tensor indices. The resulting tensor is symmetric due to symmetry considerations. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="312" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="312" bodyend="323"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a7a5b9f5e83f6918ca1726fb4316c3b86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d Ikarus::calcTransformationMatrix2D</definition>
        <argsstring>(const Geometry &amp;geometry)</argsstring>
        <name>calcTransformationMatrix2D</name>
        <qualifiedname>Ikarus::calcTransformationMatrix2D</qualifiedname>
        <param>
          <type>const Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the 2D transformation matrix. </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes the transformation matrix needed to transform second-order tensors represented in Voigt notation from local to global coordinate system for 2D elements.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The geometry type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to the geometry object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The transformation matrix for 2D elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="336" column="17" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="336" bodyend="356"/>
      </memberdef>
      <memberdef kind="function" id="a00325_1a95234ab8588ced83708c6e5a30e2368e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; double, 6, 6 &gt;</type>
        <definition>Eigen::Matrix&lt; double, 6, 6 &gt; Ikarus::calcTransformationMatrix3D</definition>
        <argsstring>(const Geometry &amp;geometry)</argsstring>
        <name>calcTransformationMatrix3D</name>
        <qualifiedname>Ikarus::calcTransformationMatrix3D</qualifiedname>
        <param>
          <type>const Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the 3D transformation matrix. </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes the transformation matrix needed to transform second-order tensors represented in Voigt notation from local to global coordinate system for 3D elements.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The geometry type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to the geometry object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The transformation matrix for 3D elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="369" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="369" bodyend="398"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/__w/ikarus/ikarus/repo/ikarus/assembler/simpleassemblers.hh" line="21" column="1"/>
  </compounddef>
</doxygen>
