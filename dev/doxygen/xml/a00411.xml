<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.4" xml:lang="en-US">
  <compounddef id="a00411" kind="namespace" language="C++">
    <compoundname>Ikarus</compoundname>
    <innerclass refid="a01386" prot="public">Ikarus::AffordanceCollection</innerclass>
    <innerclass refid="a01854" prot="public">Ikarus::AlgoInfo</innerclass>
    <innerclass refid="a01350" prot="public">Ikarus::ArcLength</innerclass>
    <innerclass refid="a01526" prot="public">Ikarus::ArrudaBoyceMatParameters</innerclass>
    <innerclass refid="a01278" prot="public">Ikarus::AssemblerManipulator</innerclass>
    <innerclass refid="a01282" prot="public">Ikarus::AssemblerManipulator&lt; A, ScalarAss &gt;</innerclass>
    <innerclass refid="a01286" prot="public">Ikarus::AssemblerManipulator&lt; A, ScalarAss, VectorAss &gt;</innerclass>
    <innerclass refid="a01290" prot="public">Ikarus::AssemblerManipulator&lt; A, ScalarAss, VectorAss, MatrixAss &gt;</innerclass>
    <innerclass refid="a01366" prot="public">Ikarus::AutoDiffFE</innerclass>
    <innerclass refid="a01870" prot="public">Ikarus::BasisHandler</innerclass>
    <innerclass refid="a01706" prot="public">Ikarus::BulkModulusAndLamesFirstParameter</innerclass>
    <innerclass refid="a01334" prot="public">Ikarus::ControlInformation</innerclass>
    <innerclass refid="a01986" prot="public">Ikarus::ControlLogger</innerclass>
    <innerclass refid="a01990" prot="public">Ikarus::ControlSubsamplingVertexVTKWriter</innerclass>
    <innerclass refid="a01714" prot="public">Ikarus::ConvertLameConstants</innerclass>
    <innerclass refid="a01646" prot="public">Ikarus::DefaultMembraneStrain</innerclass>
    <innerclass refid="a01322" prot="public">Ikarus::DenseFlatAssembler</innerclass>
    <innerclass refid="a01914" prot="public">Ikarus::DeriveSizeType</innerclass>
    <innerclass refid="a01922" prot="public">Ikarus::DeriveSizeType&lt; std::vector&lt; bool &gt; &gt;</innerclass>
    <innerclass refid="a01918" prot="public">Ikarus::DeriveSizeType&lt; T &gt;</innerclass>
    <innerclass refid="a01926" prot="public">Ikarus::DirichletValues</innerclass>
    <innerclass refid="a01358" prot="public">Ikarus::DisplacementControl</innerclass>
    <innerclass refid="a01478" prot="public">Ikarus::EnhancedAssumedStrains</innerclass>
    <innerclass refid="a01482" prot="public">Ikarus::EnhancedAssumedStrainsPre</innerclass>
    <innerclass refid="a01370" prot="public">Ikarus::FE</innerclass>
    <innerclass refid="a01382" prot="public">Ikarus::FEFactory</innerclass>
    <innerclass refid="a01670" prot="public">Ikarus::FEMixin</innerclass>
    <innerclass refid="a01402" prot="public">Ikarus::FERequirements</innerclass>
    <innerclass refid="a01406" prot="public">Ikarus::FERequirementsFactory</innerclass>
    <innerclass refid="a01442" prot="public">Ikarus::FETraits</innerclass>
    <innerclass refid="a01294" prot="public">Ikarus::FlatAssemblerBase</innerclass>
    <innerclass refid="a01938" prot="public">Ikarus::FlatIndexMergingStrategy</innerclass>
    <innerclass refid="a01942" prot="public">Ikarus::FlatIndexMergingStrategy&lt; Dune::Functions::BasisFactory::BlockedInterleaved &gt;</innerclass>
    <innerclass refid="a01946" prot="public">Ikarus::FlatIndexMergingStrategy&lt; Dune::Functions::BasisFactory::BlockedLexicographic &gt;</innerclass>
    <innerclass refid="a01934" prot="public">Ikarus::FlatPreBasis</innerclass>
    <innerclass refid="a01950" prot="public">Ikarus::FlatPreBasis&lt; Dune::Functions::CompositePreBasis&lt; IMS, SPB... &gt; &gt;</innerclass>
    <innerclass refid="a01954" prot="public">Ikarus::FlatPreBasis&lt; Dune::Functions::PowerPreBasis&lt; IMS, SPB, C &gt; &gt;</innerclass>
    <innerclass refid="a01994" prot="public">Ikarus::GenericObserver</innerclass>
    <innerclass refid="a01542" prot="public">Ikarus::GentMatParameters</innerclass>
    <innerclass refid="a01962" prot="public">Ikarus::IkarusInstance</innerclass>
    <innerclass refid="a02006" prot="public">Ikarus::IObservable</innerclass>
    <innerclass refid="a02002" prot="public">Ikarus::IObserver</innerclass>
    <innerclass refid="a01486" prot="public">Ikarus::KirchhoffLoveShell</innerclass>
    <innerclass refid="a01490" prot="public">Ikarus::KirchhoffLoveShellPre</innerclass>
    <innerclass refid="a01498" prot="public">Ikarus::KlArgs</innerclass>
    <innerclass refid="a01710" prot="public">Ikarus::LamesFirstParameterAndShearModulus</innerclass>
    <innerclass refid="a01502" prot="public">Ikarus::LinearElastic</innerclass>
    <innerclass refid="a01506" prot="public">Ikarus::LinearElasticPre</innerclass>
    <innerclass refid="a01798" prot="public">Ikarus::LinearSolverTemplate</innerclass>
    <innerclass refid="a01338" prot="public">Ikarus::LoadControl</innerclass>
    <innerclass refid="a01354" prot="public">Ikarus::LoadControlSubsidiaryFunction</innerclass>
    <innerclass refid="a01306" prot="public">Ikarus::MatrixAssembler</innerclass>
    <innerclass refid="a01270" prot="public">Ikarus::MatrixManipulator</innerclass>
    <innerclass refid="a01514" prot="public">Ikarus::NeumannBoundaryLoadPre</innerclass>
    <innerclass refid="a01810" prot="public">Ikarus::NewtonRaphson</innerclass>
    <innerclass refid="a01818" prot="public">Ikarus::NewtonRaphsonConfig</innerclass>
    <innerclass refid="a01822" prot="public">Ikarus::NewtonRaphsonWithSubsidiaryFunction</innerclass>
    <innerclass refid="a01830" prot="public">Ikarus::NewtonRaphsonWithSubsidiaryFunctionConfig</innerclass>
    <innerclass refid="a01826" prot="public">Ikarus::NewtonRaphsonWithSubsidiaryFunctionSettings</innerclass>
    <innerclass refid="a01650" prot="public">Ikarus::NonLinearElastic</innerclass>
    <innerclass refid="a01654" prot="public">Ikarus::NonLinearElasticPre</innerclass>
    <innerclass refid="a01974" prot="public">Ikarus::NonLinearOperator</innerclass>
    <innerclass refid="a01982" prot="public">Ikarus::NonLinearOperatorFactory</innerclass>
    <innerclass refid="a01834" prot="public">Ikarus::NonlinearSolverFactory</innerclass>
    <innerclass refid="a01838" prot="public">Ikarus::NonLinearSolverInformation</innerclass>
    <innerclass refid="a01998" prot="public">Ikarus::NonLinearSolverLogger</innerclass>
    <innerclass refid="a01814" prot="public">Ikarus::NRSettings</innerclass>
    <innerclass refid="a01342" prot="public">Ikarus::PathFollowing</innerclass>
    <innerclass refid="a01374" prot="public">Ikarus::PreFE</innerclass>
    <innerclass refid="a01742" prot="public">Ikarus::ResultFunction</innerclass>
    <innerclass refid="a01438" prot="public">Ikarus::ResultTypeBase</innerclass>
    <innerclass refid="a01426" prot="public">Ikarus::ResultWrapper</innerclass>
    <innerclass refid="a01298" prot="public">Ikarus::ScalarAssembler</innerclass>
    <innerclass refid="a01310" prot="public">Ikarus::ScalarFlatAssembler</innerclass>
    <innerclass refid="a01262" prot="public">Ikarus::ScalarManipulator</innerclass>
    <innerclass refid="a01686" prot="public">Ikarus::Skills</innerclass>
    <innerclass refid="a01318" prot="public">Ikarus::SparseFlatAssembler</innerclass>
    <innerclass refid="a01858" prot="public">Ikarus::Stats</innerclass>
    <innerclass refid="a01346" prot="public">Ikarus::SubsidiaryArgs</innerclass>
    <innerclass refid="a01510" prot="public">Ikarus::Traction</innerclass>
    <innerclass refid="a01842" prot="public">Ikarus::TRSettings</innerclass>
    <innerclass refid="a01658" prot="public">Ikarus::Truss</innerclass>
    <innerclass refid="a01662" prot="public">Ikarus::TrussPre</innerclass>
    <innerclass refid="a01850" prot="public">Ikarus::TrustRegion</innerclass>
    <innerclass refid="a01846" prot="public">Ikarus::TrustRegionConfig</innerclass>
    <innerclass refid="a01302" prot="public">Ikarus::VectorAssembler</innerclass>
    <innerclass refid="a01314" prot="public">Ikarus::VectorFlatAssembler</innerclass>
    <innerclass refid="a01266" prot="public">Ikarus::VectorManipulator</innerclass>
    <innerclass refid="a01518" prot="public">Ikarus::VolumeLoad</innerclass>
    <innerclass refid="a01522" prot="public">Ikarus::VolumeLoadPre</innerclass>
    <innerclass refid="a01698" prot="public">Ikarus::YoungsModulusAndBulkModulus</innerclass>
    <innerclass refid="a01702" prot="public">Ikarus::YoungsModulusAndLamesFirstParameter</innerclass>
    <innerclass refid="a01690" prot="public">Ikarus::YoungsModulusAndPoissonsRatio</innerclass>
    <innerclass refid="a01694" prot="public">Ikarus::YoungsModulusAndShearModulus</innerclass>
    <innernamespace refid="a00413">Ikarus::AdaptiveStepSizing</innernamespace>
    <innernamespace refid="a00417">Ikarus::AffordanceCollections</innernamespace>
    <innernamespace refid="a00421">Ikarus::Concepts</innernamespace>
    <innernamespace refid="a00419">Ikarus::EAS</innernamespace>
    <innernamespace refid="a00414">Ikarus::Experimental</innernamespace>
    <innernamespace refid="a00415">Ikarus::FEHelper</innernamespace>
    <innernamespace refid="a00422">Ikarus::Materials</innernamespace>
    <innernamespace refid="a00435">Ikarus::plot</innernamespace>
    <innernamespace refid="a00429">Ikarus::Python</innernamespace>
    <innernamespace refid="a00424">Ikarus::ResultEvaluators</innernamespace>
    <innernamespace refid="a00418">Ikarus::ResultTypes</innernamespace>
    <innernamespace refid="a00437">Ikarus::traits</innernamespace>
    <innernamespace refid="a00431">Ikarus::utils</innernamespace>
    <innernamespace refid="a00425">Ikarus::Vtk</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="a00411_1a9f83fad9f4c149f249165a13f2370eec" prot="public" static="no" strong="yes">
        <type></type>
        <name>DBCOption</name>
        <qualifiedname>Ikarus::DBCOption</qualifiedname>
        <enumvalue id="a00411_1a9f83fad9f4c149f249165a13f2370eeca19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a9f83fad9f4c149f249165a13f2370eeca65e65c8ab0d8609ce12fc68a03cb8e00" prot="public">
          <name>Raw</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a9f83fad9f4c149f249165a13f2370eeca4335949a935758ca1b570689c3c6750b" prot="public">
          <name>Reduced</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a9f83fad9f4c149f249165a13f2370eecabbd47109890259c0127154db1af26c75" prot="public">
          <name>Full</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a9f83fad9f4c149f249165a13f2370eecab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/assembler/dirichletbcenforcement.hh" line="7" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/assembler/dirichletbcenforcement.hh" bodystart="7" bodyend="7"/>
      </memberdef>
      <memberdef kind="enum" id="a00411_1af6f894084edd9109762b86222995ef2a" prot="public" static="no" strong="yes">
        <type></type>
        <name>ScalarAffordance</name>
        <qualifiedname>Ikarus::ScalarAffordance</qualifiedname>
        <enumvalue id="a00411_1af6f894084edd9109762b86222995ef2aa19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1af6f894084edd9109762b86222995ef2aa9a280b29988e2eac8c0767e0fcefb49c" prot="public">
          <name>noAffordance</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1af6f894084edd9109762b86222995ef2aa814f34f472acef493e9ecf0ffccdcae6" prot="public">
          <name>mechanicalPotentialEnergy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1af6f894084edd9109762b86222995ef2aae45c0886135e58c01a313bda2d69e29a" prot="public">
          <name>microMagneticPotentialEnergy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1af6f894084edd9109762b86222995ef2aab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the scalar affordance. </para>
        </briefdescription>
        <detaileddescription>
<para>ScalarAffordance </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="37" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="37" bodyend="37"/>
      </memberdef>
      <memberdef kind="enum" id="a00411_1aab9e3e38507d1db7602bc750718c302a" prot="public" static="no" strong="yes">
        <type></type>
        <name>VectorAffordance</name>
        <qualifiedname>Ikarus::VectorAffordance</qualifiedname>
        <enumvalue id="a00411_1aab9e3e38507d1db7602bc750718c302aa19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1aab9e3e38507d1db7602bc750718c302aa9a280b29988e2eac8c0767e0fcefb49c" prot="public">
          <name>noAffordance</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1aab9e3e38507d1db7602bc750718c302aa2c05161a7e67e946ddc889571aac4e89" prot="public">
          <name>forces</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1aab9e3e38507d1db7602bc750718c302aa3cc975e7798ac76d6af4f624e23c6ddc" prot="public">
          <name>microMagneticForces</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1aab9e3e38507d1db7602bc750718c302aab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the vector affordance. </para>
        </briefdescription>
        <detaileddescription>
<para>VectorAffordance </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="48" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="48" bodyend="48"/>
      </memberdef>
      <memberdef kind="enum" id="a00411_1a390d5311179ec61d163a29c943b3d1a0" prot="public" static="no" strong="yes">
        <type></type>
        <name>MatrixAffordance</name>
        <qualifiedname>Ikarus::MatrixAffordance</qualifiedname>
        <enumvalue id="a00411_1a390d5311179ec61d163a29c943b3d1a0a19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a390d5311179ec61d163a29c943b3d1a0a9a280b29988e2eac8c0767e0fcefb49c" prot="public">
          <name>noAffordance</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a390d5311179ec61d163a29c943b3d1a0a086e8b527490b8abe606a8dd76586ab1" prot="public">
          <name>stiffness</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a390d5311179ec61d163a29c943b3d1a0a3a130b44dd6ff9351e7734ac33096b62" prot="public">
          <name>materialstiffness</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a390d5311179ec61d163a29c943b3d1a0ae15aaa3bcdfc63653ecc7de3f1d4794b" prot="public">
          <name>geometricstiffness</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a390d5311179ec61d163a29c943b3d1a0adaa7ff7d704732b763943e3355764532" prot="public">
          <name>stiffnessdiffBucklingVector</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a390d5311179ec61d163a29c943b3d1a0a1b0fce0a361af9d6e59694b4c51524f9" prot="public">
          <name>microMagneticHessian</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a390d5311179ec61d163a29c943b3d1a0ad90ccffa01275a7a7795fb6d1274e75f" prot="public">
          <name>mass</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a390d5311179ec61d163a29c943b3d1a0ab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the matrix affordance. </para>
        </briefdescription>
        <detaileddescription>
<para>MatrixAffordance </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="63" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="63" bodyend="63"/>
      </memberdef>
      <memberdef kind="enum" id="a00398_1ga0c1577fd05efee8475b0f7fef795bbbe" prot="public" static="no" strong="yes">
        <type></type>
        <name>FEParameter</name>
        <qualifiedname>Ikarus::FEParameter</qualifiedname>
        <enumvalue id="a00398_1gga0c1577fd05efee8475b0f7fef795bbbea19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1gga0c1577fd05efee8475b0f7fef795bbbea298c62e2f9918b280f40eb210c44fdbe" prot="public">
          <name>noParameter</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1gga0c1577fd05efee8475b0f7fef795bbbeaf72bac0ac84c0315e7bcbb8aa84b2ff8" prot="public">
          <name>loadfactor</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1gga0c1577fd05efee8475b0f7fef795bbbea07cc694b9b3fc636710fa08b6922c42b" prot="public">
          <name>time</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1gga0c1577fd05efee8475b0f7fef795bbbeab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the <ref refid="a01370" kindref="compound">FE</ref> parameter. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="74" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="74" bodyend="74"/>
      </memberdef>
      <memberdef kind="enum" id="a00398_1gaea763c94a1cecbeefc4f8661debcc5a3" prot="public" static="no" strong="yes">
        <type></type>
        <name>FESolutions</name>
        <qualifiedname>Ikarus::FESolutions</qualifiedname>
        <enumvalue id="a00398_1ggaea763c94a1cecbeefc4f8661debcc5a3a19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1ggaea763c94a1cecbeefc4f8661debcc5a3a2100a151ce2773b3467509ae085aa505" prot="public">
          <name>noSolution</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1ggaea763c94a1cecbeefc4f8661debcc5a3a0c2d35f5f278a229db5ba41d40120f1c" prot="public">
          <name>displacement</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1ggaea763c94a1cecbeefc4f8661debcc5a3aac1a453d0cdc1f19d9479ccfaa8b082c" prot="public">
          <name>velocity</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1ggaea763c94a1cecbeefc4f8661debcc5a3a3d4e992d8d8a7d848724aa26ed7f4176" prot="public">
          <name>director</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1ggaea763c94a1cecbeefc4f8661debcc5a3a58edccca94b76e0355ed45da28ece7ff" prot="public">
          <name>magnetizationAndVectorPotential</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00398_1ggaea763c94a1cecbeefc4f8661debcc5a3ab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the solutions vectors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="87" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="87" bodyend="87"/>
      </memberdef>
      <memberdef kind="enum" id="a00411_1acfb09bb7db104db62d3d1d2dc3e009b2" prot="public" static="no" strong="yes">
        <type></type>
        <name>ResultShape</name>
        <qualifiedname>Ikarus::ResultShape</qualifiedname>
        <enumvalue id="a00411_1acfb09bb7db104db62d3d1d2dc3e009b2a57dea6f5039281b7fee517fc43bf3110" prot="public">
          <name>Vector</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1acfb09bb7db104db62d3d1d2dc3e009b2af53df0293e169f562bc1d9a20e1d2589" prot="public">
          <name>Matrix</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/feresulttypes.hh" line="150" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/feresulttypes.hh" bodystart="151" bodyend="154"/>
      </memberdef>
      <memberdef kind="enum" id="a00400_1gacef1e451de1a99845c59d7391064fb8f" prot="public" static="no" strong="yes">
        <type></type>
        <name>StrainTags</name>
        <qualifiedname>Ikarus::StrainTags</qualifiedname>
        <enumvalue id="a00400_1ggacef1e451de1a99845c59d7391064fb8fa19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1ggacef1e451de1a99845c59d7391064fb8fa9a932b3cb396238423eb2f33ec17d6aa" prot="public">
          <name>linear</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1ggacef1e451de1a99845c59d7391064fb8fa61fc106262d2e2049866894bb4f862a5" prot="public">
          <name>deformationGradient</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1ggacef1e451de1a99845c59d7391064fb8fa0eb1f1f7a6a355c2f4260b74c21d80f3" prot="public">
          <name>displacementGradient</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1ggacef1e451de1a99845c59d7391064fb8faca3f1e4bb21fd00a3d29c5d8aff8e11e" prot="public">
          <name>greenLagrangian</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1ggacef1e451de1a99845c59d7391064fb8faea40a9960a7a89c4f366beeab85d07d2" prot="public">
          <name>rightCauchyGreenTensor</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1ggacef1e451de1a99845c59d7391064fb8fab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the passed strain. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="19" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="19" bodyend="19"/>
      </memberdef>
      <memberdef kind="enum" id="a00400_1ga70b4ce43c53cc5e949d49919f437501e" prot="public" static="no" strong="yes">
        <type></type>
        <name>StressTags</name>
        <qualifiedname>Ikarus::StressTags</qualifiedname>
        <enumvalue id="a00400_1gga70b4ce43c53cc5e949d49919f437501ea19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga70b4ce43c53cc5e949d49919f437501ea9a932b3cb396238423eb2f33ec17d6aa" prot="public">
          <name>linear</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga70b4ce43c53cc5e949d49919f437501eab13248d68ac5516c015337b68346fc21" prot="public">
          <name>PK2</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga70b4ce43c53cc5e949d49919f437501eac34dd77ffb9238275b93ea1897664a7e" prot="public">
          <name>PK1</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga70b4ce43c53cc5e949d49919f437501ea2ee21c55474972b3e65b31a6b0b57dc8" prot="public">
          <name>Cauchy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga70b4ce43c53cc5e949d49919f437501eadb46969ba633ea08a9181d8eb6218ba9" prot="public">
          <name>Kirchhoff</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga70b4ce43c53cc5e949d49919f437501eab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the computed stresses. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="26" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="26" bodyend="26"/>
      </memberdef>
      <memberdef kind="enum" id="a00400_1ga05ac785124262c1e323d2f937d520a1b" prot="public" static="no" strong="yes">
        <type></type>
        <name>TangentModuliTags</name>
        <qualifiedname>Ikarus::TangentModuliTags</qualifiedname>
        <enumvalue id="a00400_1gga05ac785124262c1e323d2f937d520a1ba19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga05ac785124262c1e323d2f937d520a1bad92a8333dd3ccb895cc65f7455b71206" prot="public">
          <name>Material</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga05ac785124262c1e323d2f937d520a1ba33d7f1ec5fe18e7ba799474138e71504" prot="public">
          <name>Spatial</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga05ac785124262c1e323d2f937d520a1ba331d16a2885c7f82ba949f286f48143d" prot="public">
          <name>TwoPoint</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00400_1gga05ac785124262c1e323d2f937d520a1bab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the computed tangent moduli. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="33" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="33" bodyend="33"/>
      </memberdef>
      <memberdef kind="enum" id="a00411_1aec3d3c4647af5c01e1bf18637b3c89fe" prot="public" static="no" strong="yes">
        <type></type>
        <name>PrincipalStretchTags</name>
        <qualifiedname>Ikarus::PrincipalStretchTags</qualifiedname>
        <enumvalue id="a00411_1aec3d3c4647af5c01e1bf18637b3c89fea19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1aec3d3c4647af5c01e1bf18637b3c89feafbb44b4487415b134bce9c790a27fe5e" prot="public">
          <name>total</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1aec3d3c4647af5c01e1bf18637b3c89feaae6dc167631992e1312a197d5c3c39f8" prot="public">
          <name>deviatoric</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1aec3d3c4647af5c01e1bf18637b3c89feab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A strongly typed enum class representing the type of the the principal strechts used in hyperelastic materials. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="40" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="40" bodyend="40"/>
      </memberdef>
      <memberdef kind="enum" id="a00411_1a731a9ee6621f91193c15f31b9a399906" prot="public" static="no" strong="yes">
        <type></type>
        <name>SolverTypeTag</name>
        <qualifiedname>Ikarus::SolverTypeTag</qualifiedname>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a334c4a4c42fdb79d7ebc3e73b517e6f8" prot="public">
          <name>none</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a43e7ad1498548ecfbe9359418877c793" prot="public">
          <name>si_ConjugateGradient</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a64a3b585d23ed07479c1452d49f397bb" prot="public">
          <name>si_LeastSquaresConjugateGradient</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a3ba09bd833aa666cbeca9bfd4a33be6f" prot="public">
          <name>si_BiCGSTAB</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906acd4c06ca3bfe2246c9ec45bee84b5852" prot="public">
          <name>sd_SimplicialLLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906af493d8a2d2d89f06181e77bc79cabf1c" prot="public">
          <name>sd_SimplicialLDLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906ae7cfd15be408672026faa788c0c112e5" prot="public">
          <name>sd_SparseLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a259246f1b3299da36945e32f5660bebd" prot="public">
          <name>sd_SparseQR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a286dc99776bcd1ea313e669aa17b3236" prot="public">
          <name>sd_CholmodSupernodalLLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906afe6a46ed15566813699daa9c9cbf85d5" prot="public">
          <name>sd_UmfPackLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906aa8fe11042608f12d110c154033361fcc" prot="public">
          <name>sd_SuperLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a97eafebe024f68db956c95519ddf66f2" prot="public">
          <name>d_PartialPivLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a4c20d1c5006d9987b894313a4af5de6e" prot="public">
          <name>d_FullPivLU</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a290d38c1d75cda978733c7ee8266e16e" prot="public">
          <name>d_HouseholderQR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906af66de0478863779eca4d9e7dcf39c59a" prot="public">
          <name>d_ColPivHouseholderQR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a9be60de1df84a8b371f0ad372aba4582" prot="public">
          <name>d_FullPivHouseholderQR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906ae1f5f0486da0c6645a75c3df39d8d942" prot="public">
          <name>d_CompleteOrthogonalDecomposition</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906a40c05e324bcfe6242fddbef28720e86a" prot="public">
          <name>d_LLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906ad495de2cc8831501954c24afe8688190" prot="public">
          <name>d_LDLT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a731a9ee6621f91193c15f31b9a399906ab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration representing different solver types. </para>
        </briefdescription>
        <detaileddescription>
<para>The prefix s and d stand for sparse and dense solvers and the second prefix i and d stand for iterative or direct solvers for the sparse case </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" line="31" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" bodystart="31" bodyend="31"/>
      </memberdef>
      <memberdef kind="enum" id="a00411_1a4763ca5888a027ed9b8d965d67cbb9ab" prot="public" static="no" strong="yes">
        <type></type>
        <name>MatrixTypeTag</name>
        <qualifiedname>Ikarus::MatrixTypeTag</qualifiedname>
        <enumvalue id="a00411_1a4763ca5888a027ed9b8d965d67cbb9aba9a71a13863c84ba34fc41595fc2ee0c6" prot="public">
          <name>Dense</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1a4763ca5888a027ed9b8d965d67cbb9aba7407fb7e6a4df6392aaabd2368157312" prot="public">
          <name>Sparse</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration representing different matrix types (Dense or Sparse). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" line="37" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" bodystart="38" bodyend="41"/>
      </memberdef>
      <memberdef kind="enum" id="a00411_1ace28d4868cfc647491f7938f04ef6c66" prot="public" static="no" strong="yes">
        <type></type>
        <name>PreConditioner</name>
        <qualifiedname>Ikarus::PreConditioner</qualifiedname>
        <enumvalue id="a00411_1ace28d4868cfc647491f7938f04ef6c66a7a24b184ba388b8e327feb98dbe168ff" prot="public">
          <name>IncompleteCholesky</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1ace28d4868cfc647491f7938f04ef6c66a7a93111b975ec3c3824eab230f3ec608" prot="public">
          <name>IdentityPreconditioner</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1ace28d4868cfc647491f7938f04ef6c66a3c6b5404db3b7bf45a0302f376a53afc" prot="public">
          <name>DiagonalPreconditioner</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration of available preconditioners for the trust region solver. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" line="33" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" bodystart="34" bodyend="38"/>
      </memberdef>
      <memberdef kind="enum" id="a00411_1abd5d0cf356d1ae81f6ee827b0f47c674" prot="public" static="no" strong="yes">
        <type></type>
        <name>StopReason</name>
        <qualifiedname>Ikarus::StopReason</qualifiedname>
        <enumvalue id="a00411_1abd5d0cf356d1ae81f6ee827b0f47c674a0c4f44592a7ae85baf42cb3fb4a5a3d1" prot="public">
          <name>gradientNormTolReached</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1abd5d0cf356d1ae81f6ee827b0f47c674ad1c6a6016de417acc66b5ac44a1fdca3" prot="public">
          <name>correctionNormTolReached</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1abd5d0cf356d1ae81f6ee827b0f47c674ad205528fe2a4412b89626ff7eee936f9" prot="public">
          <name>maximumTimeReached</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1abd5d0cf356d1ae81f6ee827b0f47c674a5ed07f9461b91dd3a6ba961a0ed5c8fe" prot="public">
          <name>maximumIterationsReached</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00411_1abd5d0cf356d1ae81f6ee827b0f47c674a8d2fa9685be8b8f8994bd8a73bfa8c9f" prot="public">
          <name>dontStop</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration of reasons for stopping the <ref refid="a01850" kindref="compound">TrustRegion</ref> solver. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" line="110" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" bodystart="111" bodyend="117"/>
      </memberdef>
      <memberdef kind="enum" id="a00405_1ga35fa62fd2d4186a9750af3d0692f2893" prot="public" static="no" strong="yes">
        <type></type>
        <name>ControlMessages</name>
        <qualifiedname>Ikarus::ControlMessages</qualifiedname>
        <enumvalue id="a00405_1gga35fa62fd2d4186a9750af3d0692f2893a19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga35fa62fd2d4186a9750af3d0692f2893a3fbccdb8d4ddfe10b3c9ee45ed07aad0" prot="public">
          <name>CONTROL_STARTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga35fa62fd2d4186a9750af3d0692f2893a1c32d268de88f801deb25166d98a3938" prot="public">
          <name>CONTROL_ENDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga35fa62fd2d4186a9750af3d0692f2893a18e0c9ecde68d13f1d2608dd1a180945" prot="public">
          <name>STEP_STARTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga35fa62fd2d4186a9750af3d0692f2893ae2b2386af3d7379bd2ddde735d5867b2" prot="public">
          <name>STEP_ENDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga35fa62fd2d4186a9750af3d0692f2893a0d30d757bf062e88728ebe7f8e2b2577" prot="public">
          <name>SOLUTION_CHANGED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga35fa62fd2d4186a9750af3d0692f2893ab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enum class defining control-routine-related messages. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/observer/observermessages.hh" line="16" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/observer/observermessages.hh" bodystart="17" bodyend="25"/>
      </memberdef>
      <memberdef kind="enum" id="a00405_1ga662b2b6a80547adf4b9ce8b30d87fab5" prot="public" static="no" strong="yes">
        <type></type>
        <name>NonLinearSolverMessages</name>
        <qualifiedname>Ikarus::NonLinearSolverMessages</qualifiedname>
        <enumvalue id="a00405_1gga662b2b6a80547adf4b9ce8b30d87fab5a19aad9f2fe3ce0023298ab83f7e75775" prot="public">
          <name>BEGIN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga662b2b6a80547adf4b9ce8b30d87fab5afaee4ca3c30ee18148ce3ada37466498" prot="public">
          <name>INIT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga662b2b6a80547adf4b9ce8b30d87fab5afdb2cb9832d112cd92fb2cda8879c3b4" prot="public">
          <name>ITERATION_STARTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga662b2b6a80547adf4b9ce8b30d87fab5a073d71a89cce6d4b9775987fdbb22815" prot="public">
          <name>ITERATION_ENDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga662b2b6a80547adf4b9ce8b30d87fab5a721c68980ba6c47122945477a56d7a14" prot="public">
          <name>RESIDUALNORM_UPDATED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga662b2b6a80547adf4b9ce8b30d87fab5a07a63a77745ab72a7e89fb22a8bcfd78" prot="public">
          <name>CORRECTIONNORM_UPDATED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga662b2b6a80547adf4b9ce8b30d87fab5a0d30d757bf062e88728ebe7f8e2b2577" prot="public">
          <name>SOLUTION_CHANGED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga662b2b6a80547adf4b9ce8b30d87fab5a15380ac35d47cdbcbd64aada4bc21931" prot="public">
          <name>FINISHED_SUCESSFULLY</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="a00405_1gga662b2b6a80547adf4b9ce8b30d87fab5ab1a326c06d88bf042f73d70f50197905" prot="public">
          <name>END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enum class defining non-linear solver-related messages. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/observer/observermessages.hh" line="31" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/observer/observermessages.hh" bodystart="32" bodyend="42"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="a00411_1a2afda25e777ed3a794da319ba535b87b" prot="public" static="no">
        <type><ref refid="a01798" kindref="compound">LinearSolverTemplate</ref>&lt; double &gt;</type>
        <definition>using Ikarus::LinearSolver = typedef LinearSolverTemplate&lt;double&gt;</definition>
        <argsstring></argsstring>
        <name>LinearSolver</name>
        <qualifiedname>Ikarus::LinearSolver</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" line="235" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" bodystart="235" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="a00411_1a98cbe3aef4b3238ea7de77ee9c4c19ac" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class PreBasis</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="a01934" kindref="compound">FlatPreBasis</ref>&lt; PreBasis &gt;::type</type>
        <definition>using Ikarus::FlatPreBasis_t = typedef typename FlatPreBasis&lt;PreBasis&gt;::type</definition>
        <argsstring></argsstring>
        <name>FlatPreBasis_t</name>
        <qualifiedname>Ikarus::FlatPreBasis_t</qualifiedname>
        <briefdescription>
<para>Type alias for flatted PreBasis. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" line="53" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" bodystart="53" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="a00411_1a79f92cdef4ce37a01fd76e7cbc460cb4" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00411_1aab9e3e38507d1db7602bc750718c302a" kindref="member">VectorAffordance</ref></type>
        <definition>constexpr VectorAffordance Ikarus::forces</definition>
        <argsstring></argsstring>
        <name>forces</name>
        <qualifiedname>Ikarus::forces</qualifiedname>
        <initializer>= VectorAffordance::forces</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="169" column="35" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="169" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="a00411_1a5bd2b9f6fec9989fd5e5e9d7e3cd986e" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00411_1a390d5311179ec61d163a29c943b3d1a0" kindref="member">MatrixAffordance</ref></type>
        <definition>constexpr MatrixAffordance Ikarus::stiffness</definition>
        <argsstring></argsstring>
        <name>stiffness</name>
        <qualifiedname>Ikarus::stiffness</qualifiedname>
        <initializer>= MatrixAffordance::stiffness</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="171" column="35" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="171" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="a00411_1a0ceb0c9442d4755cb5c2bd47ea46a22f" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00411_1a390d5311179ec61d163a29c943b3d1a0" kindref="member">MatrixAffordance</ref></type>
        <definition>constexpr MatrixAffordance Ikarus::stiffnessdiffBucklingVector</definition>
        <argsstring></argsstring>
        <name>stiffnessdiffBucklingVector</name>
        <qualifiedname>Ikarus::stiffnessdiffBucklingVector</qualifiedname>
        <initializer>= MatrixAffordance::stiffnessdiffBucklingVector</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="172" column="35" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="172" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="a00411_1ad8479f7f6217f57442ec18948b7aece1" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00411_1a390d5311179ec61d163a29c943b3d1a0" kindref="member">MatrixAffordance</ref></type>
        <definition>constexpr MatrixAffordance Ikarus::mass</definition>
        <argsstring></argsstring>
        <name>mass</name>
        <qualifiedname>Ikarus::mass</qualifiedname>
        <initializer>= MatrixAffordance::mass</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="173" column="35" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="173" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="a00411_1a8c6efe61469638e139724dc7c9bdaa9d" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="a00411_1af6f894084edd9109762b86222995ef2a" kindref="member">ScalarAffordance</ref></type>
        <definition>constexpr ScalarAffordance Ikarus::potentialEnergy</definition>
        <argsstring></argsstring>
        <name>potentialEnergy</name>
        <qualifiedname>Ikarus::potentialEnergy</qualifiedname>
        <initializer>= <ref refid="a00411_1af6f894084edd9109762b86222995ef2aa814f34f472acef493e9ecf0ffccdcae6" kindref="member">ScalarAffordance::mechanicalPotentialEnergy</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="174" column="35" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="174" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="a00411_1aae9d6a05f2ca4f54c0524404e27e7ed1" prot="public" static="yes" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>template&lt; typename, int, int &gt; class</type>
            <declname>RT1</declname>
            <defname>RT1</defname>
          </param>
          <param>
            <type>template&lt; typename, int, int &gt; class</type>
            <declname>RT2</declname>
            <defname>RT2</defname>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool Ikarus::isSameResultType</definition>
        <argsstring></argsstring>
        <name>isSameResultType</name>
        <qualifiedname>Ikarus::isSameResultType</qualifiedname>
        <initializer>= std::is_same_v&lt;Impl::DummyRT&lt;RT1&gt;, Impl::DummyRT&lt;RT2&gt;&gt;</initializer>
        <briefdescription>
<para>Meta variable to test whether two ResultType templates are the same. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>RT1</parametername>
</parameternamelist>
<parameterdescription>
<para>first ResultType template </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RT2</parametername>
</parameternamelist>
<parameterdescription>
<para>second ResultType template </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/feresulttypes.hh" line="258" column="23" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/feresulttypes.hh" bodystart="258" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="a00406_1ga8bdeefaffd49685e7dcd89f34af51d76" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto Ikarus::voigtNotationContainer</definition>
        <argsstring></argsstring>
        <name>voigtNotationContainer</name>
        <qualifiedname>Ikarus::voigtNotationContainer</qualifiedname>
        <initializer>= std::get&lt;dim - 1&gt;(Impl::voigtIndices)</initializer>
        <briefdescription>
<para>Container for Voigt notation indices based on dimension.</para>
<para>1D: 0,0 2D: 0,0; 1,1; 0,1 3D: 0,0; 1,1; 2,2; 1,2; 0,2; 0,1. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>The dimension for which Voigt indices are needed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="483" column="16" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="483" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="a00411_1afc83c2d114028f47280b981daf728ebe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename A</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeAssemblerManipulator</definition>
        <argsstring>(A &amp;&amp;a)</argsstring>
        <name>makeAssemblerManipulator</name>
        <qualifiedname>Ikarus::makeAssemblerManipulator</qualifiedname>
        <param>
          <type>A &amp;&amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Creates an <ref refid="a01278" kindref="compound">AssemblerManipulator</ref> instance based on the type of the provided assembler. </para>
        </briefdescription>
        <detaileddescription>
<para>This function constructs an appropriate <ref refid="a01278" kindref="compound">AssemblerManipulator</ref> for the given assembler object, utilizing different interface and implementation templates based on the assembler&apos;s capabilities.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the assembler. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>An assembler object to be wrapped by the <ref refid="a01278" kindref="compound">AssemblerManipulator</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An instance of <ref refid="a01278" kindref="compound">AssemblerManipulator</ref> wrapping the provided assembler. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/assembler/assemblermanipulatorfuser.hh" line="358" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/assembler/assemblermanipulatorfuser.hh" bodystart="358" bodyend="375"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aef80b6b5b45dcfbea4f722f51a84f53f" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(DBCOption _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00411_1a9f83fad9f4c149f249165a13f2370eec" kindref="member">DBCOption</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/assembler/dirichletbcenforcement.hh" line="7" column="47" bodyfile="/__w/ikarus/ikarus/repo/ikarus/assembler/dirichletbcenforcement.hh" bodystart="7" bodyend="7"/>
        <referencedby refid="a01486_1a71e905f315ca4efee16150b0c43fbabe" compoundref="a00284" startline="238" endline="280">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::calculateMatrixImpl</referencedby>
        <referencedby refid="a01486_1ac901c3457b487e52ca4c40ccfb1e69a6" compoundref="a00284" startline="316" endline="339">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::calculateScalarImpl</referencedby>
        <referencedby refid="a01486_1a14aa1287417c41d90c1f9cad4738cc93" compoundref="a00284" startline="283" endline="313">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::calculateVectorImpl</referencedby>
        <referencedby refid="a01558_1af415cd72d105db7efb92a77286c3ed61" compoundref="a00263" startline="60" endline="62">Ikarus::Materials::OgdenT&lt; ST_, n, tag &gt;::name</referencedby>
        <referencedby refid="a00429_1a0c58c17676c73945cb11eff8a80309ae" compoundref="a00155" startline="51" endline="71">Ikarus::Python::registerCalculateAt</referencedby>
        <referencedby refid="a00403_1ga9f62f91fc33b1f9e17756c2ac7b30077" compoundref="a03095" startline="50" endline="93">Ikarus::Python::registerVtkWriter</referencedby>
        <referencedby refid="a00411_1ae9c1868f27f4754a448edbbc97b9a2f2" compoundref="a00302" startline="248" endline="250">toString</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1a7b31ad9106d0c3d4052413bcbf5ea596" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FEC</type>
          </param>
          <param>
            <type>typename DV</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeSparseFlatAssembler</definition>
        <argsstring>(FEC &amp;&amp;fes, const DV &amp;dirichletValues)</argsstring>
        <name>makeSparseFlatAssembler</name>
        <qualifiedname>Ikarus::makeSparseFlatAssembler</qualifiedname>
        <param>
          <type>FEC &amp;&amp;</type>
          <declname>fes</declname>
        </param>
        <param>
          <type>const DV &amp;</type>
          <declname>dirichletValues</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/assembler/simpleassemblers.hh" line="175" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/assembler/simpleassemblers.hh" bodystart="175" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aa2e289f3c26f24717a19b05b5561538c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FEC</type>
          </param>
          <param>
            <type>typename DV</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeDenseFlatAssembler</definition>
        <argsstring>(FEC &amp;&amp;fes, const DV &amp;dirichletValues)</argsstring>
        <name>makeDenseFlatAssembler</name>
        <qualifiedname>Ikarus::makeDenseFlatAssembler</qualifiedname>
        <param>
          <type>FEC &amp;&amp;</type>
          <declname>fes</declname>
        </param>
        <param>
          <type>const DV &amp;</type>
          <declname>dirichletValues</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/assembler/simpleassemblers.hh" line="229" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/assembler/simpleassemblers.hh" bodystart="229" bodyend="231"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a59639a9a20f036a4f1c0794f65595662" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>useFlat</declname>
            <defname>useFlat</defname>
            <defval>true</defval>
          </param>
          <param>
            <type>bool</type>
            <declname>useEigenRef</declname>
            <defname>useEigenRef</defname>
            <defval>false</defval>
          </param>
          <param>
            <type>typename BH</type>
          </param>
          <param>
            <type>typename SK</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeFE</definition>
        <argsstring>(const BH &amp;basisHandler, const SK &amp;sk)</argsstring>
        <name>makeFE</name>
        <qualifiedname>Ikarus::makeFE</qualifiedname>
        <param>
          <type>const BH &amp;</type>
          <declname>basisHandler</declname>
        </param>
        <param>
          <type>const SK &amp;</type>
          <declname>sk</declname>
        </param>
        <briefdescription>
<para>A function to create a finite element using the flat version of the basis. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>BH</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the basis handler. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SK</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the skills. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>useFlat</parametername>
</parameternamelist>
<parameterdescription>
<para>A boolean indicating if the the underlying basis should be handed out as flat or the untouched version. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>useEigenRef</parametername>
</parameternamelist>
<parameterdescription>
<para>A boolean flag indicating whether to use <ref refid="a00427" kindref="compound">Eigen</ref> references. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>basisHandler</parametername>
</parameternamelist>
<parameterdescription>
<para>The basis handler. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sk</parametername>
</parameternamelist>
<parameterdescription>
<para>Skill arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An <ref refid="a01382" kindref="compound">FEFactory</ref> object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/fefactory.hh" line="68" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/fefactory.hh" bodystart="68" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aa80712fed165a22f02670f195488fe5f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>useEigenRef</declname>
            <defname>useEigenRef</defname>
            <defval>false</defval>
          </param>
          <param>
            <type>typename BH</type>
          </param>
          <param>
            <type>typename SK</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeFEWithUnTouchedBasis</definition>
        <argsstring>(const BH &amp;basisHandler, SK &amp;&amp;sk)</argsstring>
        <name>makeFEWithUnTouchedBasis</name>
        <qualifiedname>Ikarus::makeFEWithUnTouchedBasis</qualifiedname>
        <param>
          <type>const BH &amp;</type>
          <declname>basisHandler</declname>
        </param>
        <param>
          <type>SK &amp;&amp;</type>
          <declname>sk</declname>
        </param>
        <briefdescription>
<para>A function to create a finite element using the untouched version of the basis. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>BH</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the basis handler. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SK</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the skills.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>useEigenRef</parametername>
</parameternamelist>
<parameterdescription>
<para>A boolean flag indicating whether to use <ref refid="a00427" kindref="compound">Eigen</ref> references. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>basisHandler</parametername>
</parameternamelist>
<parameterdescription>
<para>The basis handler. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sk</parametername>
</parameternamelist>
<parameterdescription>
<para>Skill arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An <ref refid="a01382" kindref="compound">FEFactory</ref> object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/fefactory.hh" line="85" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/fefactory.hh" bodystart="85" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a93cb7668686a4b4a64389ca0a2533449" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(ScalarAffordance _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00411_1af6f894084edd9109762b86222995ef2a" kindref="member">ScalarAffordance</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="37" column="54" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="37" bodyend="37"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aecab2e77f1da6ec0d77b728b96f7fed8" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(VectorAffordance _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00411_1aab9e3e38507d1db7602bc750718c302a" kindref="member">VectorAffordance</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="48" column="54" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="48" bodyend="48"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a1e09faefb9fb22635de50c3d3ee57954" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(MatrixAffordance _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00411_1a390d5311179ec61d163a29c943b3d1a0" kindref="member">MatrixAffordance</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="63" column="54" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="63" bodyend="63"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a2b95b51e82bcb7c8990ff20bd8273ebf" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(FEParameter _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00398_1ga0c1577fd05efee8475b0f7fef795bbbe" kindref="member">FEParameter</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="74" column="49" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="74" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1ad313676e121358d0076db4f79fbce4be" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(FESolutions _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00398_1gaea763c94a1cecbeefc4f8661debcc5a3" kindref="member">FESolutions</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="87" column="49" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="87" bodyend="87"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a2597fb8b5ba646668b01bcc4e5f75818" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::vectorAffordance</definition>
        <argsstring>(MatrixAffordance affordanceM)</argsstring>
        <name>vectorAffordance</name>
        <qualifiedname>Ikarus::vectorAffordance</qualifiedname>
        <param>
          <type><ref refid="a00411_1a390d5311179ec61d163a29c943b3d1a0" kindref="member">MatrixAffordance</ref></type>
          <declname>affordanceM</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="176" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="176" bodyend="183"/>
        <referencedby refid="a01302_1a392677d4c1009af6a51fd6865f6a0775" compoundref="a03065" startline="360" endline="362">Ikarus::VectorAssembler&lt; VA, FEC, DV, VT &gt;::vector</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1a9f58a3849d4736e5cc314f6f995fe9e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::scalarAffordance</definition>
        <argsstring>(MatrixAffordance affordanceM)</argsstring>
        <name>scalarAffordance</name>
        <qualifiedname>Ikarus::scalarAffordance</qualifiedname>
        <param>
          <type><ref refid="a00411_1a390d5311179ec61d163a29c943b3d1a0" kindref="member">MatrixAffordance</ref></type>
          <declname>affordanceM</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="185" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="185" bodyend="192"/>
        <referencedby refid="a01298_1a0049c0dddc7ffb131777fff41da83f5d" compoundref="a03065" startline="292" endline="295">Ikarus::ScalarAssembler&lt; SA, FEC, DV, ST &gt;::scalar</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1ac600b73743c56f0668ae66be56c37c87" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::scalarAffordance</definition>
        <argsstring>(VectorAffordance affordanceV)</argsstring>
        <name>scalarAffordance</name>
        <qualifiedname>Ikarus::scalarAffordance</qualifiedname>
        <param>
          <type><ref refid="a00411_1aab9e3e38507d1db7602bc750718c302a" kindref="member">VectorAffordance</ref></type>
          <declname>affordanceV</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" line="194" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/ferequirements.hh" bodystart="194" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a38629395c2d43ba44328b01ce0c0daf3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename, int, int &gt; class</type>
            <declname>RT</declname>
            <defname>RT</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeRT</definition>
        <argsstring>()</argsstring>
        <name>makeRT</name>
        <qualifiedname>Ikarus::makeRT</qualifiedname>
        <briefdescription>
<para>Creates a dummy resultType which can be stored in a variable. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>RT</parametername>
</parameternamelist>
<parameterdescription>
<para>The ResultType template </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The ResultType </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/feresulttypes.hh" line="238" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/feresulttypes.hh" bodystart="238" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1ae9c1868f27f4754a448edbbc97b9a2f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename, int, int &gt; class</type>
            <declname>RT</declname>
            <defname>RT</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::toString</definition>
        <argsstring>()</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <briefdescription>
<para>Retrieves a string representation of the ResultType template. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>RT</parametername>
</parameternamelist>
<parameterdescription>
<para>the ResultType template </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the name of the ResultType </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/feresulttypes.hh" line="248" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/feresulttypes.hh" bodystart="248" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a95d330fd032b3ed38354e893a814d33a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::eas</definition>
        <argsstring>(int numberOfEASParameters=0)</argsstring>
        <name>eas</name>
        <qualifiedname>Ikarus::eas</qualifiedname>
        <param>
          <type>int</type>
          <declname>numberOfEASParameters</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>A helper function to create an enhanced assumed strain pre finite element. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>numberOfEASParameters</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of <ref refid="a00419" kindref="compound">EAS</ref> parameters </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An enhanced assumed strain pre finite element. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/enhancedassumedstrains.hh" line="277" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/enhancedassumedstrains.hh" bodystart="277" bodyend="281"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aecb794f40bd585f77e094976751ba41e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::kirchhoffLoveShell</definition>
        <argsstring>(const KlArgs &amp;args)</argsstring>
        <name>kirchhoffLoveShell</name>
        <qualifiedname>Ikarus::kirchhoffLoveShell</qualifiedname>
        <param>
          <type>const <ref refid="a01498" kindref="compound">KlArgs</ref> &amp;</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>A helper function to create a Kirchhoff-Love shell pre finite element. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>Arguments for the Kirchhoff-Love shell element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A Kirchhoff-Love shell pre finite element. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/kirchhoffloveshell.hh" line="445" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/kirchhoffloveshell.hh" bodystart="445" bodyend="449"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1af9e2c0087fa5819ca15d064776034a6f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MAT</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::linearElastic</definition>
        <argsstring>(const MAT &amp;mat)</argsstring>
        <name>linearElastic</name>
        <qualifiedname>Ikarus::linearElastic</qualifiedname>
        <param>
          <type>const MAT &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
<para>A helper function to create a linear elastic pre finite element. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MAT</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the material. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mat</parametername>
</parameternamelist>
<parameterdescription>
<para>Material parameters for the non-linear elastic element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A linear elastic pre finite element. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/linearelastic.hh" line="282" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/linearelastic.hh" bodystart="282" bodyend="286"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1ac2ae666c1ffd22e3c22a3418ab390893" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GV</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::neumannBoundaryLoad</definition>
        <argsstring>(const BoundaryPatch&lt; GV &gt; *patch, F &amp;&amp;load)</argsstring>
        <name>neumannBoundaryLoad</name>
        <qualifiedname>Ikarus::neumannBoundaryLoad</qualifiedname>
        <param>
          <type>const BoundaryPatch&lt; GV &gt; *</type>
          <declname>patch</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>load</declname>
        </param>
        <briefdescription>
<para>A helper function to create a Neumann boundary load skill. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>GV</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the grid view. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the Neumann boundary load functor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>patch</parametername>
</parameternamelist>
<parameterdescription>
<para>The patch where Neumann boundary load is applied. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>load</parametername>
</parameternamelist>
<parameterdescription>
<para>The neumann boundary load functor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A Neumann boundary load skill. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/loads/traction.hh" line="165" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/loads/traction.hh" bodystart="165" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a93a9eac09126da6a203f68af3e7c8ba2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>Ikarus::VolumeLoadPre</definition>
        <argsstring>(F f) -&gt; VolumeLoadPre&lt; traits::FunctionTraits&lt; F &gt;::return_type::RowsAtCompileTime &gt;</argsstring>
        <name>VolumeLoadPre</name>
        <qualifiedname>Ikarus::VolumeLoadPre</qualifiedname>
        <param>
          <type>F</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/loads/volume.hh" line="34" column="1" declfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/loads/volume.hh" declline="34" declcolumn="1"/>
        <referencedby refid="a00429_1a1f597ae7aac82dc24a8a2669f86fc12b" compoundref="a00149" startline="115" endline="119">Ikarus::Python::registerVolumeLoadPre</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1a0eecc01634324520df56c4352eb15077" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>worldDim</declname>
            <defname>worldDim</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::volumeLoad</definition>
        <argsstring>(const std::function&lt; Eigen::Vector&lt; double, worldDim &gt;(const Dune::FieldVector&lt; double, worldDim &gt; &amp;, const double &amp;)&gt; &amp;f)</argsstring>
        <name>volumeLoad</name>
        <qualifiedname>Ikarus::volumeLoad</qualifiedname>
        <param>
          <type>const std::function&lt; Eigen::Vector&lt; double, worldDim &gt;(const <ref refid="a01910" kindref="compound">Dune::FieldVector</ref>&lt; double, worldDim &gt; &amp;, const double &amp;)&gt; &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A helper function to create a volume load skill. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>worldDim</parametername>
</parameternamelist>
<parameterdescription>
<para>The world dimension. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>A function representing the volume load. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A volume load skill. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/loads/volume.hh" line="128" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/loads/volume.hh" bodystart="128" bodyend="132"/>
        <referencedby refid="a00429_1a813121e686b5d64d6ef1e11bd4bfc59b" compoundref="a00149" startline="93" endline="103">Ikarus::Python::registerNeumannBoundaryLoadPre</referencedby>
        <referencedby refid="a00429_1a1f597ae7aac82dc24a8a2669f86fc12b" compoundref="a00149" startline="115" endline="119">Ikarus::Python::registerVolumeLoadPre</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1a5038b2eef0efbcc123415c92d15b588d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::volumeLoad</definition>
        <argsstring>(F &amp;&amp;f)</argsstring>
        <name>volumeLoad</name>
        <qualifiedname>Ikarus::volumeLoad</qualifiedname>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A helper function to create a volume load skill. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>A function representing the volume load. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A volume load skill. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/loads/volume.hh" line="140" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/loads/volume.hh" bodystart="140" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="a00399_1gad5aa30fe829c7316a0a744b3438609f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>StrainTags</type>
            <declname>tag</declname>
            <defname>tag</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::createGreenLagrangianStrains</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;eMB)</argsstring>
        <name>createGreenLagrangianStrains</name>
        <qualifiedname>Ikarus::createGreenLagrangianStrains</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>eMB</declname>
        </param>
        <briefdescription>
<para>Create Green-Lagrangian strain based on the input. </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates Green-Lagrangian strains based on the input strain matrix. What to do is decided by the provided strain tag</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eMB</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00427" kindref="compound">Eigen</ref> matrix representing the input strain. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The Green-Lagrangian strains matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" line="46" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" bodystart="46" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="a00399_1ga5293eb09f12e4a45a7aa19a3403a73d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>StrainTags</type>
            <declname>tag</declname>
            <defname>tag</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::createDeformationGradient</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;eMB)</argsstring>
        <name>createDeformationGradient</name>
        <qualifiedname>Ikarus::createDeformationGradient</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>eMB</declname>
        </param>
        <briefdescription>
<para>Create the deformation gradient based on the input. </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates deformation gradient based on the input strain matrix. What to do is decided by the provided strain tag</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eMB</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00427" kindref="compound">Eigen</ref> matrix representing the input strain. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The deformation gradient matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" line="71" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" bodystart="71" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="a00399_1gae53e0e7999f565fc94610d1c4ede0d16" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>StrainTags</type>
            <declname>tag</declname>
            <defname>tag</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::createRightCauchyGreen</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;eMB)</argsstring>
        <name>createRightCauchyGreen</name>
        <qualifiedname>Ikarus::createRightCauchyGreen</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>eMB</declname>
        </param>
        <briefdescription>
<para>Create right Cauchy-Green tensor based on the input. </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates Right Cauchy-Green tensor based on the input strain matrix. What to do is decided by the provided strain tag</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eMB</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00427" kindref="compound">Eigen</ref> matrix representing the input strain. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The Right Cauchy-Green tensor matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" line="102" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" bodystart="102" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="a00399_1gae9c00f19ce473d7183c87aa84b247f88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>StrainTags</type>
            <declname>from</declname>
            <defname>from</defname>
          </param>
          <param>
            <type>StrainTags</type>
            <declname>to</declname>
            <defname>to</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::transformStrain</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;eRaw)</argsstring>
        <name>transformStrain</name>
        <qualifiedname>Ikarus::transformStrain</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>eRaw</declname>
        </param>
        <briefdescription>
<para>Transform strain from one type to another. </para>
        </briefdescription>
        <detaileddescription>
<para>This function transforms one strain component matrix from one type to another, based on the provided strain tags</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>from</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the source strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>to</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the target strain tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eRaw</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00427" kindref="compound">Eigen</ref> matrix representing the input strain (can be in Voigt notation). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The transformed strain matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" line="132" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/strainconversions.hh" bodystart="132" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aabe2255ec3392fe00a383dd05d7dfe8a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(StrainTags _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00400_1gacef1e451de1a99845c59d7391064fb8f" kindref="member">StrainTags</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="19" column="48" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="19" bodyend="19"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a31d0fcb0973be69c8c36cc4cbcb70c11" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(StressTags _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00400_1ga70b4ce43c53cc5e949d49919f437501e" kindref="member">StressTags</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="26" column="48" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="26" bodyend="26"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a1146e010b8f52fa9a883f064b3aa389a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(TangentModuliTags _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00400_1ga05ac785124262c1e323d2f937d520a1b" kindref="member">TangentModuliTags</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="33" column="55" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="33" bodyend="33"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a255878a42301d3dfe1051c30a590ceaf" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(PrincipalStretchTags _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00411_1aec3d3c4647af5c01e1bf18637b3c89fe" kindref="member">PrincipalStretchTags</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" line="40" column="58" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/materials/tags.hh" bodystart="40" bodyend="40"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a6f028adf5a1a78301381fe92b241d550" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MAT</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::nonLinearElastic</definition>
        <argsstring>(const MAT &amp;mat)</argsstring>
        <name>nonLinearElastic</name>
        <qualifiedname>Ikarus::nonLinearElastic</qualifiedname>
        <param>
          <type>const MAT &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
<para>A helper function to create a non-linear elastic pre finite element. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MAT</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the material. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mat</parametername>
</parameternamelist>
<parameterdescription>
<para>Material parameters for the non-linear elastic element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A non-linear elastic pre finite element. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/nonlinearelastic.hh" line="321" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/nonlinearelastic.hh" bodystart="321" bodyend="325"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a1936b02a190200901c54cc8b1004506e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::truss</definition>
        <argsstring>(const double E, const double A)</argsstring>
        <name>truss</name>
        <qualifiedname>Ikarus::truss</qualifiedname>
        <param>
          <type>const double</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>A helper function to create a truss pre finite element. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Young&apos;s modulus of the truss member </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Cross section area of the truss member </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A truss pre finite element. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/truss.hh" line="231" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mechanics/truss.hh" bodystart="231" bodyend="235"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aefa492686bced0d5d9235bdb112f482e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::skills</definition>
        <argsstring>(const Args &amp;... args)</argsstring>
        <name>skills</name>
        <qualifiedname>Ikarus::skills</qualifiedname>
        <param>
          <type>const Args &amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Function to create a <ref refid="a01686" kindref="compound">Skills</ref> instance with the given skills. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>Variadic template parameters representing the skills. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>Variadic arguments representing the skills. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="a01686" kindref="compound">Skills</ref> instance containing the specified skills. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mixin.hh" line="282" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mixin.hh" bodystart="282" bodyend="284"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a4f5729471c2a5801482188e6d42009ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args1</declname>
            <defname>Args1</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args2</declname>
            <defname>Args2</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::merge</definition>
        <argsstring>(const Skills&lt; Args1... &gt; &amp;sk1, const Skills&lt; Args2... &gt; &amp;sk2)</argsstring>
        <name>merge</name>
        <qualifiedname>Ikarus::merge</qualifiedname>
        <param>
          <type>const <ref refid="a01686" kindref="compound">Skills</ref>&lt; Args1... &gt; &amp;</type>
          <declname>sk1</declname>
        </param>
        <param>
          <type>const <ref refid="a01686" kindref="compound">Skills</ref>&lt; Args2... &gt; &amp;</type>
          <declname>sk2</declname>
        </param>
        <briefdescription>
<para>Function to merge two <ref refid="a01686" kindref="compound">Skills</ref> instances. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Args1</parametername>
</parameternamelist>
<parameterdescription>
<para>Variadic template parameters representing the skills of the first instance. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args2</parametername>
</parameternamelist>
<parameterdescription>
<para>Variadic template parameters representing the skills of the second instance. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sk1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first <ref refid="a01686" kindref="compound">Skills</ref> instance. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sk2</parametername>
</parameternamelist>
<parameterdescription>
<para>The second <ref refid="a01686" kindref="compound">Skills</ref> instance. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new <ref refid="a01686" kindref="compound">Skills</ref> instance containing the merged skills. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mixin.hh" line="296" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/mixin.hh" bodystart="296" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a5e27551f9edaebc557108aa164899b54" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01714" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01690" kindref="compound">YoungsModulusAndPoissonsRatio</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; YoungsModulusAndPoissonsRatio &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const YoungsModulusAndPoissonsRatio &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01690" kindref="compound">YoungsModulusAndPoissonsRatio</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="250" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="250" bodyend="253"/>
        <referencedby refid="a00411_1a32940ef922d090491ffcaa9bf2a44aef" compoundref="a00194" startline="281" endline="286">toLamesFirstParameterAndShearModulus</referencedby>
        <referencedby refid="a00411_1a4161393d679e5ec44806e6e911e26dee" compoundref="a00194" startline="294" endline="299">toYoungsModulusAndPoissonsRatio</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1a6a85c01d9e8f0e2adff8035087485109" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01714" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01694" kindref="compound">YoungsModulusAndShearModulus</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; YoungsModulusAndShearModulus &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const YoungsModulusAndShearModulus &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01694" kindref="compound">YoungsModulusAndShearModulus</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="254" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="254" bodyend="257"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1ad80fc80be73cb847542e1b7c5bde5af6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01714" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01698" kindref="compound">YoungsModulusAndBulkModulus</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; YoungsModulusAndBulkModulus &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const YoungsModulusAndBulkModulus &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01698" kindref="compound">YoungsModulusAndBulkModulus</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="258" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="258" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aec5648541007a5e5bb89c1f64ec2da92" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01714" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01710" kindref="compound">LamesFirstParameterAndShearModulus</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; LamesFirstParameterAndShearModulus &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const LamesFirstParameterAndShearModulus &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01710" kindref="compound">LamesFirstParameterAndShearModulus</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="262" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="262" bodyend="265"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a8c72e37743694391da18e64618a7c799" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01714" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01706" kindref="compound">BulkModulusAndLamesFirstParameter</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; BulkModulusAndLamesFirstParameter &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const BulkModulusAndLamesFirstParameter &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01706" kindref="compound">BulkModulusAndLamesFirstParameter</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="266" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="266" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a4e7b46d2ddcd68dfe864489ffb003ca3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="a01714" kindref="compound">ConvertLameConstants</ref>&lt; <ref refid="a01702" kindref="compound">YoungsModulusAndLamesFirstParameter</ref> &gt;</type>
        <definition>ConvertLameConstants&lt; YoungsModulusAndLamesFirstParameter &gt; Ikarus::convertLameConstants</definition>
        <argsstring>(const YoungsModulusAndLamesFirstParameter &amp;valuePair)</argsstring>
        <name>convertLameConstants</name>
        <qualifiedname>Ikarus::convertLameConstants</qualifiedname>
        <param>
          <type>const <ref refid="a01702" kindref="compound">YoungsModulusAndLamesFirstParameter</ref> &amp;</type>
          <declname>valuePair</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="270" column="29" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="270" bodyend="273"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a32940ef922d090491ffcaa9bf2a44aef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::toLamesFirstParameterAndShearModulus</definition>
        <argsstring>(const YoungsModulusAndPoissonsRatio &amp;matParameter)</argsstring>
        <name>toLamesFirstParameterAndShearModulus</name>
        <qualifiedname>Ikarus::toLamesFirstParameterAndShearModulus</qualifiedname>
        <param>
          <type>const <ref refid="a01690" kindref="compound">YoungsModulusAndPoissonsRatio</ref> &amp;</type>
          <declname>matParameter</declname>
        </param>
        <briefdescription>
<para>Converts Young&apos;s modulus and Poisson&apos;s ratio to Lame&apos;s first parameter and shear modulus. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>matParameter</parametername>
</parameternamelist>
<parameterdescription>
<para>Young&apos;s modulus and Poisson&apos;s ratio. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Lame&apos;s first parameter and shear modulus. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="281" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="281" bodyend="286"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a4161393d679e5ec44806e6e911e26dee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::toYoungsModulusAndPoissonsRatio</definition>
        <argsstring>(const LamesFirstParameterAndShearModulus &amp;matParameter)</argsstring>
        <name>toYoungsModulusAndPoissonsRatio</name>
        <qualifiedname>Ikarus::toYoungsModulusAndPoissonsRatio</qualifiedname>
        <param>
          <type>const <ref refid="a01710" kindref="compound">LamesFirstParameterAndShearModulus</ref> &amp;</type>
          <declname>matParameter</declname>
        </param>
        <briefdescription>
<para>Converts Lame&apos;s first parameter and shear modulus to Young&apos;s modulus and Poisson&apos;s ratio. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>matParameter</parametername>
</parameternamelist>
<parameterdescription>
<para>Lame&apos;s first parameter and shear modulus. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Young&apos;s modulus and Poisson&apos;s ratio. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" line="294" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/finiteelements/physicshelper.hh" bodystart="294" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aba0432efad1cef6c956ccf108829682c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename, int, int &gt; class</type>
            <declname>RT</declname>
            <defname>RT</defname>
          </param>
          <param>
            <type>typename UserFunction</type>
            <defval>Impl::DefaultUserFunction</defval>
          </param>
          <param>
            <type>Concepts::FlatAssembler</type>
            <declname>AS</declname>
            <defname>AS</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeResultFunction</definition>
        <argsstring>(std::shared_ptr&lt; AS &gt; assembler, Dune::VTK::Precision prec=Dune::VTK::Precision::float64, UserFunction &amp;&amp;userFunction={})</argsstring>
        <name>makeResultFunction</name>
        <qualifiedname>Ikarus::makeResultFunction</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; AS &gt;</type>
          <declname>assembler</declname>
        </param>
        <param>
          <type>Dune::VTK::Precision</type>
          <declname>prec</declname>
          <defval>Dune::VTK::Precision::float64</defval>
        </param>
        <param>
          <type>UserFunction &amp;&amp;</type>
          <declname>userFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Function to create a <ref refid="a01742" kindref="compound">ResultFunction</ref> as a shared_ptr. </para>
        </briefdescription>
        <detaileddescription>
<para>Constructs a <ref refid="a01742" kindref="compound">ResultFunction</ref> object with given assembler as shared_ptr to be used with the native <ref refid="a00434" kindref="compound">Dune</ref> VTKWriter <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>assembler</parametername>
</parameternamelist>
<parameterdescription>
<para>shared pointer to the underlying assembler (provides the finite elements and the requested results) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>AS</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the assembler </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RT</parametername>
</parameternamelist>
<parameterdescription>
<para>requested result type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UserFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the user-defined function for custom result evaluation (default is DefaultUserFunction) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>assembler</parametername>
</parameternamelist>
<parameterdescription>
<para>shared pointer to the underlying assembler (provides the finite elements and the requested results) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prec</parametername>
</parameternamelist>
<parameterdescription>
<para>(optional) specify the used precision </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>userFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>(optional) the user function (default is DefaultUserFunction) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/io/resultfunction.hh" line="180" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/io/resultfunction.hh" bodystart="180" bodyend="184"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aa4430d7f94a172d765fba38d393450a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename, int, int &gt; class</type>
            <declname>RT</declname>
            <defname>RT</defname>
          </param>
          <param>
            <type>typename UserFunction</type>
          </param>
          <param>
            <type>Concepts::FlatAssembler</type>
            <declname>AS</declname>
            <defname>AS</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeResultFunction</definition>
        <argsstring>(std::shared_ptr&lt; AS &gt; assembler, UserFunction &amp;&amp;userFunction)</argsstring>
        <name>makeResultFunction</name>
        <qualifiedname>Ikarus::makeResultFunction</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; AS &gt;</type>
          <declname>assembler</declname>
        </param>
        <param>
          <type>UserFunction &amp;&amp;</type>
          <declname>userFunction</declname>
        </param>
        <briefdescription>
<para>Function to create a <ref refid="a01742" kindref="compound">ResultFunction</ref> as a shared_ptr. </para>
        </briefdescription>
        <detaileddescription>
<para>Constructs a <ref refid="a01742" kindref="compound">ResultFunction</ref> object with given assembler as shared_ptr to be used with the native <ref refid="a00434" kindref="compound">Dune</ref> VTKWriter <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>AS</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the assembler </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RT</parametername>
</parameternamelist>
<parameterdescription>
<para>requested result type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UserFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the user-defined function for custom result evaluation (default is DefaultUserFunction) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>assembler</parametername>
</parameternamelist>
<parameterdescription>
<para>shared pointer to the underlying assembler (provides the finite elements and the requested results) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>userFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>the user function </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/io/resultfunction.hh" line="197" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/io/resultfunction.hh" bodystart="197" bodyend="199"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1ad8472943b9877db27039331c847154f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename, int, int &gt; class</type>
            <declname>RT</declname>
            <defname>RT</defname>
          </param>
          <param>
            <type>typename UserFunction</type>
            <defval>Impl::DefaultUserFunction</defval>
          </param>
          <param>
            <type>Concepts::FlatAssembler</type>
            <declname>AS</declname>
            <defname>AS</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeResultVtkFunction</definition>
        <argsstring>(std::shared_ptr&lt; AS &gt; assembler, UserFunction &amp;&amp;userFunction={})</argsstring>
        <name>makeResultVtkFunction</name>
        <qualifiedname>Ikarus::makeResultVtkFunction</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; AS &gt;</type>
          <declname>assembler</declname>
        </param>
        <param>
          <type>UserFunction &amp;&amp;</type>
          <declname>userFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Function to create a <ref refid="a01742" kindref="compound">ResultFunction</ref> as a gridfunction that can be used with dune-vtk. </para>
        </briefdescription>
        <detaileddescription>
<para>Constructs a <ref refid="a01742" kindref="compound">ResultFunction</ref> object with given finite elements, ferequirements as a VTK::Function to be used with dune-vtk It is possible to construct a localFunction from this as follows <programlisting><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>localResultFunction<sp/>=<sp/>localFunction(vtkResultFunction);</highlight></codeline>
<codeline><highlight class="normal">localResultFunction.bind(element);</highlight></codeline>
</programlisting> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>AS</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the assembler </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RT</parametername>
</parameternamelist>
<parameterdescription>
<para>requested result type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UserFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the user-defined function for custom result evaluation (default is DefaultUserFunction) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>userFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>(optional) the user function (default is DefaultUserFunction) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>assembler</parametername>
</parameternamelist>
<parameterdescription>
<para>shared pointer to the underlying assembler (provides the finite elements and the requested results) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/io/resultfunction.hh" line="219" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/io/resultfunction.hh" bodystart="219" bodyend="222"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a206e0bf186f2215991c45880183b4845" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::string</type>
        <definition>constexpr std::string Ikarus::toString</definition>
        <argsstring>(SolverTypeTag _e)</argsstring>
        <name>toString</name>
        <qualifiedname>Ikarus::toString</qualifiedname>
        <param>
          <type><ref refid="a00411_1a731a9ee6621f91193c15f31b9a399906" kindref="member">SolverTypeTag</ref></type>
          <declname>_e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" line="31" column="51" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/linearsolver/linearsolver.hh" bodystart="31" bodyend="31"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a66b45c139b5d57965ada53d92d8f93ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>typename NRConfig</type>
          </param>
        </templateparamlist>
        <type>::value auto</type>
        <definition>::value auto Ikarus::createNonlinearSolver</definition>
        <argsstring>(NRConfig &amp;&amp;config, NLO &amp;&amp;nonLinearOperator)</argsstring>
        <name>createNonlinearSolver</name>
        <qualifiedname>Ikarus::createNonlinearSolver</qualifiedname>
        <param>
          <type>NRConfig &amp;&amp;</type>
          <declname>config</declname>
        </param>
        <param>
          <type>NLO &amp;&amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
    <requiresclause>traits::isSpecialization&lt;NewtonRaphsonConfig, std::remove_cvref_t&lt;NRConfig&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Function to create a <ref refid="a01810" kindref="compound">NewtonRaphson</ref> solver instance. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NLO</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NRConfig</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear solver config. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>config</parametername>
</parameternamelist>
<parameterdescription>
<para>Config for the solver. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nonLinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Shared pointer to the <ref refid="a01810" kindref="compound">NewtonRaphson</ref> solver instance. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphson.hh" line="65" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphson.hh" bodystart="65" bodyend="90"/>
        <referencedby refid="a01834_1ae5da57e3dced6046dda504510e19bdbd" compoundref="a00125" startline="54" endline="65">Ikarus::NonlinearSolverFactory&lt; NLSSetting &gt;::create</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1afa463e708cffd14133ff65ffa366e329" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>typename LS</type>
            <defval>utils::SolverDefault</defval>
          </param>
          <param>
            <type>typename UF</type>
            <defval>utils::UpdateDefault</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeNewtonRaphson</definition>
        <argsstring>(const NLO &amp;nonLinearOperator, LS &amp;&amp;linearSolver={}, UF &amp;&amp;updateFunction={})</argsstring>
        <name>makeNewtonRaphson</name>
        <qualifiedname>Ikarus::makeNewtonRaphson</qualifiedname>
        <param>
          <type>const NLO &amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
        <param>
          <type>LS &amp;&amp;</type>
          <declname>linearSolver</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>UF &amp;&amp;</type>
          <declname>updateFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Function to create a <ref refid="a01810" kindref="compound">NewtonRaphson</ref> solver instance. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NLO</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>LS</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the linear solver used internally (default is SolverDefault). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UF</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>linearSolver</parametername>
</parameternamelist>
<parameterdescription>
<para>Linear solver used internally (default is SolverDefault). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Shared pointer to the <ref refid="a01810" kindref="compound">NewtonRaphson</ref> solver instance. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphson.hh" line="228" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphson.hh" bodystart="228" bodyend="231"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1acff40d61279eba58e16c3889d8c0a5f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>typename LS</type>
            <defval>utils::SolverDefault</defval>
          </param>
          <param>
            <type>typename UF</type>
            <defval>utils::UpdateDefault</defval>
          </param>
        </templateparamlist>
        <type></type>
        <definition>Ikarus::NewtonRaphson</definition>
        <argsstring>(const NLO &amp;nonLinearOperator, LS &amp;&amp;linearSolver={}, UF &amp;&amp;updateFunction={}) -&gt; NewtonRaphson&lt; NLO, std::remove_cvref_t&lt; LS &gt;, std::remove_cvref_t&lt; UF &gt; &gt;</argsstring>
        <name>NewtonRaphson</name>
        <qualifiedname>Ikarus::NewtonRaphson</qualifiedname>
        <param>
          <type>const NLO &amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
        <param>
          <type>LS &amp;&amp;</type>
          <declname>linearSolver</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>UF &amp;&amp;</type>
          <declname>updateFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphson.hh" line="234" column="1" declfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphson.hh" declline="234" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1adc267de956ce12d694f0302159d8d848" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>typename NRConfig</type>
          </param>
        </templateparamlist>
        <type>::value auto</type>
        <definition>::value auto Ikarus::createNonlinearSolver</definition>
        <argsstring>(NRConfig &amp;&amp;config, NLO &amp;&amp;nonLinearOperator)</argsstring>
        <name>createNonlinearSolver</name>
        <qualifiedname>Ikarus::createNonlinearSolver</qualifiedname>
        <param>
          <type>NRConfig &amp;&amp;</type>
          <declname>config</declname>
        </param>
        <param>
          <type>NLO &amp;&amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
    <requiresclause>traits::isSpecialization&lt;NewtonRaphsonWithSubsidiaryFunctionConfig, std::remove_cvref_t&lt;NRConfig&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Function to create a <ref refid="a01810" kindref="compound">NewtonRaphson</ref> with subsidiary function solver instance. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NLO</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NRConfig</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear solver config. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>config</parametername>
</parameternamelist>
<parameterdescription>
<para>Config for the solver. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nonLinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Shared pointer to the <ref refid="a01810" kindref="compound">NewtonRaphson</ref> solver instance. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphsonwithscalarsubsidiaryfunction.hh" line="66" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphsonwithscalarsubsidiaryfunction.hh" bodystart="66" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1ade2a979ee79a657c6ab7530ee203056f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>typename LS</type>
            <defval>utils::SolverDefault</defval>
          </param>
          <param>
            <type>typename UF</type>
            <defval>utils::UpdateDefault</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeNewtonRaphsonWithSubsidiaryFunction</definition>
        <argsstring>(const NLO &amp;nonLinearOperator, LS &amp;&amp;linearSolver={}, UF &amp;&amp;updateFunction={})</argsstring>
        <name>makeNewtonRaphsonWithSubsidiaryFunction</name>
        <qualifiedname>Ikarus::makeNewtonRaphsonWithSubsidiaryFunction</qualifiedname>
        <param>
          <type>const NLO &amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
        <param>
          <type>LS &amp;&amp;</type>
          <declname>linearSolver</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>UF &amp;&amp;</type>
          <declname>updateFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Function to create a <ref refid="a01810" kindref="compound">NewtonRaphson</ref> with subsidiary function solver instance. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NLO</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>LS</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the linear solver used internally (default is SolverDefault). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UF</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>linearSolver</parametername>
</parameternamelist>
<parameterdescription>
<para>Linear solver used internally (default is SolverDefault). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Shared pointer to the <ref refid="a01810" kindref="compound">NewtonRaphson</ref> solver instance. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphsonwithscalarsubsidiaryfunction.hh" line="278" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphsonwithscalarsubsidiaryfunction.hh" bodystart="278" bodyend="282"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1acc2addd732412fa64b99546b6d07a60b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>typename LS</type>
            <defval>utils::SolverDefault</defval>
          </param>
          <param>
            <type>typename UF</type>
            <defval>utils::UpdateDefault</defval>
          </param>
        </templateparamlist>
        <type></type>
        <definition>Ikarus::NewtonRaphsonWithSubsidiaryFunction</definition>
        <argsstring>(const NLO &amp;nonLinearOperator, LS &amp;&amp;linearSolver={}, UF &amp;&amp;updateFunction={}) -&gt; NewtonRaphsonWithSubsidiaryFunction&lt; NLO, std::remove_cvref_t&lt; LS &gt;, std::remove_cvref_t&lt; UF &gt; &gt;</argsstring>
        <name>NewtonRaphsonWithSubsidiaryFunction</name>
        <qualifiedname>Ikarus::NewtonRaphsonWithSubsidiaryFunction</qualifiedname>
        <param>
          <type>const NLO &amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
        <param>
          <type>LS &amp;&amp;</type>
          <declname>linearSolver</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>UF &amp;&amp;</type>
          <declname>updateFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphsonwithscalarsubsidiaryfunction.hh" line="285" column="1" declfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/newtonraphsonwithscalarsubsidiaryfunction.hh" declline="285" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a8785899121b52f1b6ffe3a43b1a5df61" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>typename TRConfig</type>
          </param>
        </templateparamlist>
        <type>::value auto</type>
        <definition>::value auto Ikarus::createNonlinearSolver</definition>
        <argsstring>(TRConfig &amp;&amp;config, NLO &amp;&amp;nonLinearOperator)</argsstring>
        <name>createNonlinearSolver</name>
        <qualifiedname>Ikarus::createNonlinearSolver</qualifiedname>
        <param>
          <type>TRConfig &amp;&amp;</type>
          <declname>config</declname>
        </param>
        <param>
          <type>NLO &amp;&amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
    <requiresclause>traits::isSpecializationNonTypeAndTypes&lt;TrustRegionConfig, std::remove_cvref_t&lt;TRConfig&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Function to create a trust region non-linear solver. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NLO</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TRConfig</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear solver config. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>config</parametername>
</parameternamelist>
<parameterdescription>
<para>Config for the solver. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nonLinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Shared pointer to the <ref refid="a01850" kindref="compound">TrustRegion</ref> solver instance. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" line="94" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" bodystart="94" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a547326eb09552d3d1fed0830d0e2d269" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>PreConditioner</type>
            <declname>preConditioner</declname>
            <defname>preConditioner</defname>
            <defval>PreConditioner::IncompleteCholesky</defval>
          </param>
          <param>
            <type>typename UF</type>
            <defval>utils::UpdateDefault</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeTrustRegion</definition>
        <argsstring>(const NLO &amp;nonLinearOperator, UF &amp;&amp;updateFunction={})</argsstring>
        <name>makeTrustRegion</name>
        <qualifiedname>Ikarus::makeTrustRegion</qualifiedname>
        <param>
          <type>const NLO &amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
        <param>
          <type>UF &amp;&amp;</type>
          <declname>updateFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Creates an instance of the <ref refid="a01850" kindref="compound">TrustRegion</ref> solver. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NLO</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>preConditioner</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the preconditioner used internally (default is IncompleteCholesky). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UF</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Nonlinear operator to solve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function (default is UpdateDefault). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Shared pointer to the <ref refid="a01850" kindref="compound">TrustRegion</ref> solver instance. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" line="537" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" bodystart="537" bodyend="539"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a8d76e20d6a74e339f85d98c9854ee89c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NLO</type>
          </param>
          <param>
            <type>PreConditioner</type>
            <declname>preConditioner</declname>
            <defname>preConditioner</defname>
            <defval>PreConditioner::IncompleteCholesky</defval>
          </param>
          <param>
            <type>typename UF2</type>
            <defval>utils::UpdateDefault</defval>
          </param>
        </templateparamlist>
        <type></type>
        <definition>Ikarus::TrustRegion</definition>
        <argsstring>(const NLO &amp;nonLinearOperator, UF2 &amp;&amp;updateFunction={}) -&gt; TrustRegion&lt; NLO, preConditioner, std::remove_cvref_t&lt; UF2 &gt; &gt;</argsstring>
        <name>TrustRegion</name>
        <qualifiedname>Ikarus::TrustRegion</qualifiedname>
        <param>
          <type>const NLO &amp;</type>
          <declname>nonLinearOperator</declname>
        </param>
        <param>
          <type>UF2 &amp;&amp;</type>
          <declname>updateFunction</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" line="543" column="1" declfile="/__w/ikarus/ikarus/repo/ikarus/solver/nonlinearsolver/trustregion.hh" declline="543" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a9acabb8291c86afe74e8617830e033de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GV</type>
          </param>
          <param>
            <type>typename PBF</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeBasis</definition>
        <argsstring>(const GV &amp;gv, const PBF &amp;pb)</argsstring>
        <name>makeBasis</name>
        <qualifiedname>Ikarus::makeBasis</qualifiedname>
        <param>
          <type>const GV &amp;</type>
          <declname>gv</declname>
        </param>
        <param>
          <type>const PBF &amp;</type>
          <declname>pb</declname>
        </param>
        <briefdescription>
<para>Factory function to create a Basis object. </para>
        </briefdescription>
        <detaileddescription>
<para>Factory function that creates a Basis object from a given grid view and pre-basis factory.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>GV</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the grid view. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PBF</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the pre-basis factory function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>gv</parametername>
</parameternamelist>
<parameterdescription>
<para>The grid view. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pb</parametername>
</parameternamelist>
<parameterdescription>
<para>The pre-basis factory function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A Basis object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/basis.hh" line="109" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/basis.hh" bodystart="109" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aa8350697b25edf5034483b28fb0c3f76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PB</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::makeBasis</definition>
        <argsstring>(const Dune::Functions::DefaultGlobalBasis&lt; PB &gt; &amp;gb)</argsstring>
        <name>makeBasis</name>
        <qualifiedname>Ikarus::makeBasis</qualifiedname>
        <param>
          <type>const Dune::Functions::DefaultGlobalBasis&lt; PB &gt; &amp;</type>
          <declname>gb</declname>
        </param>
        <briefdescription>
<para>Factory function to create a Basis object from a DefaultGlobalBasis. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PB</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the pre-basis associated with the DefaultGlobalBasis. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>gb</parametername>
</parameternamelist>
<parameterdescription>
<para>The DefaultGlobalBasis. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A Basis object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/basis.hh" line="123" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/basis.hh" bodystart="123" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1ac2c6469be19ce4ef2e630bfa1c5a5e24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::transpose</definition>
        <argsstring>(const Eigen::EigenBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>transpose</name>
        <qualifiedname>Ikarus::transpose</qualifiedname>
        <param>
          <type>const <ref refid="a01874" kindref="compound">Eigen::EigenBase</ref>&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/concepts.hh" line="36" column="6" declfile="/__w/ikarus/ikarus/repo/ikarus/utils/concepts.hh" declline="36" declcolumn="6"/>
        <referencedby refid="a01486_1ab64163b2440a36540cffe5be74981574" compoundref="a00284" startline="388" endline="407">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::bopBending</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1a0fdba7f3ebe4bf1ada6618f450b50221" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type><ref refid="a01910" kindref="compound">Dune::FieldVector</ref>&lt; ST, size &gt;</type>
        <definition>Dune::FieldVector&lt; ST, size &gt; Ikarus::toDune</definition>
        <argsstring>(const Eigen::Vector&lt; ST, size &gt; &amp;vec)</argsstring>
        <name>toDune</name>
        <qualifiedname>Ikarus::toDune</qualifiedname>
        <param>
          <type>const Eigen::Vector&lt; ST, size &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>Create Eigen::Vector to <ref refid="a01910" kindref="compound">Dune::FieldVector</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the vectors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the vectors. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>The Eigen::Vector to be converted. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Dune::FieldVector&lt;ST, size&gt; representing the converted vector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="30" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="30" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a4e9e21776afdaaa93c4a9d19554976fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>rows</declname>
            <defname>rows</defname>
          </param>
        </templateparamlist>
        <type><ref refid="a01910" kindref="compound">Dune::FieldVector</ref>&lt; ST, rows &gt;</type>
        <definition>Dune::FieldVector&lt; ST, rows &gt; Ikarus::toDune</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, rows, 0 &gt; &amp;vec)</argsstring>
        <name>toDune</name>
        <qualifiedname>Ikarus::toDune</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, rows, 0 &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>Convert Eigen::Matrix to <ref refid="a01910" kindref="compound">Dune::FieldVector</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>The matrix has fixed row size. The matrix needs to have a single column. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the vectors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rows</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of rows in the matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>The Eigen::Matrix to be converted. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Dune::FieldVector&lt;ST, rows&gt; representing the converted matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="47" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="47" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a83633e77ee5a35cb31a7cd2f02aedb7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>rows</declname>
            <defname>rows</defname>
          </param>
          <param>
            <type>int</type>
            <declname>cols</declname>
            <defname>cols</defname>
          </param>
        </templateparamlist>
        <type>Dune::FieldMatrix&lt; ST, rows, cols &gt;</type>
        <definition>Dune::FieldMatrix&lt; ST, rows, cols &gt; Ikarus::toDune</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, rows, cols &gt; &amp;mat)</argsstring>
        <name>toDune</name>
        <qualifiedname>Ikarus::toDune</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, rows, cols &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
<para>Convert Eigen::Matrix to Dune::FieldMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para>The matrix has fixed rows and column size <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rows</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of rows in the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cols</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of columns in the matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mat</parametername>
</parameternamelist>
<parameterdescription>
<para>The Eigen::Matrix to be converted. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Dune::FieldMatrix&lt;ST, rows, cols&gt; representing the converted matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="66" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="66" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aaa7e8e9b8bd8247afecc24cdd54ec658" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; const Eigen::Vector&lt; ST, size &gt; &gt;</type>
        <definition>Eigen::Map&lt; const Eigen::Vector&lt; ST, size &gt; &gt; Ikarus::toEigenMap</definition>
        <argsstring>(const Dune::FieldVector&lt; ST, size &gt; &amp;vec)</argsstring>
        <name>toEigenMap</name>
        <qualifiedname>Ikarus::toEigenMap</qualifiedname>
        <param>
          <type>const <ref refid="a01910" kindref="compound">Dune::FieldVector</ref>&lt; ST, size &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>View a <ref refid="a01910" kindref="compound">Dune::FieldVector</ref> as an Eigen::Vector using Map, no copies take place. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="a01910" kindref="compound">Dune::FieldVector</ref> to be viewed as Eigen::Vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map&lt;const Eigen::Vector&lt;ST, size&gt;&gt; representing the viewed vector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="83" column="12" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="83" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1aaac71220182c301ee8c864f2a507c3db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; Eigen::Vector&lt; ST, size &gt; &gt;</type>
        <definition>Eigen::Map&lt; Eigen::Vector&lt; ST, size &gt; &gt; Ikarus::toEigenMap</definition>
        <argsstring>(Dune::FieldVector&lt; ST, size &gt; &amp;vec)</argsstring>
        <name>toEigenMap</name>
        <qualifiedname>Ikarus::toEigenMap</qualifiedname>
        <param>
          <type><ref refid="a01910" kindref="compound">Dune::FieldVector</ref>&lt; ST, size &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>View a constant <ref refid="a01910" kindref="compound">Dune::FieldVector</ref> as a constant Eigen::Vector, no copies take place. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>The scalar type of the vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="a01910" kindref="compound">Dune::FieldVector</ref> to be viewed as Eigen::Vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map&lt;Eigen::Vector&lt;ST, size&gt;&gt; representing the viewed vector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" line="95" column="12" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/eigendunetransformations.hh" bodystart="95" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga0728039472747184e9eb2ec0992a4a2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PreBasis</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::flatPreBasis</definition>
        <argsstring>(const PreBasis &amp;preBasis)</argsstring>
        <name>flatPreBasis</name>
        <qualifiedname>Ikarus::flatPreBasis</qualifiedname>
        <param>
          <type>const PreBasis &amp;</type>
          <declname>preBasis</declname>
        </param>
        <briefdescription>
<para>Generator function for a flatted PreBasis. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" line="110" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" bodystart="110" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1ac8243891c1b961e50a066140ab79a142" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Ikarus::init</definition>
        <argsstring>(int argc, char **argv, bool enableFileLogger=true)</argsstring>
        <name>init</name>
        <qualifiedname>Ikarus::init</qualifiedname>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>enableFileLogger</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Initializes the <ref refid="a00411" kindref="compound">Ikarus</ref> framework. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of command-line arguments. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>The command-line arguments. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>enableFileLogger</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether to enable the file logger. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
<para><ulink url="https://patorjk.com/software/taag/#p=testall&amp;f=Univers&amp;t=IKARUS">https://patorjk.com/software/taag/#p=testall&amp;f=Univers&amp;t=IKARUS</ulink> (font: Lean)</para>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/init.hh" line="82" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/init.hh" bodystart="82" bodyend="107"/>
        <referencedby refid="a00429_1aad35f78683b64303a28d3b8b4f83aa37" compoundref="a00161" startline="70" endline="111">Ikarus::Python::registerAssemblerManipulator</referencedby>
        <referencedby refid="a00403_1ga2f6146bb687ad25cfb413fbcfd470788" compoundref="a03080" startline="37" endline="50">Ikarus::Python::registerBasisHandler</referencedby>
        <referencedby refid="a00429_1a331fd78be5a4155963abe5829282c8f1" compoundref="a00143" startline="16" endline="31">Ikarus::Python::registerBoundaryPatch</referencedby>
        <referencedby refid="a00403_1ga39b6df6adfe4858b13ac71f5830f29f6" compoundref="a03086" startline="147" endline="192">Ikarus::Python::registerDirichletValues</referencedby>
        <referencedby refid="a00429_1a79dfab8379c15a5c5da0d3e5a415f0a3" compoundref="a00149" startline="79" endline="81">Ikarus::Python::registerEnhancedAssumedStrainsPre</referencedby>
        <referencedby refid="a00403_1gac8bb4a818dee7342efbc5e174e35b840" compoundref="a00155" startline="87" endline="147">Ikarus::Python::registerFE</referencedby>
        <referencedby refid="a00429_1a32c3989a8ef1dbc581313ef17a0c6f5b" compoundref="a00152" startline="14" endline="48">Ikarus::Python::registerFERequirement</referencedby>
        <referencedby refid="a00403_1ga87d3c6e620be5df59ba6923751caae86" compoundref="a00164" startline="41" endline="124">Ikarus::Python::registerFlatAssembler</referencedby>
        <referencedby refid="a00429_1a0ef1ab14030985bd8af2551f51ceeeb6" compoundref="a00149" startline="64" endline="67">Ikarus::Python::registerKirchhoffLoveShellPre</referencedby>
        <referencedby refid="a00429_1a04d0c82e615a65a1ba027cb77bbf784d" compoundref="a00149" startline="35" endline="38">Ikarus::Python::registerLinearElasticPre</referencedby>
        <referencedby refid="a00429_1a3a4831265d4a775b43c50c25242a2910" compoundref="a00158" startline="107" endline="203">Ikarus::Python::registerMaterial</referencedby>
        <referencedby refid="a00429_1a813121e686b5d64d6ef1e11bd4bfc59b" compoundref="a00149" startline="93" endline="103">Ikarus::Python::registerNeumannBoundaryLoadPre</referencedby>
        <referencedby refid="a00429_1ab45b29a3ca18f1c8bf87263c60d14711" compoundref="a00149" startline="20" endline="23">Ikarus::Python::registerNonLinearElasticPre</referencedby>
        <referencedby refid="a00429_1a09b4a81e2d6d0619406854f6dc3fc8f7" compoundref="a00161" startline="54" endline="67">Ikarus::Python::registerSparseMatrixWrapper</referencedby>
        <referencedby refid="a00429_1a5004d72f594d4ceecaebb33ee71f80cf" compoundref="a00149" startline="50" endline="52">Ikarus::Python::registerTrussPre</referencedby>
        <referencedby refid="a00429_1a1f597ae7aac82dc24a8a2669f86fc12b" compoundref="a00149" startline="115" endline="119">Ikarus::Python::registerVolumeLoadPre</referencedby>
        <referencedby refid="a00403_1ga9f62f91fc33b1f9e17756c2ac7b30077" compoundref="a03095" startline="50" endline="93">Ikarus::Python::registerVtkWriter</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaa33adfa2e95d7040a816bb2da81d275d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::orthonormalizeMatrixColumns</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>orthonormalizeMatrixColumns</name>
        <qualifiedname>Ikarus::orthonormalizeMatrixColumns</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Orthonormalizes all Matrix columns using Gram-Schmidt Orthogonalization. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input matrix.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>The input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="a00427" kindref="compound">Eigen</ref> Matrix with orthonormalized columns. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="35" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="35" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga545d74839895f4576a3b8c97d72abefd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsFlatEigenVector</definition>
        <argsstring>(Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsFlatEigenVector</name>
        <qualifiedname>Ikarus::viewAsFlatEigenVector</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View Dune::BlockVector as an Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a flat Eigen::Vector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="57" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="57" bodyend="62"/>
        <referencedby refid="a01478_1afddcb054816acf30dd2f0543a67dc96c" compoundref="a00221" startline="103" endline="130">Ikarus::EnhancedAssumedStrains&lt; PreFE, FE &gt;::calculateAtImpl</referencedby>
        <referencedby refid="a01478_1a9febb77b55a78ae825f8627d2ad1e8c7" compoundref="a00221" startline="197" endline="234">Ikarus::EnhancedAssumedStrains&lt; PreFE, FE &gt;::calculateVectorImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga3beeb26c911116fa02df8756214484aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsFlatEigenVector</definition>
        <argsstring>(const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsFlatEigenVector</name>
        <qualifiedname>Ikarus::viewAsFlatEigenVector</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View const Dune::BlockVector as an Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a flat Eigen::Vector (const version). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="72" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="72" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaf9d7cf401f9f03ce1aae728c646ce178" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixAsDynFixed</definition>
        <argsstring>(Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixAsDynFixed</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixAsDynFixed</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View Dune::BlockVector as an Eigen::Matrix with dynamic rows and fixed columns depending on the size of the ValueType. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a dynamic Eigen::Matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="88" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="88" bodyend="93"/>
        <referencedby refid="a01486_1a2116db254c03a1873dc6d1d432d8eaa1" compoundref="a00284" startline="201" endline="235">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::computeMaterialAndStrains</referencedby>
        <referencedby refid="a01658_1aeab583c651a9704392133a98e58e6ad4" compoundref="a00281" startline="117" endline="158">Ikarus::Truss&lt; PreFE, FE &gt;::computeStrain</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaf1c6bdf14e40ee46e881f646e1c28b0d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixAsDynFixed</definition>
        <argsstring>(const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixAsDynFixed</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixAsDynFixed</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>Const view Dune::BlockVector as an Eigen::Matrix with dynamic rows and fixed columns depending on the size of the ValueType. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a dynamic Eigen::Matrix (const version). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="104" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="104" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gac25618d0e7c4aece653662d2541b61ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixFixedDyn</definition>
        <argsstring>(Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixFixedDyn</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixFixedDyn</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View Dune::BlockVector as an Eigen::Matrix with fixed rows depending on the size of the ValueType and dynamic columns. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a fixed-size Eigen::Matrix with dynamic columns. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="120" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="120" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga146a052f6eb97304a8172c7b65fe70fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixFixedDyn</definition>
        <argsstring>(const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixFixedDyn</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixFixedDyn</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>Const view Dune::BlockVector as an Eigen::Matrix with fixed rows depending on the size of the ValueType and dynamic columns. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a fixed-size Eigen::Matrix with dynamic columns (const version). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="135" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="135" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga609664964681787f2f736f772b82a01e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t Ikarus::correctionSize</definition>
        <argsstring>(const Dune::BlockVector&lt; Type &gt; &amp;a)</argsstring>
        <name>correctionSize</name>
        <qualifiedname>Ikarus::correctionSize</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
    <requiresclause>requires { Type::correctionSize; }    </requiresclause>
        <briefdescription>
<para>Returns the total correction size of a block vector with a Manifold as the underlying type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Total correction size. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="150" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="150" bodyend="154"/>
        <referencedby refid="a00406_1ga609664964681787f2f736f772b82a01e" compoundref="a00017" startline="150" endline="154">correctionSize</referencedby>
        <referencedby refid="a00406_1ga09cedf6a65b142340c1934c987ed064c" compoundref="a00017" startline="180" endline="188">operator+=</referencedby>
        <referencedby refid="a00406_1ga90c40b4eebec59eeb02294cd7cb0470c" compoundref="a00017" startline="200" endline="205">operator-=</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1gac1df27a0dfa864327029cdb906a1840c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t Ikarus::valueSize</definition>
        <argsstring>(const Dune::BlockVector&lt; Type &gt; &amp;a)</argsstring>
        <name>valueSize</name>
        <qualifiedname>Ikarus::valueSize</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
    <requiresclause>requires { Type::valueSize; }    </requiresclause>
        <briefdescription>
<para>Returns the total value size of a block vector with a Manifold as the underlying type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Total value size. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="164" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="164" bodyend="168"/>
        <referencedby refid="a00406_1gadab36ca6a3183fb9fedbb02b3ecba736" compoundref="a00017" startline="239" endline="248">addInEmbedding</referencedby>
        <referencedby refid="a00406_1gac1df27a0dfa864327029cdb906a1840c" compoundref="a00017" startline="164" endline="168">valueSize</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga09cedf6a65b142340c1934c987ed064c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
        <definition>Dune::BlockVector&lt; Type &gt; &amp; Ikarus::operator+=</definition>
        <argsstring>(Dune::BlockVector&lt; Type &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator+=</name>
        <qualifiedname>Ikarus::operator+=</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
    <requiresclause>(<ref refid="a02090" kindref="compound">Ikarus::Concepts::AddAssignAble</ref>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })    </requiresclause>
        <briefdescription>
<para>Enables the += operator for Dune::BlockVector += Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::BlockVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="180" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="180" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga90c40b4eebec59eeb02294cd7cb0470c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
        <definition>Dune::BlockVector&lt; Type &gt; &amp; Ikarus::operator-=</definition>
        <argsstring>(Dune::BlockVector&lt; Type &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator-=</name>
        <qualifiedname>Ikarus::operator-=</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
    <requiresclause>(<ref refid="a02090" kindref="compound">Ikarus::Concepts::AddAssignAble</ref>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })    </requiresclause>
        <briefdescription>
<para>Enables the -= operator for Dune::BlockVector += Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::BlockVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="200" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="200" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaada5360aeb17e59d87ae2ba82057421d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Types</declname>
            <defname>Types</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::TupleVector&lt; Types... &gt; &amp;</type>
        <definition>Dune::TupleVector&lt; Types... &gt; &amp; Ikarus::operator+=</definition>
        <argsstring>(Dune::TupleVector&lt; Types... &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator+=</name>
        <qualifiedname>Ikarus::operator+=</qualifiedname>
        <param>
          <type>Dune::TupleVector&lt; Types... &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Enables the += operator for Dune::TupleVector += Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Types</parametername>
</parameternamelist>
<parameterdescription>
<para>Types of the elements in the TupleVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::TupleVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::TupleVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="217" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="217" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gadab36ca6a3183fb9fedbb02b3ecba736" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ManifoldPoint</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::BlockVector&lt; ManifoldPoint &gt; &amp;</type>
        <definition>Dune::BlockVector&lt; ManifoldPoint &gt; &amp; Ikarus::addInEmbedding</definition>
        <argsstring>(Dune::BlockVector&lt; ManifoldPoint &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>addInEmbedding</name>
        <qualifiedname>Ikarus::addInEmbedding</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ManifoldPoint &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
    <requiresclause>(<ref refid="a02090" kindref="compound">Ikarus::Concepts::AddAssignAble</ref>&lt;ManifoldPoint, decltype(b.template segment&lt;ManifoldPoint::valueSize&gt;(0))&gt; and requires() { ManifoldPoint::valueSize; })    </requiresclause>
        <briefdescription>
<para>Enables the addition in the embedding space of a vector in the space M^n, where M is a manifold with the points of type ManifoldPoint. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ManifoldPoint</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>ManifoldPoint of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::BlockVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="239" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="239" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga0ffc0c74dbd9aeee3e53b199a21b828c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::norm</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;v)</argsstring>
        <name>norm</name>
        <qualifiedname>Ikarus::norm</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>v</declname>
        </param>
    <requiresclause>(!std::floating_point&lt;Derived&gt;)    </requiresclause>
        <briefdescription>
<para>Adding free norm function to <ref refid="a00427" kindref="compound">Eigen</ref> types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Norm of the matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="259" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="259" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaceb8dc8f6f43516dabf75155b1f22d4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::norm</definition>
        <argsstring>(const std::floating_point auto &amp;v)</argsstring>
        <name>norm</name>
        <qualifiedname>Ikarus::norm</qualifiedname>
        <param>
          <type>const std::floating_point auto &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Helper Free Function to have the same interface as for <ref refid="a00427" kindref="compound">Eigen</ref> Vector Types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>Input scalar. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Absolute value of the scalar. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="269" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="269" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gacbc60e06e8e43a9bc14660189eb1baa1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator*</definition>
        <argsstring>(const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</argsstring>
        <name>operator*</name>
        <qualifiedname>Ikarus::operator*</qualifiedname>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Eigen::DiagonalMatrix Product Missing in <ref refid="a00427" kindref="compound">Eigen</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Product of the two DiagonalMatrices. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="281" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="281" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga96968bbff353ac49f48d0aa8b9810b7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+=</definition>
        <argsstring>(Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</argsstring>
        <name>operator+=</name>
        <qualifiedname>Ikarus::operator+=</qualifiedname>
        <param>
          <type>Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>In-place addition for Eigen::DiagonalMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified DiagonalMatrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="295" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="295" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga098b554b29619e0cea837f3daa6e0e30" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Eigen::Matrix + Eigen::DiagonalMatrix addition missing in <ref refid="a00427" kindref="compound">Eigen</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of the <ref refid="a00427" kindref="compound">Eigen</ref> matrix and DiagonalMatrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="311" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="311" bodyend="315"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gafe54695fd1436b5f2d75934a6fda8fe8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Eigen::DiagonalMatrix + Eigen::Matrix addition missing in <ref refid="a00427" kindref="compound">Eigen</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of the DiagonalMatrix and <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="328" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="328" bodyend="330"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga9ab6437d6235e378a6171bfffd4bf1cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator-</definition>
        <argsstring>(const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a)</argsstring>
        <name>operator-</name>
        <qualifiedname>Ikarus::operator-</qualifiedname>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Unary minus for Eigen::DiagonalMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Negation of the DiagonalMatrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="341" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="341" bodyend="343"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga0fe1660eb760ecc49838d130ba6c6712" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Derived2</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;a, const Eigen::DiagonalWrapper&lt; Derived2 &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalWrapper&lt; Derived2 &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Addition of Eigen::Matrix and Eigen::DiagonalWrapper. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived2</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of <ref refid="a00427" kindref="compound">Eigen</ref> matrix and DiagonalWrapper. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="355" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="355" bodyend="359"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga9377cd2cf3a5ec468d140cb7063efa58" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Derived2</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::DiagonalWrapper&lt; Derived &gt; &amp;a, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::DiagonalWrapper&lt; Derived &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived2 &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Addition of Eigen::DiagonalWrapper and Eigen::Matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived2</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of DiagonalWrapper and <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="371" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="371" bodyend="373"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gac2cdcc3047e59b91a4874a1355503cd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; Ikarus::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>Ikarus::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Output stream operator for Eigen::DiagonalMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>os</parametername>
</parameternamelist>
<parameterdescription>
<para>Output stream. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the output stream. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="385" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="385" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gabd35ea7f69bcc71ee90ea421a1c48167" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Derived</type>
        <definition>Derived Ikarus::sym</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>sym</name>
        <qualifiedname>Ikarus::sym</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the symmetric part of a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Symmetric part of the matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="398" column="9" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="398" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga1496a9776a583f8b09c4244a68453394" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Derived</type>
        <definition>Derived Ikarus::skew</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>skew</name>
        <qualifiedname>Ikarus::skew</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the skew part of a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Skew part of the matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="410" column="9" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="410" bodyend="412"/>
        <referencedby refid="a01486_1a93f11b9294df96b1955867984fe71670" compoundref="a00284" startline="342" endline="385">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::kgBending</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga40c08050aff1e3e49e58c7823ecbcc77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Ikarus::printForMaple</definition>
        <argsstring>(const Eigen::EigenBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>printForMaple</name>
        <qualifiedname>Ikarus::printForMaple</qualifiedname>
        <param>
          <type>const <ref refid="a01874" kindref="compound">Eigen::EigenBase</ref>&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Method to print the matrix in a format that can directly be copied to Maple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>The derived type of the matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>The input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="421" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="421" bodyend="433"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga821ecf80e4a83241318d825f49cd79e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FieldVectorT</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::createRandomVector</definition>
        <argsstring>(typename FieldVectorT::value_type lower=-1, typename FieldVectorT::value_type upper=1)</argsstring>
        <name>createRandomVector</name>
        <qualifiedname>Ikarus::createRandomVector</qualifiedname>
        <param>
          <type>typename FieldVectorT::value_type</type>
          <declname>lower</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>typename FieldVectorT::value_type</type>
          <declname>upper</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Creates a random vector of the specified type within a given range. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>FieldVectorT</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lower</parametername>
</parameternamelist>
<parameterdescription>
<para>The lower bound of the random values (default is -1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>upper</parametername>
</parameternamelist>
<parameterdescription>
<para>The upper bound of the random values (default is 1). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A random vector within the specified range. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="444" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="444" bodyend="452"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gabf7cb564e7fa11a403cb8439e2436205" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; ScalarType, 3, 3 &gt;</type>
        <definition>Eigen::Matrix&lt; ScalarType, 3, 3 &gt; Ikarus::skew</definition>
        <argsstring>(const Eigen::Vector&lt; ScalarType, 3 &gt; &amp;a)</argsstring>
        <name>skew</name>
        <qualifiedname>Ikarus::skew</qualifiedname>
        <param>
          <type>const Eigen::Vector&lt; ScalarType, 3 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Create skew 3x3 matrix from 3d vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the coordinates in the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The skew matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="462" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="462" bodyend="466"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga19d425a4fbc72c2ef7a97d71de9329a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>size_t</type>
            <declname>sizeOfCondensedIndices</declname>
            <defname>sizeOfCondensedIndices</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::staticCondensation</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E, const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;indices)</argsstring>
        <name>staticCondensation</name>
        <qualifiedname>Ikarus::staticCondensation</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Performs static condensation on a square matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizeOfCondensedIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the condensed indices. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>indices</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of indices to be condensed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting matrix after static condensation.</para>
</simplesect>
This function performs static condensation on a square matrix. It removes the specified indices from the matrix, computes the remaining submatrices (K11, K12, K22), and returns the result of the static condensation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="498" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="498" bodyend="511"/>
        <referencedby refid="a01642_1a0ebefbbf6effdedcf7ce4238d5079394" compoundref="a00239" startline="117" endline="124">Ikarus::Materials::VanishingStress&lt; stressIndexPair, MI &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1af366ed9ed9329aecf202c8b170476efa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>size_t</type>
            <declname>sizeOfCondensedIndices</declname>
            <defname>sizeOfCondensedIndices</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::reduceMatrix</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E, const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;indices)</argsstring>
        <name>reduceMatrix</name>
        <qualifiedname>Ikarus::reduceMatrix</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="514" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="514" bodyend="524"/>
        <referencedby refid="a01638_1aa7bd7e40c6b4995a6e33dfba4ab88de0" compoundref="a00242" startline="113" endline="120">Ikarus::Materials::VanishingStrain&lt; strainIndexPair, MI &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga2f675229501979101656ec4dee7764d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>size_t</type>
            <declname>sizeOfRemovedCols</declname>
            <defname>sizeOfRemovedCols</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::removeCol</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E, const std::array&lt; size_t, sizeOfRemovedCols &gt; &amp;indices)</argsstring>
        <name>removeCol</name>
        <qualifiedname>Ikarus::removeCol</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const std::array&lt; size_t, sizeOfRemovedCols &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Removes specified columns from a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizeOfRemovedCols</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the columns to be removed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>indices</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of column indices to be removed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting matrix after removing specified columns.</para>
</simplesect>
This function removes specified columns from a matrix. It computes the remaining columns after removing the specified indices and returns the resulting matrix. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="539" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="539" bodyend="548"/>
        <referencedby refid="a01638_1aa29dd3baf16c20438b69d5f3e6590b57" compoundref="a00242" startline="93" endline="103">Ikarus::Materials::VanishingStrain&lt; strainIndexPair, MI &gt;::stressesImpl</referencedby>
        <referencedby refid="a01642_1a78bed662e2230b7aabafd97556400071" compoundref="a00239" startline="99" endline="107">Ikarus::Materials::VanishingStress&lt; stressIndexPair, MI &gt;::stressesImpl</referencedby>
        <referencedby refid="a00406_1ga378c5569b7b899586e7c8006fb776351" compoundref="a00017" startline="565" endline="578">toVoigtAndMaybeReduce</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga378c5569b7b899586e7c8006fb776351" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>typename MaterialImpl</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::toVoigtAndMaybeReduce</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, 3, 3 &gt; &amp;E, const MaterialImpl &amp;material, bool isStrain=true)</argsstring>
        <name>toVoigtAndMaybeReduce</name>
        <qualifiedname>Ikarus::toVoigtAndMaybeReduce</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, 3, 3 &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const MaterialImpl &amp;</type>
          <declname>material</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isStrain</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Converts a 3x3 matrix to Voigt notation, possibly reducing it based on material properties. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MaterialImpl</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the material implementation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input 3x3 matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>material</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to the material implementation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isStrain</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating if the matrix represents strain (default is true). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting matrix in Voigt notation.</para>
</simplesect>
This function converts a 3x3 matrix to its Voigt notation. If the material is not reduced, the full Voigt notation is returned. Otherwise, the specified columns (based on material properties, such as VanishingStress) are removed, and the reduced Voigt notation is returned. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="565" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="565" bodyend="578"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga30500f2c49b7d1997c7eb7b6ee90ad75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename M</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::enlargeIfReduced</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E)</argsstring>
        <name>enlargeIfReduced</name>
        <qualifiedname>Ikarus::enlargeIfReduced</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <briefdescription>
<para>Enlarges a matrix if it reduced in the context of material laws, i.e., VanishingStress If the material is not reduced the untouched matrix is returned and rendering the function as a NoOp. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>M</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the material. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto Resulting matrix based on material properties.</para>
</simplesect>
This function takes an input matrix and, based on the material properties, either returns the original matrix (if it is not reduced) or enlarges the matrix by filling in the specified columns with zeros (if it is reduced). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="593" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="593" bodyend="618"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga5db6e8f04892e85e6b17e276cdbd0e54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MessageType</type>
          </param>
        </templateparamlist>
        <type>MessageType &amp;</type>
        <definition>MessageType &amp; Ikarus::increment</definition>
        <argsstring>(MessageType &amp;e)</argsstring>
        <name>increment</name>
        <qualifiedname>Ikarus::increment</qualifiedname>
        <param>
          <type>MessageType &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Increments the given enum value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MessageType</parametername>
</parameternamelist>
<parameterdescription>
<para>The enum type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>The enum value to increment. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The incremented enum value. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>Dune::RangeError</parametername>
</parameternamelist>
<parameterdescription>
<para>if trying to increment MessageType::END. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/makeenum.hh" line="68" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/makeenum.hh" bodystart="68" bodyend="74"/>
        <referencedby refid="a02006_1ac8058d5b1ebb462a10712ba598154e23" compoundref="a00191" startline="131" endline="134">Ikarus::IObservable&lt; MessageType &gt;::IObservable</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1ae55d4d0c3478ab3ecf54ce905ddf223b" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr T</type>
        <definition>constexpr T Ikarus::ct_sqrt</definition>
        <argsstring>(T x)</argsstring>
        <name>ct_sqrt</name>
        <qualifiedname>Ikarus::ct_sqrt</qualifiedname>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
    <requiresclause>std::integral&lt;T&gt;    </requiresclause>
        <briefdescription>
<para>Compile-time square root for integer types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The integral type for which square root is calculated. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value for which square root is calculated. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr T The calculated square root. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/math.hh" line="47" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/math.hh" bodystart="47" bodyend="49"/>
        <referencedby refid="a00407_1gadc8e9e9f3838d0392a5fcf1e11374ee9" compoundref="a00032" startline="284" endline="314">fromVoigt</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1ac00abda505aa8ccc73ce59afd165ce49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::parameter</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>parameter</name>
        <qualifiedname>Ikarus::parameter</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Creates a Parameter object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument types. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>The tuple of arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto The Parameter object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" line="115" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" bodystart="115" bodyend="117"/>
        <referencedby refid="a01982_1a644858005534ab498b1802bb633bb37b" compoundref="a00029" startline="22" endline="65">Ikarus::NonLinearOperatorFactory::op</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1ab787b670f0d338c870988f417cf85f76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::functions</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>functions</name>
        <qualifiedname>Ikarus::functions</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Creates a Functions object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument types. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>The tuple of arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto The Functions object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" line="127" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" bodystart="127" bodyend="129"/>
        <referencedby refid="a01982_1a644858005534ab498b1802bb633bb37b" compoundref="a00029" startline="22" endline="65">Ikarus::NonLinearOperatorFactory::op</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1ab346d8d79af81fa5312a67cd8b4e6d9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>DerivativeArgs</declname>
            <defname>DerivativeArgs</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>ParameterArgs</declname>
            <defname>ParameterArgs</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::initResults</definition>
        <argsstring>(const std::tuple&lt; DerivativeArgs... &gt; &amp;derivativesFunctions, const std::tuple&lt; ParameterArgs... &gt; &amp;parameter)</argsstring>
        <name>initResults</name>
        <qualifiedname>Ikarus::initResults</qualifiedname>
        <param>
          <type>const std::tuple&lt; DerivativeArgs... &gt; &amp;</type>
          <declname>derivativesFunctions</declname>
        </param>
        <param>
          <type>const std::tuple&lt; ParameterArgs... &gt; &amp;</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Initializes the results for functions and parameters. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DerivativeArgs</parametername>
</parameternamelist>
<parameterdescription>
<para>The types of derivative arguments. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ParameterArgs</parametername>
</parameternamelist>
<parameterdescription>
<para>The types of parameter arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>derivativesFunctions</parametername>
</parameternamelist>
<parameterdescription>
<para>The Functions object for derivative arguments. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parameter</parametername>
</parameternamelist>
<parameterdescription>
<para>The Parameter object for parameter arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto The initialized results. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" line="141" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" bodystart="141" bodyend="146"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1abcf5978fa18a6e0aadc5e19c4a0edaa9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>DerivativeArgs</declname>
            <defname>DerivativeArgs</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>ParameterArgs</declname>
            <defname>ParameterArgs</defname>
          </param>
        </templateparamlist>
        <type></type>
        <definition>Ikarus::NonLinearOperator</definition>
        <argsstring>(const Impl::Functions&lt; DerivativeArgs &amp;&amp;... &gt; &amp;a, const Impl::Parameter&lt; ParameterArgs... &gt; &amp;b) -&gt; NonLinearOperator&lt; Impl::Functions&lt; DerivativeArgs... &gt;, Impl::Parameter&lt; ParameterArgs... &gt; &gt;</argsstring>
        <name>NonLinearOperator</name>
        <qualifiedname>Ikarus::NonLinearOperator</qualifiedname>
        <param>
          <type>const Impl::Functions&lt; DerivativeArgs &amp;&amp;... &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Impl::Parameter&lt; ParameterArgs... &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" line="382" column="1" declfile="/__w/ikarus/ikarus/repo/ikarus/utils/nonlinearoperator.hh" declline="382" declcolumn="1"/>
        <referencedby refid="a01982_1a644858005534ab498b1802bb633bb37b" compoundref="a00029" startline="22" endline="65">Ikarus::NonLinearOperatorFactory::op</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00411_1a839e2d8a648318c584c66024e62ddd91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class BaseQuadrature</type>
          </param>
          <param>
            <type>class Quadrature</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::tensorProductQuadrature</definition>
        <argsstring>(const BaseQuadrature &amp;baseQuad, const Quadrature &amp;onedQuad)</argsstring>
        <name>tensorProductQuadrature</name>
        <qualifiedname>Ikarus::tensorProductQuadrature</qualifiedname>
        <param>
          <type>const BaseQuadrature &amp;</type>
          <declname>baseQuad</declname>
        </param>
        <param>
          <type>const Quadrature &amp;</type>
          <declname>onedQuad</declname>
        </param>
        <briefdescription>
<para>Computes the tensor product quadrature rule using a base and one-dimensional quadrature rule. </para>
        </briefdescription>
        <detaileddescription>
<para>This function constructs a tensor product quadrature rule by combining a base quadrature rule and a one-dimensional quadrature rule. It iterates over the points of the base quadrature and combines them with each point of the one-dimensional quadrature.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>BaseQuadrature</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the base quadrature. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Quadrature</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the one-dimensional quadrature.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>baseQuad</parametername>
</parameternamelist>
<parameterdescription>
<para>The base quadrature rule. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>onedQuad</parametername>
</parameternamelist>
<parameterdescription>
<para>The one-dimensional quadrature rule.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Dune::QuadratureRule&lt;double, BaseQuadrature::d + 1&gt; - Tensor product quadrature rule. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorproductquadrule.hh" line="29" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorproductquadrule.hh" bodystart="29" bodyend="48"/>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga5cfd9d098384fb067d897b3c0499b447" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>auto</type>
            <declname>rank</declname>
            <defname>rank</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Tensor&lt; typename Derived::Scalar, rank &gt;</type>
        <definition>Eigen::Tensor&lt; typename Derived::Scalar, rank &gt; Ikarus::tensorView</definition>
        <argsstring>(const Eigen::EigenBase&lt; Derived &gt; &amp;matrix, const std::array&lt; T, rank &gt; &amp;dims)</argsstring>
        <name>tensorView</name>
        <qualifiedname>Ikarus::tensorView</qualifiedname>
        <param>
          <type>const <ref refid="a01874" kindref="compound">Eigen::EigenBase</ref>&lt; Derived &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type>const std::array&lt; T, rank &gt; &amp;</type>
          <declname>dims</declname>
        </param>
        <briefdescription>
<para>View an <ref refid="a00427" kindref="compound">Eigen</ref> matrix as an <ref refid="a00427" kindref="compound">Eigen</ref> Tensor with specified dimensions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rank</parametername>
</parameternamelist>
<parameterdescription>
<para>Rank of the resulting Tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix to be cast. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimensions of the resulting Tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Tensor&lt;typename Derived::Scalar, rank&gt; The casted <ref refid="a00427" kindref="compound">Eigen</ref> Tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="32" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="32" bodyend="37"/>
        <referencedby refid="a01486_1a0a02eda2ec4b244354d313e8c98568f6" compoundref="a00284" startline="415" endline="426">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::materialTangent</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00407_1gab2cea9ac847cc3635812467c9d96ceb4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::dyadic</definition>
        <argsstring>(const auto &amp;A_ij, const auto &amp;B_kl)</argsstring>
        <name>dyadic</name>
        <qualifiedname>Ikarus::dyadic</qualifiedname>
        <param>
          <type>const auto &amp;</type>
          <declname>A_ij</declname>
        </param>
        <param>
          <type>const auto &amp;</type>
          <declname>B_kl</declname>
        </param>
        <briefdescription>
<para>Computes the dyadic product of two <ref refid="a00427" kindref="compound">Eigen</ref> tensors. </para>
        </briefdescription>
        <detaileddescription>
<para>The components of the result read <formula id="79">\[ \CI_{ijkl} = A_{ij}B_{kl}. \]</formula></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A_ij</parametername>
</parameternamelist>
<parameterdescription>
<para>First tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_kl</parametername>
</parameternamelist>
<parameterdescription>
<para>Second tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting tensor after the dyadic product. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="47" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="47" bodyend="50"/>
        <referencedby refid="a01486_1a0a02eda2ec4b244354d313e8c98568f6" compoundref="a00284" startline="415" endline="426">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::materialTangent</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga9c5657c8eff4526802c2a67f15135bb8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::dyadic</definition>
        <argsstring>(const Eigen::Vector&lt; ST, size &gt; &amp;a, const Eigen::Vector&lt; ST, size &gt; &amp;b)</argsstring>
        <name>dyadic</name>
        <qualifiedname>Ikarus::dyadic</qualifiedname>
        <param>
          <type>const Eigen::Vector&lt; ST, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::Vector&lt; ST, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Computes the dyadic product of two first order Tensors (here: Eigen::Vector). </para>
        </briefdescription>
        <detaileddescription>
<para>The components of the result read <formula id="80">\[ A_{ij} = a_{i}b_{j}. \]</formula></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a_i</parametername>
</parameternamelist>
<parameterdescription>
<para>First tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_j</parametername>
</parameternamelist>
<parameterdescription>
<para>Second tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting tensor after the dyadic product </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="61" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="61" bodyend="63"/>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga1c9618ef351cd986d4f64fde7f52e860" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
            <defval>double</defval>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
            <defval>3</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::symmetricIdentityFourthOrder</definition>
        <argsstring>()</argsstring>
        <name>symmetricIdentityFourthOrder</name>
        <qualifiedname>Ikarus::symmetricIdentityFourthOrder</qualifiedname>
        <briefdescription>
<para>Generates a symmetric identity fourth-order tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension of the tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Symmetric identity fourth-order tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="73" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="73" bodyend="81"/>
        <referencedby refid="a01634_1aacf24b92643f54607e96cf323723f061" compoundref="a00236" startline="148" endline="163">Ikarus::Materials::StVenantKirchhoffT&lt; ST &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga2368a572348c410fd7e7deb6c6e3964a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
            <defval>double</defval>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
            <defval>3</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::symmetricFourthOrder</definition>
        <argsstring>(const auto &amp;A, const auto &amp;B)</argsstring>
        <name>symmetricFourthOrder</name>
        <qualifiedname>Ikarus::symmetricFourthOrder</qualifiedname>
        <param>
          <type>const auto &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const auto &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Generates a symmetric fourth-order tensor based on two second-order input tensors. </para>
        </briefdescription>
        <detaileddescription>
<para>The components of the result read <formula id="81">\[ \CI_{ijkl} = \frac{1}{2} \left(A_{ik}B_{jl}+A_{il}B_{jk} \right) .
\]</formula> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the tensors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension of the tensors. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>First tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Second tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Symmetric fourth-order tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="95" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="95" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="a00407_1gadb08b6f9cc40847b70286dc314a23000" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
            <defval>double</defval>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
            <defval>3</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::identityFourthOrder</definition>
        <argsstring>()</argsstring>
        <name>identityFourthOrder</name>
        <qualifiedname>Ikarus::identityFourthOrder</qualifiedname>
        <briefdescription>
<para>Generates an identity fourth-order tensor. </para>
        </briefdescription>
        <detaileddescription>
<para>The components of the result read <formula id="82">\[ \CI_{ijkl} = \de_{ij}\de_{kl}. \]</formula> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension of the tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Identity fourth-order tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="114" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="114" bodyend="121"/>
        <referencedby refid="a01634_1aacf24b92643f54607e96cf323723f061" compoundref="a00236" startline="148" endline="163">Ikarus::Materials::StVenantKirchhoffT&lt; ST &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga8fa2b440586483c1ee0f9b90b9081da2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename AType</type>
          </param>
          <param>
            <type>typename BType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::fourthOrderIKJL</definition>
        <argsstring>(const Eigen::MatrixBase&lt; AType &gt; &amp;A, const Eigen::MatrixBase&lt; BType &gt; &amp;B)</argsstring>
        <name>fourthOrderIKJL</name>
        <qualifiedname>Ikarus::fourthOrderIKJL</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; AType &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; BType &gt; &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Computes the IKJL product of two matrices. </para>
        </briefdescription>
        <detaileddescription>
<para>The components of the result read <formula id="83">\[ \CI_{ijkl} = A_{ik}B_{jl}, \]</formula> which simply swaps the inner slots <computeroutput>j</computeroutput>and <computeroutput>k</computeroutput> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>AType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the first matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the second matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>First matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Second matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting tensor of the IKJL product. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="135" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="135" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="a00407_1gaea03dbfcd8f85ef7af004c7e09244aa9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
          </param>
          <param>
            <type>long int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::symTwoSlots</definition>
        <argsstring>(const Eigen::TensorFixedSize&lt; ScalarType, Eigen::Sizes&lt; dim, dim, dim, dim &gt; &gt; &amp;t, const std::array&lt; size_t, 2 &gt; &amp;slots)</argsstring>
        <name>symTwoSlots</name>
        <qualifiedname>Ikarus::symTwoSlots</qualifiedname>
        <param>
          <type>const Eigen::TensorFixedSize&lt; ScalarType, Eigen::Sizes&lt; dim, dim, dim, dim &gt; &gt; &amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const std::array&lt; size_t, 2 &gt; &amp;</type>
          <declname>slots</declname>
        </param>
        <briefdescription>
<para>Creates a symmetric fourth-order tensor in the two specified slots of the input tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>slots</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices of the slots to be swapped. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Fourth-order Tensor which is symmetric in the given slots. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="158" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="158" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga4304655095296ce9283e012587817a51" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>constexpr Eigen::Index</type>
        <definition>constexpr Eigen::Index Ikarus::toVoigt</definition>
        <argsstring>(Eigen::Index i, Eigen::Index j) noexcept</argsstring>
        <name>toVoigt</name>
        <qualifiedname>Ikarus::toVoigt</qualifiedname>
        <param>
          <type>Eigen::Index</type>
          <declname>i</declname>
        </param>
        <param>
          <type>Eigen::Index</type>
          <declname>j</declname>
        </param>
        <briefdescription>
<para>Converts 2D indices to Voigt notation index. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>Row index. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>j</parametername>
</parameternamelist>
<parameterdescription>
<para>Column index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Index Voigt notation index.</para>
</simplesect>
This function converts 2D indices (i, j) to a Voigt notation index. The Voigt notation is used to represent the six unique components of a symmetric 3x3 matrix in a one-dimensional array.</para>
<para>If the input indices are not within the valid range (0, 1, 2), an assertion failure is triggered. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="179" column="24" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="179" bodyend="190"/>
        <referencedby refid="a00406_1ga1fbedbac54712740abe25ceab2990472" compoundref="a00371" startline="10" endline="57">addBindingsToUtils</referencedby>
        <referencedby refid="a01650_1a7c8edbff09762bdb9cae26d4cf6b0a91" compoundref="a00290" startline="209" endline="227">Ikarus::NonLinearElastic&lt; PreFE, FE, PRE &gt;::calculateAtImpl</referencedby>
        <referencedby refid="a01486_1a2116db254c03a1873dc6d1d432d8eaa1" compoundref="a00284" startline="201" endline="235">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::computeMaterialAndStrains</referencedby>
        <referencedby refid="a01486_1a0a02eda2ec4b244354d313e8c98568f6" compoundref="a00284" startline="415" endline="426">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::materialTangent</referencedby>
        <referencedby refid="a01622_1a8d6370e3d198662f4222a0b94e2d6703" compoundref="a03068" startline="136" endline="147">Ikarus::Materials::Material&lt; MI &gt;::storedEnergy</referencedby>
        <referencedby refid="a01362_1aa58ea268a050d8f2735e5098a0d519df" compoundref="a00140" startline="99" endline="120">Ikarus::Experimental::AutoDiffMAT&lt; RealMAT, forceAutoDiffV, forceAutoDiffS &gt;::stresses</referencedby>
        <referencedby refid="a01622_1a8a68e052cade23285d1a28d1e08845f5" compoundref="a03068" startline="160" endline="168">Ikarus::Materials::Material&lt; MI &gt;::stresses</referencedby>
        <referencedby refid="a01362_1abd22c052743105a646c9cb16d531c57a" compoundref="a00140" startline="130" endline="170">Ikarus::Experimental::AutoDiffMAT&lt; RealMAT, forceAutoDiffV, forceAutoDiffS &gt;::tangentModuli</referencedby>
        <referencedby refid="a01622_1a7a97d64507fd1ce0c14e919edb8a639b" compoundref="a03068" startline="181" endline="189">Ikarus::Materials::Material&lt; MI &gt;::tangentModuli</referencedby>
        <referencedby refid="a00407_1ga8777400d7d11c49d46f3c6be2698722e" compoundref="a00032" startline="207" endline="215">toVoigt</referencedby>
        <referencedby refid="a00406_1ga378c5569b7b899586e7c8006fb776351" compoundref="a00017" startline="565" endline="578">toVoigtAndMaybeReduce</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga8777400d7d11c49d46f3c6be2698722e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
            <defval>double</defval>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; ScalarType, 6, 6 &gt;</type>
        <definition>Eigen::Matrix&lt; ScalarType, 6, 6 &gt; Ikarus::toVoigt</definition>
        <argsstring>(const Eigen::TensorFixedSize&lt; ScalarType, Eigen::Sizes&lt; 3, 3, 3, 3 &gt; &gt; &amp;ft)</argsstring>
        <name>toVoigt</name>
        <qualifiedname>Ikarus::toVoigt</qualifiedname>
        <param>
          <type>const Eigen::TensorFixedSize&lt; ScalarType, Eigen::Sizes&lt; 3, 3, 3, 3 &gt; &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <briefdescription>
<para>Converts a fourth-order tensor of fixed size 3x3x3x3 to a Voigt notation matrix of size 6x6. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type of the tensor elements. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>Fourth-order tensor . </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Voigt notation matrix.</para>
</simplesect>
This function converts a fourth-order tensor to a Voigt notation matrix, which is a symmetric 6x6 matrix containing the unique components of the input tensor. The mapping from the tensor indices to the Voigt notation indices is performed by the toVoigt function.</para>
<para><simplesect kind="remark"><para>The current implementation does not take advantage of this symmetry. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="207" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="207" bodyend="215"/>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga130c456477155bd833fc6fd5b0223fd3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
          <param>
            <type>int</type>
            <declname>Options</declname>
            <defname>Options</defname>
          </param>
          <param>
            <type>int</type>
            <declname>maxSize</declname>
            <defname>maxSize</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::toVoigt</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, size, size, Options, maxSize, maxSize &gt; &amp;E, bool isStrain=true)</argsstring>
        <name>toVoigt</name>
        <qualifiedname>Ikarus::toVoigt</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, size, size, Options, maxSize, maxSize &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isStrain</declname>
          <defval>true</defval>
        </param>
    <requiresclause>((size &gt; 0 and size &lt;= 3) or (maxSize &gt; 0 and maxSize &lt;= 3 and size == Eigen::Dynamic))    </requiresclause>
        <briefdescription>
<para>Converts a square 2x2 or 3x3 matrix to a Voigt notation vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type of the matrix elements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows and columns of the square matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Options</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="a00427" kindref="compound">Eigen</ref> matrix options. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix of size (size x size). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isStrain</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether the conversion is for strain (true) or not (false). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Vector with components in Voigt notation vector.</para>
</simplesect>
This function converts a square matrix to a Voigt notation vector, which contains the unique components of the input matrix. The mapping from the matrix indices to the Voigt notation indices is performed by the toVoigt function.</para>
<para>The optional isStrain parameter allows the user to specify whether the conversion is intended for strain calculations. If isStrain is true, the off-diagonal components are multiplied by 2, providing the correct Voigt notation for symmetric strain tensors. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="238" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="238" bodyend="264"/>
      </memberdef>
      <memberdef kind="function" id="a00407_1gadc8e9e9f3838d0392a5fcf1e11374ee9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
          <param>
            <type>int</type>
            <declname>Options</declname>
            <defname>Options</defname>
          </param>
          <param>
            <type>int</type>
            <declname>maxSize</declname>
            <defname>maxSize</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::fromVoigt</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, size, 1, Options, maxSize, 1 &gt; &amp;EVoigt, bool isStrain=true)</argsstring>
        <name>fromVoigt</name>
        <qualifiedname>Ikarus::fromVoigt</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, size, 1, Options, maxSize, 1 &gt; &amp;</type>
          <declname>EVoigt</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isStrain</declname>
          <defval>true</defval>
        </param>
    <requiresclause>((size == 1 or size == 3 or size == 6) or ((maxSize == 1 or maxSize == 3 or maxSize == 6) and size == Eigen::Dynamic))    </requiresclause>
        <briefdescription>
<para>Converts a vector given in Voigt notation to a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type of the vector elements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the Voigt notation vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>EVoigt</parametername>
</parameternamelist>
<parameterdescription>
<para>Voigt notation vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isStrain</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether the vector represents a strain (default is true). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Matrix corresponding to the vector in Voigt notation.</para>
</simplesect>
This function converts a vector given in Voigt notation to the corresponding matrix. The conversion depends on the size The parameter <computeroutput>isStrain</computeroutput> is used to determine the conversion factor for off-diagonal components, which need to be divided by 2 in the matrix representation if the quantity is a strain tensor.</para>
<para>The function requires that the size of the Voigt notation vector is valid (1, 3, or 6). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="284" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="284" bodyend="314"/>
        <referencedby refid="a00406_1ga1fbedbac54712740abe25ceab2990472" compoundref="a00371" startline="10" endline="57">addBindingsToUtils</referencedby>
        <referencedby refid="a00407_1ga0afe53095f875017b5673a42e13e6f5a" compoundref="a00032" startline="356" endline="367">fromVoigt</referencedby>
        <referencedby refid="a01726_1aafc25c13807fda614d68992dcd4923ae" compoundref="a00353" startline="111" endline="116">Ikarus::ResultEvaluators::PrincipalStress&lt; dim &gt;::operator()</referencedby>
        <referencedby refid="a01718_1a4a16334a6d486018a77727fb2acca63c" compoundref="a00353" startline="38" endline="44">Ikarus::ResultEvaluators::VonMises::operator()</referencedby>
        <referencedby refid="a01722_1a35c0916886cd68004bedbebe4165fa97" compoundref="a00353" startline="75" endline="79">Ikarus::ResultEvaluators::HydrostaticStress::operator()</referencedby>
        <referencedby refid="a01734_1a22590930fe4d5d2d5e5a323cd3085cdb" compoundref="a00353" startline="184" endline="208">Ikarus::ResultEvaluators::PolarStress::operator()</referencedby>
        <referencedby refid="a01638_1aa29dd3baf16c20438b69d5f3e6590b57" compoundref="a00242" startline="93" endline="103">Ikarus::Materials::VanishingStrain&lt; strainIndexPair, MI &gt;::stressesImpl</referencedby>
        <referencedby refid="a01642_1a78bed662e2230b7aabafd97556400071" compoundref="a00239" startline="99" endline="107">Ikarus::Materials::VanishingStress&lt; stressIndexPair, MI &gt;::stressesImpl</referencedby>
        <referencedby refid="a01638_1aa7bd7e40c6b4995a6e33dfba4ab88de0" compoundref="a00242" startline="113" endline="120">Ikarus::Materials::VanishingStrain&lt; strainIndexPair, MI &gt;::tangentModuliImpl</referencedby>
        <referencedby refid="a01642_1a0ebefbbf6effdedcf7ce4238d5079394" compoundref="a00239" startline="117" endline="124">Ikarus::Materials::VanishingStress&lt; stressIndexPair, MI &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga518e0394f7c90dbe798b6cb8d757b822" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::array&lt; size_t, 2 &gt;</type>
        <definition>constexpr std::array&lt; size_t, 2 &gt; Ikarus::fromVoigt</definition>
        <argsstring>(size_t i)</argsstring>
        <name>fromVoigt</name>
        <qualifiedname>Ikarus::fromVoigt</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>Converts a Voigt notation index to matrix indices. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>Voigt notation index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Matrix indices corresponding to the Voigt notation index.</para>
</simplesect>
This function converts a Voigt notation index to the corresponding matrix indices. The mapping is based on the assumption that the Voigt notation indices 0, 1, and 2 represent the diagonal components <computeroutput>00</computeroutput>, <computeroutput>11</computeroutput>, and <computeroutput>22</computeroutput>, respectively. The remaining Voigt notation indices (3, 4, and 5) correspond to the off-diagonal components (<computeroutput>12</computeroutput> and <computeroutput>21</computeroutput>, <computeroutput>02</computeroutput> and <computeroutput>20</computeroutput>, <computeroutput>01</computeroutput> and <computeroutput>10</computeroutput>).</para>
<para>The function asserts that the input index is within the valid range for Voigt notation (0 to 5). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="329" column="22" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="329" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="a00407_1ga0afe53095f875017b5673a42e13e6f5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::fromVoigt</definition>
        <argsstring>(const Eigen::Matrix&lt; ScalarType, 6, 6 &gt; &amp;CVoigt)</argsstring>
        <name>fromVoigt</name>
        <qualifiedname>Ikarus::fromVoigt</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ScalarType, 6, 6 &gt; &amp;</type>
          <declname>CVoigt</declname>
        </param>
        <briefdescription>
<para>Converts a matrix in Voigt notation to a Fourth-order tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type of the matrix elements. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>CVoigt</parametername>
</parameternamelist>
<parameterdescription>
<para>Voigt notation matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Fourth-order tensor corresponding to the matrix in Voigt notation.</para>
</simplesect>
This function converts a Voigt notation matrix to the corresponding 4th-order tensor. The function uses the <computeroutput>fromVoigt</computeroutput> function to map matrix indices to tensor indices. The resulting tensor is symmetric due to symmetry considerations. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="356" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="356" bodyend="367"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a7a5b9f5e83f6918ca1726fb4316c3b86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d Ikarus::calcTransformationMatrix2D</definition>
        <argsstring>(const Geometry &amp;geometry)</argsstring>
        <name>calcTransformationMatrix2D</name>
        <qualifiedname>Ikarus::calcTransformationMatrix2D</qualifiedname>
        <param>
          <type>const Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the 2D transformation matrix. </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes the transformation matrix needed to transform second-order tensors represented in Voigt notation from local to global coordinate system for 2D elements.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The geometry type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to the geometry object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The transformation matrix for 2D elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="380" column="17" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="380" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="a00411_1a95234ab8588ced83708c6e5a30e2368e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; double, 6, 6 &gt;</type>
        <definition>Eigen::Matrix&lt; double, 6, 6 &gt; Ikarus::calcTransformationMatrix3D</definition>
        <argsstring>(const Geometry &amp;geometry)</argsstring>
        <name>calcTransformationMatrix3D</name>
        <qualifiedname>Ikarus::calcTransformationMatrix3D</qualifiedname>
        <param>
          <type>const Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the 3D transformation matrix. </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes the transformation matrix needed to transform second-order tensors represented in Voigt notation from local to global coordinate system for 3D elements.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The geometry type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to the geometry object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The transformation matrix for 3D elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" line="413" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/tensorutils.hh" bodystart="413" bodyend="443"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/__w/ikarus/ikarus/repo/ikarus/assembler/assemblermanipulatorbuildingblocks.hh" line="22" column="1"/>
  </compounddef>
</doxygen>
