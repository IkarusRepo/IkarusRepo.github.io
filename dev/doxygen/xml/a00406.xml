<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.4" xml:lang="en-US">
  <compounddef id="a00406" kind="group">
    <compoundname>utils</compoundname>
    <title>Utilities</title>
    <innerclass refid="a01870" prot="public">Ikarus::BasisHandler</innerclass>
    <innerclass refid="a01926" prot="public">Ikarus::DirichletValues</innerclass>
    <innerclass refid="a01934" prot="public">Ikarus::FlatPreBasis</innerclass>
    <innerclass refid="a01974" prot="public">Ikarus::NonLinearOperator</innerclass>
    <innerclass refid="a01902" prot="public">Ikarus::utils::SolverDefault</innerclass>
    <innerclass refid="a01906" prot="public">Ikarus::utils::UpdateDefault</innerclass>
      <sectiondef kind="var">
      <memberdef kind="variable" id="a00406_1ga8bdeefaffd49685e7dcd89f34af51d76" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto Ikarus::voigtNotationContainer</definition>
        <argsstring></argsstring>
        <name>voigtNotationContainer</name>
        <qualifiedname>Ikarus::voigtNotationContainer</qualifiedname>
        <initializer>= std::get&lt;dim - 1&gt;(Impl::voigtIndices)</initializer>
        <briefdescription>
<para>Container for Voigt notation indices based on dimension.</para>
<para>1D: 0,0 2D: 0,0; 1,1; 0,1 3D: 0,0; 1,1; 2,2; 1,2; 0,2; 0,1. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>The dimension for which Voigt indices are needed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="483" column="16" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="483" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="a00406_1ga2a6c26beeb8d52283e82939ca585dc20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Fun</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Vars</declname>
            <defname>Vars</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>typename U</type>
          </param>
          <param>
            <type>typename G</type>
          </param>
          <param>
            <type>typename H</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Ikarus::utils::hessianN</definition>
        <argsstring>(const Fun &amp;f, const autodiff::Wrt&lt; Vars... &gt; &amp;wrt, const autodiff::At&lt; Args... &gt; &amp;at, U &amp;u, std::array&lt; G, U::RowsAtCompileTime &gt; &amp;g, std::array&lt; H, U::RowsAtCompileTime &gt; &amp;h)</argsstring>
        <name>hessianN</name>
        <qualifiedname>Ikarus::utils::hessianN</qualifiedname>
        <param>
          <type>const Fun &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>const autodiff::Wrt&lt; Vars... &gt; &amp;</type>
          <declname>wrt</declname>
        </param>
        <param>
          <type>const autodiff::At&lt; Args... &gt; &amp;</type>
          <declname>at</declname>
        </param>
        <param>
          <type>U &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>std::array&lt; G, U::RowsAtCompileTime &gt; &amp;</type>
          <declname>g</declname>
        </param>
        <param>
          <type>std::array&lt; H, U::RowsAtCompileTime &gt; &amp;</type>
          <declname>h</declname>
        </param>
        <briefdescription>
<para>Computes the Hessian matrix for each parameter of a given function.</para>
<para>The Hessian matrix represents the second-order partial derivatives of the function with respect to the specified variables. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Fun</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function to be differentiated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Vars</parametername>
</parameternamelist>
<parameterdescription>
<para>The types of the variables with respect to which the Hessian is computed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>The types of the arguments passed to the function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>The type representing the result of the function evaluation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>G</parametername>
</parameternamelist>
<parameterdescription>
<para>The type representing the gradient of the function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>H</parametername>
</parameternamelist>
<parameterdescription>
<para>The type representing the Hessian matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be differentiated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wrt</parametername>
</parameternamelist>
<parameterdescription>
<para>The variables with respect to which the Hessian is computed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>at</parametername>
</parameternamelist>
<parameterdescription>
<para>The values at which the Hessian is evaluated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>u</parametername>
</parameternamelist>
<parameterdescription>
<para>The result of the function evaluation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of the function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>h</parametername>
</parameternamelist>
<parameterdescription>
<para>The Hessian matrix (output). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/autodiffhelper.hh" line="35" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/autodiffhelper.hh" bodystart="35" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga16e7d5f51cc42190c090e727495c1609" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, decltype(Eigen::seq(0, 0))&gt;</type>
        <definition>std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, decltype(Eigen::seq(0, 0))&gt; Ikarus::utils::findLineSegment</definition>
        <argsstring>(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;y, int segmentSize)</argsstring>
        <name>findLineSegment</name>
        <qualifiedname>Ikarus::utils::findLineSegment</qualifiedname>
        <param>
          <type>const Eigen::VectorXd &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const Eigen::VectorXd &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>segmentSize</declname>
        </param>
        <briefdescription>
<para>Find a linear segment in a set of data points. </para>
        </briefdescription>
        <detaileddescription>
<para>his function is inspired by the MATLAB code at: <ulink url="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/identify_linear_piece.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/identify_linear_piece.m</ulink> It is designed to find the most linear segment in a set of data points</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The x-coordinates of the data points. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>The y-coordinates of the data points. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>segmentSize</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the line segment to be identified. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple containing the polynomial representing the identified line segment and the indices of the data points in the segment. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/findlinesegment.hh" line="28" column="12" declfile="/__w/ikarus/ikarus/repo/ikarus/utils/findlinesegment.hh" declline="28" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga0728039472747184e9eb2ec0992a4a2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PreBasis</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::flatPreBasis</definition>
        <argsstring>(const PreBasis &amp;preBasis)</argsstring>
        <name>flatPreBasis</name>
        <qualifiedname>Ikarus::flatPreBasis</qualifiedname>
        <param>
          <type>const PreBasis &amp;</type>
          <declname>preBasis</declname>
        </param>
        <briefdescription>
<para>Generator function for a flatted PreBasis. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" line="110" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/flatprebasis.hh" bodystart="110" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gae9098182120929a0d21cff1c38f5ca84" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
          <param>
            <type>typename LV</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Ikarus::utils::obtainLagrangeGlobalNodePositions</definition>
        <argsstring>(const LV &amp;localView, std::vector&lt; Dune::FieldVector&lt; double, size &gt; &gt; &amp;lagrangeNodeGlobalCoords)</argsstring>
        <name>obtainLagrangeGlobalNodePositions</name>
        <qualifiedname>Ikarus::utils::obtainLagrangeGlobalNodePositions</qualifiedname>
        <param>
          <type>const LV &amp;</type>
          <declname>localView</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="a01910" kindref="compound">Dune::FieldVector</ref>&lt; double, size &gt; &gt; &amp;</type>
          <declname>lagrangeNodeGlobalCoords</declname>
        </param>
        <briefdescription>
<para>A function to obtain the global positions of the nodes of an element with Lagrangian basis. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the global nodal coordinate vector </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>LV</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the local view</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>localView</parametername>
</parameternamelist>
<parameterdescription>
<para>Local view bounded to an element </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lagrangeNodeGlobalCoords</parametername>
</parameternamelist>
<parameterdescription>
<para>A vector of global nodal coordinates to be updated </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" line="30" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" bodystart="30" bodyend="37"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaa19ed04a701aaa500f7c486addae2d2e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
          <param>
            <type>typename Basis</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::globalIndexFromGlobalPosition</definition>
        <argsstring>(const Basis &amp;basis, const Dune::FieldVector&lt; double, size &gt; &amp;pos)</argsstring>
        <name>globalIndexFromGlobalPosition</name>
        <qualifiedname>Ikarus::utils::globalIndexFromGlobalPosition</qualifiedname>
        <param>
          <type>const Basis &amp;</type>
          <declname>basis</declname>
        </param>
        <param>
          <type>const <ref refid="a01910" kindref="compound">Dune::FieldVector</ref>&lt; double, size &gt; &amp;</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>A helper function to obtain the global index from the global positions for a Lagrange node. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the global nodal coordinate vector </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Basis</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the basis.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>basis</parametername>
</parameternamelist>
<parameterdescription>
<para>The grid basis. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Global position </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Global index </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" line="50" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" bodystart="50" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga30df35336d19b00bc5db2a0b52ce650e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FE</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::referenceElementSubEntityPositions</definition>
        <argsstring>(FE &amp;fe, int codim)</argsstring>
        <name>referenceElementSubEntityPositions</name>
        <qualifiedname>Ikarus::utils::referenceElementSubEntityPositions</qualifiedname>
        <param>
          <type>FE &amp;</type>
          <declname>fe</declname>
        </param>
        <param>
          <type>int</type>
          <declname>codim</declname>
        </param>
        <briefdescription>
<para>A function to obtain the local coordinates of subentities of an FiniteElement. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername><ref refid="a01370" kindref="compound">FE</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the finite element </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fe</parametername>
</parameternamelist>
<parameterdescription>
<para>finite element </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>codim</parametername>
</parameternamelist>
<parameterdescription>
<para>codim of requested subentity </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>view over the position of the subenties </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" line="88" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" bodystart="88" bodyend="96"/>
        <referencedby refid="a00406_1ga8c05dce8a66fc4efbe31674b87d18298" compoundref="a00023" startline="106" endline="108">Ikarus::utils::referenceElementVertexPositions</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga8c05dce8a66fc4efbe31674b87d18298" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FE</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::referenceElementVertexPositions</definition>
        <argsstring>(FE &amp;fe)</argsstring>
        <name>referenceElementVertexPositions</name>
        <qualifiedname>Ikarus::utils::referenceElementVertexPositions</qualifiedname>
        <param>
          <type>FE &amp;</type>
          <declname>fe</declname>
        </param>
        <briefdescription>
<para>A function to obtain the local coordinates the vertices of an FiniteElement. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername><ref refid="a01370" kindref="compound">FE</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the finite element </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fe</parametername>
</parameternamelist>
<parameterdescription>
<para>finite element </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" line="106" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionhelper.hh" bodystart="106" bodyend="108"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gacb9e813539bfd84df99ad097cabc9de9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NonlinearOperator</type>
          </param>
          <param>
            <type>typename UpdateType</type>
            <defval>typename NonlinearOperator::template ParameterValue&lt;0&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::checkGradient</definition>
        <argsstring>(NonlinearOperator &amp;nonLinOp, CheckFlags checkFlags=CheckFlags(), std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt; p_updateFunction=[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;})</argsstring>
        <name>checkGradient</name>
        <qualifiedname>Ikarus::utils::checkGradient</qualifiedname>
        <param>
          <type>NonlinearOperator &amp;</type>
          <declname>nonLinOp</declname>
        </param>
        <param>
          <type>CheckFlags</type>
          <declname>checkFlags</declname>
          <defval>CheckFlags()</defval>
        </param>
        <param>
          <type>std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt;</type>
          <declname>p_updateFunction</declname>
          <defval>[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;}</defval>
        </param>
        <briefdescription>
<para>Checks the gradient of a nonlinear operator. </para>
        </briefdescription>
        <detaileddescription>
<para>The checkgradient function is inspired by <ulink url="http://sma.epfl.ch/~nboumal/book/">http://sma.epfl.ch/~nboumal/book/</ulink> Chapter 4.8 and <ulink url="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m</ulink></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NonlinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UpdateType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinOp</parametername>
</parameternamelist>
<parameterdescription>
<para>The nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>checkFlags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags for the check. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p_updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the check passed, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" line="54" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" bodystart="54" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga553465359c199ef676945832587d2869" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NonlinearOperator</type>
          </param>
          <param>
            <type>typename UpdateType</type>
            <defval>typename NonlinearOperator::template ParameterValue&lt;0&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::checkJacobian</definition>
        <argsstring>(NonlinearOperator &amp;nonLinOp, CheckFlags checkFlags=CheckFlags(), std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt; p_updateFunction=[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;})</argsstring>
        <name>checkJacobian</name>
        <qualifiedname>Ikarus::utils::checkJacobian</qualifiedname>
        <param>
          <type>NonlinearOperator &amp;</type>
          <declname>nonLinOp</declname>
        </param>
        <param>
          <type>CheckFlags</type>
          <declname>checkFlags</declname>
          <defval>CheckFlags()</defval>
        </param>
        <param>
          <type>std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt;</type>
          <declname>p_updateFunction</declname>
          <defval>[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;}</defval>
        </param>
        <briefdescription>
<para>Checks the Jacobian of a nonlinear operator. </para>
        </briefdescription>
        <detaileddescription>
<para>The checkjacobian function is inspired by <ulink url="http://sma.epfl.ch/~nboumal/book/">http://sma.epfl.ch/~nboumal/book/</ulink> Chapter 4.8 and <ulink url="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkdiff.m</ulink></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NonlinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UpdateType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinOp</parametername>
</parameternamelist>
<parameterdescription>
<para>The nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>checkFlags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags for the check. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p_updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the check passed, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" line="115" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" bodystart="115" bodyend="153"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga5d1a87964a3d6b6ddc994532e93b6798" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename NonlinearOperator</type>
          </param>
          <param>
            <type>typename UpdateType</type>
            <defval>typename NonlinearOperator::template ParameterValue&lt;0&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::checkHessian</definition>
        <argsstring>(NonlinearOperator &amp;nonLinOp, CheckFlags checkFlags=CheckFlags(), std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt; p_updateFunction=[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;})</argsstring>
        <name>checkHessian</name>
        <qualifiedname>Ikarus::utils::checkHessian</qualifiedname>
        <param>
          <type>NonlinearOperator &amp;</type>
          <declname>nonLinOp</declname>
        </param>
        <param>
          <type>CheckFlags</type>
          <declname>checkFlags</declname>
          <defval>CheckFlags()</defval>
        </param>
        <param>
          <type>std::function&lt; void(typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;, const UpdateType &amp;)&gt;</type>
          <declname>p_updateFunction</declname>
          <defval>[](typename NonlinearOperator::template ParameterValue&lt; 0 &gt; &amp;a, const UpdateType &amp;b) { a+=b;}</defval>
        </param>
        <briefdescription>
<para>Checks the Hessian of a nonlinear operator. </para>
        </briefdescription>
        <detaileddescription>
<para>The checkHessian function is inspired by <ulink url="http://sma.epfl.ch/~nboumal/book/">http://sma.epfl.ch/~nboumal/book/</ulink> Chapter 6.8 and <ulink url="https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkhessian.m">https://github.com/NicolasBoumal/manopt/blob/master/manopt/tools/checkhessian.m</ulink></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NonlinearOperator</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UpdateType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the update. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nonLinOp</parametername>
</parameternamelist>
<parameterdescription>
<para>The nonlinear operator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>checkFlags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags for the check. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p_updateFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>Update function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the check passed, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" line="168" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/functionsanitychecks.hh" bodystart="168" bodyend="216"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaa33adfa2e95d7040a816bb2da81d275d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::orthonormalizeMatrixColumns</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>orthonormalizeMatrixColumns</name>
        <qualifiedname>Ikarus::orthonormalizeMatrixColumns</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Orthonormalizes all Matrix columns using Gram-Schmidt Orthogonalization. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input matrix.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>The input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="a00427" kindref="compound">Eigen</ref> Matrix with orthonormalized columns. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="35" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="35" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga545d74839895f4576a3b8c97d72abefd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsFlatEigenVector</definition>
        <argsstring>(Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsFlatEigenVector</name>
        <qualifiedname>Ikarus::viewAsFlatEigenVector</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View Dune::BlockVector as an Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a flat Eigen::Vector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="57" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="57" bodyend="62"/>
        <referencedby refid="a01478_1afddcb054816acf30dd2f0543a67dc96c" compoundref="a00221" startline="103" endline="130">Ikarus::EnhancedAssumedStrains&lt; PreFE, FE &gt;::calculateAtImpl</referencedby>
        <referencedby refid="a01478_1a9febb77b55a78ae825f8627d2ad1e8c7" compoundref="a00221" startline="197" endline="234">Ikarus::EnhancedAssumedStrains&lt; PreFE, FE &gt;::calculateVectorImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga3beeb26c911116fa02df8756214484aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsFlatEigenVector</definition>
        <argsstring>(const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsFlatEigenVector</name>
        <qualifiedname>Ikarus::viewAsFlatEigenVector</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View const Dune::BlockVector as an Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a flat Eigen::Vector (const version). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="72" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="72" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaf9d7cf401f9f03ce1aae728c646ce178" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixAsDynFixed</definition>
        <argsstring>(Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixAsDynFixed</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixAsDynFixed</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View Dune::BlockVector as an Eigen::Matrix with dynamic rows and fixed columns depending on the size of the ValueType. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a dynamic Eigen::Matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="88" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="88" bodyend="93"/>
        <referencedby refid="a01486_1a2116db254c03a1873dc6d1d432d8eaa1" compoundref="a00284" startline="201" endline="235">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::computeMaterialAndStrains</referencedby>
        <referencedby refid="a01658_1aeab583c651a9704392133a98e58e6ad4" compoundref="a00281" startline="117" endline="158">Ikarus::Truss&lt; PreFE, FE &gt;::computeStrain</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaf1c6bdf14e40ee46e881f646e1c28b0d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixAsDynFixed</definition>
        <argsstring>(const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixAsDynFixed</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixAsDynFixed</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>Const view Dune::BlockVector as an Eigen::Matrix with dynamic rows and fixed columns depending on the size of the ValueType. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a dynamic Eigen::Matrix (const version). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="104" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="104" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gac25618d0e7c4aece653662d2541b61ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixFixedDyn</definition>
        <argsstring>(Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixFixedDyn</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixFixedDyn</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>View Dune::BlockVector as an Eigen::Matrix with fixed rows depending on the size of the ValueType and dynamic columns. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a fixed-size Eigen::Matrix with dynamic columns. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="120" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="120" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga146a052f6eb97304a8172c7b65fe70fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::viewAsEigenMatrixFixedDyn</definition>
        <argsstring>(const Dune::BlockVector&lt; ValueType &gt; &amp;blockedVector)</argsstring>
        <name>viewAsEigenMatrixFixedDyn</name>
        <qualifiedname>Ikarus::viewAsEigenMatrixFixedDyn</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; ValueType &gt; &amp;</type>
          <declname>blockedVector</declname>
        </param>
        <briefdescription>
<para>Const view Dune::BlockVector as an Eigen::Matrix with fixed rows depending on the size of the ValueType and dynamic columns. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements in the BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blockedVector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Eigen::Map of the BlockVector as a fixed-size Eigen::Matrix with dynamic columns (const version). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="135" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="135" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga609664964681787f2f736f772b82a01e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t Ikarus::correctionSize</definition>
        <argsstring>(const Dune::BlockVector&lt; Type &gt; &amp;a)</argsstring>
        <name>correctionSize</name>
        <qualifiedname>Ikarus::correctionSize</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
    <requiresclause>requires { Type::correctionSize; }    </requiresclause>
        <briefdescription>
<para>Returns the total correction size of a block vector with a Manifold as the underlying type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Total correction size. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="150" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="150" bodyend="154"/>
        <referencedby refid="a00406_1ga609664964681787f2f736f772b82a01e" compoundref="a00017" startline="150" endline="154">Ikarus::correctionSize</referencedby>
        <referencedby refid="a00406_1ga09cedf6a65b142340c1934c987ed064c" compoundref="a00017" startline="180" endline="188">Ikarus::operator+=</referencedby>
        <referencedby refid="a00406_1ga90c40b4eebec59eeb02294cd7cb0470c" compoundref="a00017" startline="200" endline="205">Ikarus::operator-=</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1gac1df27a0dfa864327029cdb906a1840c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t Ikarus::valueSize</definition>
        <argsstring>(const Dune::BlockVector&lt; Type &gt; &amp;a)</argsstring>
        <name>valueSize</name>
        <qualifiedname>Ikarus::valueSize</qualifiedname>
        <param>
          <type>const Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
    <requiresclause>requires { Type::valueSize; }    </requiresclause>
        <briefdescription>
<para>Returns the total value size of a block vector with a Manifold as the underlying type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Total value size. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="164" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="164" bodyend="168"/>
        <referencedby refid="a00406_1gadab36ca6a3183fb9fedbb02b3ecba736" compoundref="a00017" startline="239" endline="248">Ikarus::addInEmbedding</referencedby>
        <referencedby refid="a00406_1gac1df27a0dfa864327029cdb906a1840c" compoundref="a00017" startline="164" endline="168">Ikarus::valueSize</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga09cedf6a65b142340c1934c987ed064c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
        <definition>Dune::BlockVector&lt; Type &gt; &amp; Ikarus::operator+=</definition>
        <argsstring>(Dune::BlockVector&lt; Type &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator+=</name>
        <qualifiedname>Ikarus::operator+=</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
    <requiresclause>(<ref refid="a02090" kindref="compound">Ikarus::Concepts::AddAssignAble</ref>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })    </requiresclause>
        <briefdescription>
<para>Enables the += operator for Dune::BlockVector += Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::BlockVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="180" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="180" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga90c40b4eebec59eeb02294cd7cb0470c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Type</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
        <definition>Dune::BlockVector&lt; Type &gt; &amp; Ikarus::operator-=</definition>
        <argsstring>(Dune::BlockVector&lt; Type &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator-=</name>
        <qualifiedname>Ikarus::operator-=</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; Type &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
    <requiresclause>(<ref refid="a02090" kindref="compound">Ikarus::Concepts::AddAssignAble</ref>&lt;Type, decltype(b.template segment&lt;Type::correctionSize&gt;(0))&gt; and requires() { Type::correctionSize; })    </requiresclause>
        <briefdescription>
<para>Enables the -= operator for Dune::BlockVector += Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::BlockVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="200" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="200" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaada5360aeb17e59d87ae2ba82057421d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Types</declname>
            <defname>Types</defname>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::TupleVector&lt; Types... &gt; &amp;</type>
        <definition>Dune::TupleVector&lt; Types... &gt; &amp; Ikarus::operator+=</definition>
        <argsstring>(Dune::TupleVector&lt; Types... &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator+=</name>
        <qualifiedname>Ikarus::operator+=</qualifiedname>
        <param>
          <type>Dune::TupleVector&lt; Types... &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Enables the += operator for Dune::TupleVector += Eigen::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Types</parametername>
</parameternamelist>
<parameterdescription>
<para>Types of the elements in the TupleVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::TupleVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::TupleVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="217" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="217" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gadab36ca6a3183fb9fedbb02b3ecba736" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ManifoldPoint</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Dune::BlockVector&lt; ManifoldPoint &gt; &amp;</type>
        <definition>Dune::BlockVector&lt; ManifoldPoint &gt; &amp; Ikarus::addInEmbedding</definition>
        <argsstring>(Dune::BlockVector&lt; ManifoldPoint &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>addInEmbedding</name>
        <qualifiedname>Ikarus::addInEmbedding</qualifiedname>
        <param>
          <type>Dune::BlockVector&lt; ManifoldPoint &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
    <requiresclause>(<ref refid="a02090" kindref="compound">Ikarus::Concepts::AddAssignAble</ref>&lt;ManifoldPoint, decltype(b.template segment&lt;ManifoldPoint::valueSize&gt;(0))&gt; and requires() { ManifoldPoint::valueSize; })    </requiresclause>
        <briefdescription>
<para>Enables the addition in the embedding space of a vector in the space M^n, where M is a manifold with the points of type ManifoldPoint. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ManifoldPoint</parametername>
</parameternamelist>
<parameterdescription>
<para>Manifold type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>ManifoldPoint of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Dune::BlockVector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input Eigen::Matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified Dune::BlockVector. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="239" column="19" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="239" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga0ffc0c74dbd9aeee3e53b199a21b828c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::norm</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;v)</argsstring>
        <name>norm</name>
        <qualifiedname>Ikarus::norm</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>v</declname>
        </param>
    <requiresclause>(!std::floating_point&lt;Derived&gt;)    </requiresclause>
        <briefdescription>
<para>Adding free norm function to <ref refid="a00427" kindref="compound">Eigen</ref> types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Norm of the matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="259" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="259" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gaceb8dc8f6f43516dabf75155b1f22d4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>auto Ikarus::norm</definition>
        <argsstring>(const std::floating_point auto &amp;v)</argsstring>
        <name>norm</name>
        <qualifiedname>Ikarus::norm</qualifiedname>
        <param>
          <type>const std::floating_point auto &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Helper Free Function to have the same interface as for <ref refid="a00427" kindref="compound">Eigen</ref> Vector Types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>Input scalar. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Absolute value of the scalar. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="269" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="269" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gacbc60e06e8e43a9bc14660189eb1baa1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator*</definition>
        <argsstring>(const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</argsstring>
        <name>operator*</name>
        <qualifiedname>Ikarus::operator*</qualifiedname>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Eigen::DiagonalMatrix Product Missing in <ref refid="a00427" kindref="compound">Eigen</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Product of the two DiagonalMatrices. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="281" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="281" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga96968bbff353ac49f48d0aa8b9810b7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+=</definition>
        <argsstring>(Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</argsstring>
        <name>operator+=</name>
        <qualifiedname>Ikarus::operator+=</qualifiedname>
        <param>
          <type>Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>In-place addition for Eigen::DiagonalMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the modified DiagonalMatrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="295" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="295" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga098b554b29619e0cea837f3daa6e0e30" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;a, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Eigen::Matrix + Eigen::DiagonalMatrix addition missing in <ref refid="a00427" kindref="compound">Eigen</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of the <ref refid="a00427" kindref="compound">Eigen</ref> matrix and DiagonalMatrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="311" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="311" bodyend="315"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gafe54695fd1436b5f2d75934a6fda8fe8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a, const Eigen::MatrixBase&lt; Derived &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Eigen::DiagonalMatrix + Eigen::Matrix addition missing in <ref refid="a00427" kindref="compound">Eigen</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of the DiagonalMatrix and <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="328" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="328" bodyend="330"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga9ab6437d6235e378a6171bfffd4bf1cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator-</definition>
        <argsstring>(const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a)</argsstring>
        <name>operator-</name>
        <qualifiedname>Ikarus::operator-</qualifiedname>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Unary minus for Eigen::DiagonalMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Negation of the DiagonalMatrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="341" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="341" bodyend="343"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga0fe1660eb760ecc49838d130ba6c6712" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Derived2</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;a, const Eigen::DiagonalWrapper&lt; Derived2 &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalWrapper&lt; Derived2 &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Addition of Eigen::Matrix and Eigen::DiagonalWrapper. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived2</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of <ref refid="a00427" kindref="compound">Eigen</ref> matrix and DiagonalWrapper. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="355" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="355" bodyend="359"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga9377cd2cf3a5ec468d140cb7063efa58" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Derived2</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::operator+</definition>
        <argsstring>(const Eigen::DiagonalWrapper&lt; Derived &gt; &amp;a, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>Ikarus::operator+</qualifiedname>
        <param>
          <type>const Eigen::DiagonalWrapper&lt; Derived &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived2 &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Addition of Eigen::DiagonalWrapper and Eigen::Matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived2</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> DiagonalWrapper. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of DiagonalWrapper and <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="371" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="371" bodyend="373"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gac2cdcc3047e59b91a4874a1355503cd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Scalar</type>
          </param>
          <param>
            <type>int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; Ikarus::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;a)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>Ikarus::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const Eigen::DiagonalMatrix&lt; Scalar, size &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Output stream operator for Eigen::DiagonalMatrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the diagonal matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>os</parametername>
</parameternamelist>
<parameterdescription>
<para>Output stream. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input DiagonalMatrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to the output stream. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="385" column="1" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="385" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gabd35ea7f69bcc71ee90ea421a1c48167" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Derived</type>
        <definition>Derived Ikarus::sym</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>sym</name>
        <qualifiedname>Ikarus::sym</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the symmetric part of a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Symmetric part of the matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="398" column="9" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="398" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga1496a9776a583f8b09c4244a68453394" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>Derived</type>
        <definition>Derived Ikarus::skew</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>skew</name>
        <qualifiedname>Ikarus::skew</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Returns the skew part of a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Input <ref refid="a00427" kindref="compound">Eigen</ref> matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Skew part of the matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="410" column="9" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="410" bodyend="412"/>
        <referencedby refid="a01486_1a93f11b9294df96b1955867984fe71670" compoundref="a00284" startline="342" endline="385">Ikarus::KirchhoffLoveShell&lt; PreFE, FE &gt;::kgBending</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga40c08050aff1e3e49e58c7823ecbcc77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Ikarus::printForMaple</definition>
        <argsstring>(const Eigen::EigenBase&lt; Derived &gt; &amp;A)</argsstring>
        <name>printForMaple</name>
        <qualifiedname>Ikarus::printForMaple</qualifiedname>
        <param>
          <type>const <ref refid="a01874" kindref="compound">Eigen::EigenBase</ref>&lt; Derived &gt; &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
<para>Method to print the matrix in a format that can directly be copied to Maple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>The derived type of the matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>The input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="421" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="421" bodyend="433"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga821ecf80e4a83241318d825f49cd79e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FieldVectorT</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::createRandomVector</definition>
        <argsstring>(typename FieldVectorT::value_type lower=-1, typename FieldVectorT::value_type upper=1)</argsstring>
        <name>createRandomVector</name>
        <qualifiedname>Ikarus::createRandomVector</qualifiedname>
        <param>
          <type>typename FieldVectorT::value_type</type>
          <declname>lower</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>typename FieldVectorT::value_type</type>
          <declname>upper</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Creates a random vector of the specified type within a given range. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>FieldVectorT</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lower</parametername>
</parameternamelist>
<parameterdescription>
<para>The lower bound of the random values (default is -1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>upper</parametername>
</parameternamelist>
<parameterdescription>
<para>The upper bound of the random values (default is 1). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A random vector within the specified range. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="444" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="444" bodyend="452"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1gabf7cb564e7fa11a403cb8439e2436205" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ScalarType</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; ScalarType, 3, 3 &gt;</type>
        <definition>Eigen::Matrix&lt; ScalarType, 3, 3 &gt; Ikarus::skew</definition>
        <argsstring>(const Eigen::Vector&lt; ScalarType, 3 &gt; &amp;a)</argsstring>
        <name>skew</name>
        <qualifiedname>Ikarus::skew</qualifiedname>
        <param>
          <type>const Eigen::Vector&lt; ScalarType, 3 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Create skew 3x3 matrix from 3d vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ScalarType</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the coordinates in the vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The skew matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="462" column="15" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="462" bodyend="466"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga19d425a4fbc72c2ef7a97d71de9329a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>size_t</type>
            <declname>sizeOfCondensedIndices</declname>
            <defname>sizeOfCondensedIndices</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::staticCondensation</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E, const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;indices)</argsstring>
        <name>staticCondensation</name>
        <qualifiedname>Ikarus::staticCondensation</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const std::array&lt; size_t, sizeOfCondensedIndices &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Performs static condensation on a square matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizeOfCondensedIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the condensed indices. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>indices</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of indices to be condensed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting matrix after static condensation.</para>
</simplesect>
This function performs static condensation on a square matrix. It removes the specified indices from the matrix, computes the remaining submatrices (K11, K12, K22), and returns the result of the static condensation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="498" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="498" bodyend="511"/>
        <referencedby refid="a01642_1a0ebefbbf6effdedcf7ce4238d5079394" compoundref="a00239" startline="117" endline="124">Ikarus::Materials::VanishingStress&lt; stressIndexPair, MI &gt;::tangentModuliImpl</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga2f675229501979101656ec4dee7764d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>size_t</type>
            <declname>sizeOfRemovedCols</declname>
            <defname>sizeOfRemovedCols</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::removeCol</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E, const std::array&lt; size_t, sizeOfRemovedCols &gt; &amp;indices)</argsstring>
        <name>removeCol</name>
        <qualifiedname>Ikarus::removeCol</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const std::array&lt; size_t, sizeOfRemovedCols &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Removes specified columns from a matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizeOfRemovedCols</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the columns to be removed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>indices</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of column indices to be removed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting matrix after removing specified columns.</para>
</simplesect>
This function removes specified columns from a matrix. It computes the remaining columns after removing the specified indices and returns the resulting matrix. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="539" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="539" bodyend="548"/>
        <referencedby refid="a01638_1aa29dd3baf16c20438b69d5f3e6590b57" compoundref="a00242" startline="93" endline="103">Ikarus::Materials::VanishingStrain&lt; strainIndexPair, MI &gt;::stressesImpl</referencedby>
        <referencedby refid="a01642_1a78bed662e2230b7aabafd97556400071" compoundref="a00239" startline="99" endline="107">Ikarus::Materials::VanishingStress&lt; stressIndexPair, MI &gt;::stressesImpl</referencedby>
        <referencedby refid="a00406_1ga378c5569b7b899586e7c8006fb776351" compoundref="a00017" startline="565" endline="578">Ikarus::toVoigtAndMaybeReduce</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga378c5569b7b899586e7c8006fb776351" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ST</type>
          </param>
          <param>
            <type>typename MaterialImpl</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::toVoigtAndMaybeReduce</definition>
        <argsstring>(const Eigen::Matrix&lt; ST, 3, 3 &gt; &amp;E, const MaterialImpl &amp;material, bool isStrain=true)</argsstring>
        <name>toVoigtAndMaybeReduce</name>
        <qualifiedname>Ikarus::toVoigtAndMaybeReduce</qualifiedname>
        <param>
          <type>const Eigen::Matrix&lt; ST, 3, 3 &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <param>
          <type>const MaterialImpl &amp;</type>
          <declname>material</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isStrain</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Converts a 3x3 matrix to Voigt notation, possibly reducing it based on material properties. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ST</parametername>
</parameternamelist>
<parameterdescription>
<para>Scalar type of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MaterialImpl</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the material implementation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input 3x3 matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>material</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to the material implementation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isStrain</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating if the matrix represents strain (default is true). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Resulting matrix in Voigt notation.</para>
</simplesect>
This function converts a 3x3 matrix to its Voigt notation. If the material is not reduced, the full Voigt notation is returned. Otherwise, the specified columns (based on material properties, such as VanishingStress) are removed, and the reduced Voigt notation is returned. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="565" column="6" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="565" bodyend="578"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga30500f2c49b7d1997c7eb7b6ee90ad75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename M</type>
          </param>
          <param>
            <type>typename Derived</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) Ikarus::enlargeIfReduced</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;E)</argsstring>
        <name>enlargeIfReduced</name>
        <qualifiedname>Ikarus::enlargeIfReduced</qualifiedname>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>E</declname>
        </param>
        <briefdescription>
<para>Enlarges a matrix if it reduced in the context of material laws, i.e., VanishingStress If the material is not reduced the untouched matrix is returned and rendering the function as a NoOp. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>M</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the material. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Derived</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto Resulting matrix based on material properties.</para>
</simplesect>
This function takes an input matrix and, based on the material properties, either returns the original matrix (if it is not reduced) or enlarges the matrix by filling in the specified columns with zeros (if it is reduced). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" line="593" column="10" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/linearalgebrahelper.hh" bodystart="593" bodyend="618"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga5db6e8f04892e85e6b17e276cdbd0e54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MessageType</type>
          </param>
        </templateparamlist>
        <type>MessageType &amp;</type>
        <definition>MessageType &amp; Ikarus::increment</definition>
        <argsstring>(MessageType &amp;e)</argsstring>
        <name>increment</name>
        <qualifiedname>Ikarus::increment</qualifiedname>
        <param>
          <type>MessageType &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Increments the given enum value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MessageType</parametername>
</parameternamelist>
<parameterdescription>
<para>The enum type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>The enum value to increment. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The incremented enum value. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>Dune::RangeError</parametername>
</parameternamelist>
<parameterdescription>
<para>if trying to increment MessageType::END. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/makeenum.hh" line="68" column="13" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/makeenum.hh" bodystart="68" bodyend="74"/>
        <referencedby refid="a02006_1ac8058d5b1ebb462a10712ba598154e23" compoundref="a00191" startline="131" endline="134">Ikarus::IObservable&lt; MessageType &gt;::IObservable</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga0d3a38551806e4de3ff44f311847ba51" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, double &gt;</type>
        <definition>std::tuple&lt; Dune::Functions::Polynomial&lt; double &gt;, double &gt; Ikarus::utils::polyfit</definition>
        <argsstring>(const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;y, int deg)</argsstring>
        <name>polyfit</name>
        <qualifiedname>Ikarus::utils::polyfit</qualifiedname>
        <param>
          <type>const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>deg</declname>
        </param>
        <briefdescription>
<para>Fits a polynomial of a given degree to the given data points. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input vector of x-coordinates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>The input vector of y-coordinates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>deg</parametername>
</parameternamelist>
<parameterdescription>
<para>The degree of the polynomial to fit. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;Dune::Functions::Polynomial&lt;double&gt;, double&gt; A tuple containing the fitted polynomial and the least square error. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/polyfit.hh" line="24" column="12" declfile="/__w/ikarus/ikarus/repo/ikarus/utils/polyfit.hh" declline="24" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="a00406_1ga1fbedbac54712740abe25ceab2990472" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void addBindingsToUtils</definition>
        <argsstring>()</argsstring>
        <name>addBindingsToUtils</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>Converts a square 1x1, 2x2 or 3x3 matrix to a Voigt notation vector.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix of size (size x size). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isStrain</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether the conversion is for strain (true) or not (false) (default is true).. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Vector with components in Voigt notation vector.</para>
</simplesect>
This function converts a square matrix to a Voigt notation vector, which contains the unique components of the input matrix.</para>
<para>The optional isStrain parameter allows the user to specify whether the conversion is intended for strain calculations. If isStrain is true, the off-diagonal components are multiplied by 2, providing the correct Voigt notation for symmetric strain tensors.</para>
<para>Converts a vector given in Voigt notation to a matrix.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>EVoigt</parametername>
</parameternamelist>
<parameterdescription>
<para>Voigt notation vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isStrain</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether the vector represents a strain (default is true). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Matrix corresponding to the vector in Voigt notation.</para>
</simplesect>
This function converts a vector given in Voigt notation to the corresponding matrix. The conversion depends on the size The parameter <computeroutput>isStrain</computeroutput> is used to determine the conversion factor for off-diagonal components, which need to be divided by 2 in the matrix representation if the quantity is a strain tensor.</para>
<para>The function requires that the size of the Voigt notation vector is valid (1, 3, or 6).</para>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/python/ikarus/utils/utils.hh" line="10" column="6" bodyfile="/__w/ikarus/ikarus/repo/python/ikarus/utils/utils.hh" bodystart="10" bodyend="57"/>
        <referencedby refid="a00365_1a0e4f7cface71bec1c24bbed3aaa798d8" compoundref="a00365" startline="70" endline="105">PYBIND11_MODULE</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="a00406_1ga14ad7d33267cea1c93f97f3998081657" prot="public" static="no">
        <name>MAKE_ENUM</name>
        <param><defname>type</defname></param>
        <param><defname>...</defname></param>
        <initializer>  enum class type                           \
  {                                         \
    BEGIN,                                  \
    __VA_ARGS__,                            \
    END                                     \
  };                                        \
  constexpr std::string toString(type _e) { \
    using enum type;                        \
    switch (_e) {                           \
      <ref refid="a00011_1a65e77c633f605712a9237282c4e12a75" kindref="member">ENUM_CASE</ref>(BEGIN)                      \
      <ref refid="a00011_1a816aef23498fb528e440575e504589ab" kindref="member">FOR_EACH</ref>(<ref refid="a00011_1a65e77c633f605712a9237282c4e12a75" kindref="member">ENUM_CASE</ref>, __VA_ARGS__)      \
      <ref refid="a00011_1a65e77c633f605712a9237282c4e12a75" kindref="member">ENUM_CASE</ref>(END)                        \
    }                                       \
    __builtin_unreachable();                \
  }</initializer>
        <briefdescription>
<para>Macro to create an enumeration with a string conversion function.</para>
<para>The macro creates an enum class with a BEGIN and END enumerator, and provides a constexpr toString function for string conversion. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the enum class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>Enumerators to be included between BEGIN and END. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/makeenum.hh" line="40" column="9" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/makeenum.hh" bodystart="40" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Collection of several utilities. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
