{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-the-documentation-of-ikarus","title":"Welcome to the documentation of Ikarus","text":"<p>Ikarus is a C++-based library built within the finite element architecture. It originated at the Institute for Structural Mechanics at the University of Stuttgart.</p> <p>This project tries to provide an easy-to-read and an easy-to-use finite element framework. It is heavily inspired by the finite element software DUNE, the book DUNE \u2014 The Distributed and Unified Numerics Environment, deal.II and Kratos. Furthermore, it directly uses several modules from DUNE.</p> <p>The design of CI and the documentation were inspired by Autodiff  and Kratos.</p> <p>The documentation is built using Material for MkDocs.</p> <p>Ikarus provides the tools to create one's own examples and rapidly prototype finite element solution algorithms.  This is done by using template metaprogramming in C++ to write generic code, which is compiled for the example.</p>"},{"location":"download/","title":"Download","text":""},{"location":"download/#installation-of-ikarus","title":"Installation of Ikarus","text":"<p>Change links on this website when final accounts for repository and docker container are fixed and remove this warning.</p> <p>Graphical output is currently not supported on Windows 10 (but will probably be available in the future). Therefore, working on Windows 11 is recommended.</p> <p>The installations on Windows relies on WSL 2, i.e. although working with Windows, the code is compiled and executed in Linux.</p>"},{"location":"download/#installation-on-windows-using-docker-container-and-clion","title":"Installation on Windows using Docker Container and Clion","text":"<ol> <li>Install WSL: Open the PowerShell as an admin and execute the following commands. Reboot afterwards, if requested. <pre><code>wsl --install\nwsl --set-default-version 2 #(Is not needed for Windows 11)\n</code></pre></li> <li>Download and install Docker for Windows.   During the installation, select the option \"Install required Windows components for WSL 2\"</li> <li>Install debian from WindowsAppStore<ol> <li>Open the debian app</li> <li>Give yourself a username and password</li> <li>Close the debian app</li> </ol> </li> <li>Open the PowerShell and execute: <pre><code>wsl --list --all\n</code></pre> <code>Debian</code> should appear as one of the available Linux distributions.</li> <li>In the PowerShell execute: <pre><code>wsl --setdefault Debian\n</code></pre></li> <li>Try to start Docker. If it works, continue with the next step. If a message occurs that you are not allowed to use docker because     you are not in the docker user group, follow these instructions.     In short:<ol> <li>Open computer management as admin</li> <li>Go to Local users and groups and find docker-users</li> <li>Add your Account (or a group of which you are a member) to the group.</li> <li>Restart your computer</li> </ol> </li> <li>In Docker, go to Settings \u2192 General and select autostart for docker     (otherwise you have to start it manually each time you want to work with Ikarus).</li> <li> <p>In the Docker settings, select that Docker uses your WSL2 distribution Debian as shown in the picture.     </p> <p>In cases docker says that you don't have a WSL 2 distribution, go to the PowerShell and execute <pre><code>wsl --set-default-version 2 #(just to be sure that you didn't forgot this at the beginning)\nwsl --set-version Debian 2 #(Converts debian to version 2)\n</code></pre> You should now be able to change the docker settings according to the picture above.</p> </li> <li> <p>Open the PowerShell and execute: <pre><code>docker pull ikarusproject/ikarus-dev:latest #if you want to develop in Ikarus\ndocker pull ikarusproject/ikarus:latest #if you want to use Ikarus to run your own main file as in https://github.com/ikarus-project/ikarus-examples\n</code></pre></p> </li> <li>Download and install CLion. You need a version &gt;=2022.1.</li> <li>In CLion, go to File and Settings and apply the following settings for the toolchain:          Edit the Container settings and paste the following command into <code>Run options</code>: <pre><code>-e DISPLAY=:0 -v \\\\wsl$\\debian\\mnt\\wslg\\.X11-unix:/tmp/.X11-unix -v \\\\wsl$\\debian\\mnt\\wslg:/mnt/wslg --cap-add=SYS_PTRACE\n</code></pre></li> <li>Clone Ikarus</li> </ol>"},{"location":"download/#clone-ikarus","title":"Clone Ikarus","text":"<ul> <li>Clone the Ikarus repository.</li> <li>Open the <code>CMake</code> tab in the CLion footer:   </li> <li>Click on <code>Reload CMake project</code> (refresh symbol):   </li> <li>CMake now detects all required sources automatically. The output should look similar to   the screenshot below:   </li> </ul>"},{"location":"download/#installation-on-linux","title":"Installation on Linux","text":"<ol> <li>If you have docker available, simply pull the container with Ikarus installed to start developing. <pre><code>docker pull ikarusproject/ikarus:latest\n</code></pre></li> <li>Log in to the container via <pre><code>docker container run -it --entrypoint /bin/bash  ikarusproject/ikarus:latest\n</code></pre></li> <li>Instead of point 2, one can now also follow the documentation above if Clion on Linux is preferred.</li> </ol>"},{"location":"gallery/","title":"Gallery","text":""},{"location":"gallery/#gallery","title":"Gallery","text":"<p>In the future, several figures from simulations performed via Ikarus will be found here.</p>"},{"location":"01_framework/","title":"Index","text":""},{"location":"01_framework/#framework","title":"Framework","text":"<pre><code>classDiagram \n  GridView &lt;-- Grid\n  GlobalBasis &lt;-- GridView\n  Assembler &lt;-- GlobalBasis\n  NonlinearOperator &lt;-- Assembler\n  Assembler &lt;-- FiniteElement\n  FiniteElement &lt;-- FERequirements\n  FERequirements &lt;|-- ResultRequirements\n  FiniteElement &lt;-- ResultRequirements\n  FiniteElement &lt;-- Local function\n  Localfunction &lt;-- Localbasis\n  GlobalBasis &lt;--&gt; Localbasis\n  Localfunction &lt;-- Manifold\n  NonlinearSolver &lt;-- NonlinearOperator\n  NonlinearSolver &lt;-- LinearSolver\n  Controlroutine &lt;-- NonlinearSolver\n  VTKWriter &lt;-- Controlroutine\n  DirichletConditions .. Assembler\n  DirichletConditions .. Controlroutine\n  Controlroutine &lt;|-- IObservable\n  NonlinearSolver &lt;|-- IObservable\n  Observer ..&gt; IObservable\n  FERequirements &lt;-- Affordances\n  Affordances &lt;-- ScalarAffordances\n  Affordances &lt;-- VectorAffordances\n  Affordances &lt;-- MatrixAffordances\n  ResultRequirements &lt;-- ResultType\n\n\n  class ScalarAffordances{\n  &lt;&lt;enumeration&gt;&gt;\n      mechanicalPotentialEnergy\n      microMagneticPotentialEnergy\n      ...\n  }\n\n  class VectorAffordances{\n        &lt;&lt;enumeration&gt;&gt;    \n      forces\n      microMagneticForces\n      ...\n  }\n\n  class MatrixAffordances{\n        &lt;&lt;enumeration&gt;&gt;\n      stiffness\n      materialstiffness\n      geometricstiffness\n      mass\n      stiffnessdiffBucklingVector\n      microMagneticHessian\n      ...\n  }\n\n  class ResultType{\n      &lt;&lt;enumeration&gt;&gt;\n      noType\n      magnetization\n      gradientNormOfMagnetization\n      vectorPotential\n      divergenceOfVectorPotential\n      BField\n      HField\n      cauchyStress\n      director\n      ...\n  }\n\n  class Observer{\n    +update()\n  }\n\n  class DirichletConditions{\n  TBA\n  }\n\n  class IObservable{\n    +subscribe()\n    +subscribeAll()\n    +unSubscribe()\n    +unSubscribeAll()\n    +notify()\n  }\n\n  class FERequirements{\n    +hasAffordance()\n    +getGlobalSolution()\n    +getParameter()\n  } \n\n  class ResultRequirements{\n    +isResultRequested()\n    +getParameter()\n  }\n\n  class Assembler{\n    +getScalar()\n    +getVector()\n    +getMatrix()\n    +getReducedMatrix()\n    +getReducedVector()\n    +createFullVector()\n  }\n  class GridView{\n    +elements(gridView)\n    +vertices(gridView)\n    +edges(gridView)\n    +surfaces(gridView)\n  }\n  class Controlroutine{\n    +run()\n  }\n\n  class NonlinearSolver{\n    +setup()\n    +solve()\n    +nonLinearOperator()\n  }\n\n  class GlobalBasis{\n    +localView()\n  }\n\n    class Grid{\n    +leafGridView()\n  }\n\n  class FiniteElement{\n  +calculateScalar()\n  +calculateVector()\n  +calculateMatrix()\n  +calculateAt()\n  }\n\n  class LinearSolver{\n    +analyzePattern()\n    +factorize()\n    +compute()\n    +solve()\n  }\n  class NonlinearOperator{\n    +value()\n    +derivative()\n    +secondDerivative()\n    +nthDerivative&lt;n&gt;()\n    +subOperator()\n}\n\n  class Localfunction{\n    +calculateFunction()\n    +calculateDerivative()\n    +bind()\n    +viewOverIntegrationPoints()\n  }  \n\n  class Localbasis{\n    +calculateFunction()\n    +evaluateJacobian()\n    +bind()\n    +isBound()\n    +viewOverIntegrationPoints()\n  }  \n\n  class Manifold{\n    +setValue()\n    +operator+=()\n    +getValue()\n    +size()\n    +size()\n  }\n\nclick NonlinearOperator href \"../nonlinearOperator/\" \nclick LinearSolver href \"../solvers/#linear-solver\" \nclick NonlinearSolver href \"../solvers/#non-linear-solver\" \nclick FiniteElement href \"../finiteElements/\" \nclick GridView href \"../grid/\" \nclick Grid href \"../grid/\" \nclick Controlroutine href \"../controlRoutines/\" \nclick Assembler href \"../assembler/\" \nclick Localfunction href \"../localFunctions/\" \nclick Manifold href \"../manifolds/\" \nclick Localbasis href \"../localBasis/\" \nclick FERequirements href \"../feRequirements/\" \nclick ResultRequirements href \"../feRequirements/#fe-result-requirements\" \nclick Affordances href \"../feRequirements/\" \nclick ResultType href \"../feRequirements/\" \nclick IObservable href \"../observer/#iobservable\" \nclick Observer href \"../observer/#iobserver\" \nclick GlobalBasis href \"../globalBasis/\" \n</code></pre>"},{"location":"01_framework/assembler/","title":"Assembler","text":""},{"location":"01_framework/assembler/#assembler","title":"Assembler","text":"<p>The purpose of an assembler is to assemble local quantities (local stiffness matrix, local force vector, local energy, etc.)  by looping over finite elements and thereby arriving at a global structure. This page describes the available assemblers and how they can be used.</p> <p>Each of the assemblers is constructed as follows: <pre><code>AssemblerName(const Basis&amp; basis, const FEContainer&amp; fes, const std::vector&lt;bool&gt;&amp; dirichletFlags)\n</code></pre></p> <ul> <li><code>basis</code> is the basis that was used to construct the finite elements. The implementation of the bases involves four different strategies: <code>BlockedLexicographic</code>, <code>BlockedInterleaved</code>, <code>FlatLexicographic</code> and <code>FlatInterleaved</code>. These strategies are to be considered while creating the assembler. For further information on these strategies, refer to Chapter 10 of DUNE<sup>1</sup>.  </li> <li><code>fes</code> is a container that contains all the finite elements that should be assembled.</li> <li><code>dirichletFlags</code> is a <code>std::vector&lt;bool&gt;</code> type. The <code>i</code>-th degree of freedom is fixed when <code>dirichletFlags[i] = true</code>.   When a reduced matrix or vector is chosen, the corresponding row and column entries are removed. </li> </ul>"},{"location":"01_framework/assembler/#base-class-for-flat-assemblers","title":"Base class for flat assemblers","text":"<p>The FlatAssemblerBase is the base class for all assemblers currently available. All other assemblers inherit from this one,  i.e., their interface includes the following functions: <pre><code>size_t size() // (1)!\nsize_t reducedSize() // (2)!\nauto &amp;finiteElements() const // (3)!\nEigen::VectorXd createFullVector(const Eigen::VectorXd &amp;reducedVector) // (4)!\nsize_t constraintsBelow(size_t i) // (5)!\nbool isConstrained(size_t i) // (6)!\nsize_t estimateOfConnectivity() // (7)!\n</code></pre></p> <ol> <li>Returns the number of degrees of freedom.</li> <li>Returns the number of degrees of freedom that are not constrained by a Dirichlet boundary condition.</li> <li>Returns a reference to the finite element container, which was passed to the assembler.</li> <li>Gets a reduced vector and returns a full vector. Entries corresponding to fixed dofs are set to 0. The values of the other entries are     obtained from the reduced vector.</li> <li>Indicates how many degrees of freedom {0,1,...i-1} are fixed.</li> <li>Indicates whether the degree of freedom <code>i</code> is fixed.</li> <li>Returns 8x the number of grid elements, which is an estimate for the connectivity. It can be used to allocate vectors.</li> </ol>"},{"location":"01_framework/assembler/#scalar-assembler","title":"Scalar assembler","text":"<p>It has the capabilities of FlatAssemblerBase plus one additional function: <pre><code>double&amp; getScalar(const RequirementType&amp; fErequirements)\n</code></pre> This assembler can be used when only a scalar quantity is of interest and the assembly of matrices or vectors is irrelevant. The available requirements are explained on the FE requirements page. <code>dirichletFlags</code> is not used in this assembler.</p> <p>It assembles the requested scalar quantity. A call to this function could look like this: <pre><code>ScalarAssembler myAssembler(...) // (1)!\nconst auto&amp; K = myAssembler.getScalar(feRequirements) // (2)!\n</code></pre></p> <ol> <li>Represents the construction of the desired assembler.</li> <li>To learn more about the available alternatives to <code>energy</code> and how this works, read the FE requirements page.</li> </ol>"},{"location":"01_framework/assembler/#flat-vector-assembler","title":"Flat vector assembler","text":"<p>It has all the features of ScalarAssembler plus more, like: <pre><code>Eigen::VectorXd&amp; getRawVector(const FERequirementType &amp;feRequirements)\nEigen::VectorXd&amp; getVector(const FERequirementType&amp; feRequirements)\nEigen::VectorXd&amp; getReducedVector(const FERequirementType&amp; feRequirements)\n</code></pre> The first one returns a vector without considering the boundary conditions. The remaining, as the name suggests, returns a full vector or a reduced vector considering boundary conditions. They work in the same way as the scalar assembly functions of ScalarAssembler. The available FE requirements are explained on the FE requirements page.</p>"},{"location":"01_framework/assembler/#flat-sparse-assembler","title":"Flat sparse assembler","text":"<p>It offers the functions of VectorFlatAssembler plus more, like: <pre><code>Eigen::SparseMatrix&lt;double&gt; &amp;getRawMatrix(const FERequirementType &amp;feRequirements) \nEigen::SparseMatrix&lt;double&gt; &amp;getMatrix(const FERequirementType &amp;feRequirements)\nEigen::SparseMatrix&lt;double&gt; &amp;getReducedMatrix(const FERequirementType &amp;feRequirements)\n</code></pre> A sparse matrix is returned. They work in the same way as the vector assembly functions of VectorFlatAssembler. The available FE requirements are explained on the FE requirements page.</p>"},{"location":"01_framework/assembler/#flat-dense-assembler","title":"Flat dense assembler","text":"<p>The only difference between the SparseFlatAssembler and the DenseFlatAssembler is that the DenseFlatAssembler returns a dense matrix. <pre><code>Eigen::MatrixXd &amp;getRawMatrix(const FERequirementType &amp;feRequirements)\nEigen::MatrixXd &amp;getMatrix(const FERequirementType &amp;feRequirements)\nEigen::MatrixXd &amp;getReducedMatrix(const FERequirementType &amp;feRequirements)\n</code></pre></p> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/controlRoutines/","title":"Control routines","text":""},{"location":"01_framework/controlRoutines/#control-routines","title":"Control routines","text":""},{"location":"01_framework/controlRoutines/#load-control","title":"Load control","text":"<p>A load control object is constructed as follows: <pre><code>auto lc = Ikarus::LoadControl(nonlinearSolver, numLoadSteps, {loadFactorStartValue, loadFactorEndValue});\n</code></pre></p> <ul> <li><code>nonlinearSolver</code> is a nonlinear solver, e.g., Newton-Raphson method, trust-region method, etc.</li> <li><code>numLoadSteps</code> is the number of load steps.</li> <li><code>loadFactorStartValue</code> is the value of the load factor at the beginning of the simulation.</li> <li><code>loadFactorEndValue</code> is the value of the load factor at the end of the simulation.</li> </ul> <p>The load control is started with the <code>run()</code> method, i.e., for the above-mentioned example: <pre><code>lc.run();\n</code></pre></p>"},{"location":"01_framework/controlRoutines/#obtaining-information-from-control-routines","title":"Obtaining information from control routines","text":"<p>The load control is an observable object, i.e. one can subscribe to the messages of the load control method. To read further on the implementation of observer patterns in Ikarus, see here.</p> <p>The following messages are available: <pre><code>enum class ControlMessages { \n  BEGIN,\n  CONTROL_STARTED,\n  CONTROL_ENDED,\n  STEP_STARTED,\n  STEP_ENDED,\n  SOLUTION_CHANGED,\n  END \n};\n</code></pre></p>"},{"location":"01_framework/controlRoutines/#path-following-techniques","title":"Path-following techniques","text":"<p>A general routine based on the standard arc-length method is included, which uses a scalar subsidiary function to impose  a constraint on the non-linear system of equations. The previously mentioned LoadControl method can also be recreated  using this technique. For more details on the standard arc-length method, see, among others, the works  of Wempner<sup>1</sup>, Crisfield<sup>2</sup>, Ramm<sup>3</sup> and  Riks<sup>4</sup> among others. A path-following object is constructed as follows: <pre><code>auto alc = Ikarus::PathFollowing(nr, load_steps, stepSize, pft);\n</code></pre> where <code>nr</code> is a Newton-Raphson solver which considers a scalar subsidiary function and is defined by <pre><code>auto nr = Ikarus::makeNewtonRaphsonWithSubsidiaryFunction(nonLinOp, std::move(linSolver));\n</code></pre> and <code>pft</code> is the desired path-following technique. Three different path-following techniques are included, namely</p> <ul> <li>Standard arc-length method</li> <li>Load control method (as a subsidiary function under this generalized implementation)</li> <li>Displacement control method (uses a vector of indices which are all controlled by a same <code>stepSize</code>).</li> </ul> <p>These can be invoked by defining  <pre><code>auto pft = Ikarus::StandardArcLength{};\nauto pft = Ikarus::LoadControlWithSubsidiaryFunction{};\nauto pft = Ikarus::DisplacementControl{controlledIndices};\n</code></pre></p> <p>Note</p> <p>The default path-following type is the <code>Ikarus::StandardArcLength{}</code>. In the current implementation, it is assumed that the external forces are given by  \\(F_{ext} = F_{ext}^0\\lambda\\) such that  $$ -\\frac{\\partial \\mathbf{R}}{\\partial \\lambda} = F_{ext}^0 $$ An implementation for a general non-linear \\(F_{ext} = F_{ext}^0\\left(\\mathbf{D},\\lambda\\right)\\) is an open task.</p> <p>In order to create an own implementation for the scalar subsidiary function, the user has to create a <code>struct</code>  with the following three member functions: <pre><code>void evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args) const;\nvoid initialPrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args);\nvoid intermediatePrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args);\n</code></pre> For each Newton-Raphson iteration, the function <code>evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args)</code> is used to evaluate the subsidiary function and  its derivatives with respect to the displacement \\(\\mathbf{D}\\) and the load factor \\(\\lambda\\). The other two functions  are used to specify a prediction for \\(\\mathbf{D}\\) and \\(\\lambda\\) for the initial step and for  all the other intermediate subsequent <code>load_steps</code>, respectively.   </p> <p><code>SubsidiaryArgs</code> is a <code>struct</code> which is defined as <pre><code>struct SubsidiaryArgs {\n  double stepSize; // (1)!\n  Eigen::VectorX&lt;double&gt; DD; // (2)!\n  double Dlambda{}; // (3)!\n  double f{}; // (4)!\n  Eigen::VectorX&lt;double&gt; dfdDD; // (5)!\n  double dfdDlambda{}; // (6)!\n};\n</code></pre></p> <ol> <li>User-desired step size</li> <li>Vector of displacement increments</li> <li>Increment in the load factor</li> <li>Scalar value evaluated from the subsidiary function</li> <li>Derivative of the subsidiary function with respect to the displacement increment</li> <li>Derivative of the subsidiary function with respect to the load factor increment</li> </ol> <p>An example for the standard arc-length method is shown below: <pre><code>struct StandardArcLength {\n    void evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args) const {\n      if (psi) {\n        const auto root = sqrt(args.DD.squaredNorm() + psi.value() * psi.value() * args.Dlambda * args.Dlambda);\n        args.f          = root - args.stepSize;\n        args.dfdDD      = args.DD / root;\n        args.dfdDlambda = (psi.value() * psi.value() * args.Dlambda) / root;\n      } else\n        DUNE_THROW(Dune::InvalidStateException,\n                   \"You have to call initialPrediction first. Otherwise psi is not defined\");\n    }\n\n    template &lt;typename NonLinearOperator&gt;\n    void initialPrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args) {\n      auto linearSolver\n          = Ikarus::LinearSolver(Ikarus::SolverTypeTag::d_LDLT);  // for the linear predictor step\n\n      nonLinearOperator.lastParameter() = 1.0;  // lambda =1.0\n\n      nonLinearOperator.template update&lt;0&gt;();\n      const auto&amp; R = nonLinearOperator.value();\n      const auto&amp; K = nonLinearOperator.derivative();\n\n      linearSolver.factorize(K);\n      linearSolver.solve(args.DD, -R);\n\n      const auto DD2 = args.DD.squaredNorm();\n\n      psi    = sqrt(DD2);\n      auto s = sqrt(psi.value() * psi.value() + DD2);\n\n      args.DD      = args.DD * args.stepSize / s;\n      args.Dlambda = args.stepSize / s;\n\n      nonLinearOperator.firstParameter() = args.DD;\n      nonLinearOperator.lastParameter()  = args.Dlambda;\n    }\n\n    template &lt;typename NonLinearOperator&gt;\n    void intermediatePrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args) {\n      nonLinearOperator.firstParameter() += args.DD;\n      nonLinearOperator.lastParameter() += args.Dlambda;\n    }\n\n    std::string name = \"Arc length\";\n\n  private:\n    std::optional&lt;double&gt; psi;\n  };\n</code></pre></p> <ol> <li> <p>Gerald A. Wempner. Discrete approximations related to nonlinear theories of solids. International Journal of Solids and Structures, 7(11):1581\u20131599, 1971. doi:10.1016/0020-7683(71)90038-2.\u00a0\u21a9</p> </li> <li> <p>M.A. Crisfield. A fast incremental/iterative solution procedure that handles \u201csnap-through\u201d. Computers &amp; Structures, 13(1):55\u201362, 1981. doi:10.1016/0045-7949(81)90108-5.\u00a0\u21a9</p> </li> <li> <p>E. Ramm. Strategies for Tracing the Nonlinear Response Near Limit Points. In W. Wunderlich, E. Stein, and K.-J. Bathe, editors, Nonlinear Finite Element Analysis in Structural Mechanics, pages 63\u201389. Springer Berlin Heidelberg, Berlin, Heidelberg, 1981. doi:10.1007/978-3-642-81589-8_5.\u00a0\u21a9</p> </li> <li> <p>E. Riks. The Application of Newton\u2019s Method to the Problem of Elastic Stability. Journal of Applied Mechanics, 39(4):1060\u20131065, 1972. doi:10.1115/1.3422829.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/dirichletBCs/","title":"Dirichlet boundary conditions","text":""},{"location":"01_framework/dirichletBCs/#dirichlet-boundary-conditions","title":"Dirichlet boundary conditions","text":""},{"location":"01_framework/dirichletBCs/#introduction","title":"Introduction","text":"<p>In finite element problems, it is essential to incorporate the Dirichlet boundary conditions, i.e.,  prescribing a part of the solution to a fixed value. Let us consider the following:</p> <p>$$  \\boldsymbol{u} = \\boldsymbol{g} \\quad \\text{on  } \\Gamma_\\mathrm{D}. $$ Here \\(  \\boldsymbol{u} \\) is the solution field with a prescribed value \\(\\boldsymbol{g}\\) on the boundary \\(\\Gamma_\\mathrm{D}\\).</p> <p>For the discrete algebraic problem, this translates to fixing the values of \\(u_i\\) to \\(g_i\\) in the approximation \\(  \\boldsymbol{u}^h = \\sum_i N^i u_i \\), where \\(  N^i \\) is the \\(i\\)-th ansatz function.</p> <p>The handling of such a function \\(\\boldsymbol{g}\\) is done by the class <code>Ikarus::DirichletValues</code>.</p>"},{"location":"01_framework/dirichletBCs/#interface","title":"Interface","text":"<p>The interface of <code>Ikarus::DirichletValues</code> is represented by the following code snippet: <pre><code>Ikarus::DirichletValues dirichletValues2(basis); // (1)!\nvoid fixBoundaryDOFs(f); // (2)!\nvoid fixDOFs(f); // (3)!\nconst auto&amp; basis() const; // (4)!\nbool isConstrained(std::size_t i) const; // (5)!\nauto fixedDOFsize() const; // (6)!\nauto size() const ; // (7)! \n</code></pre></p> <ol> <li>Create class by inserting a global basis, <sup>1</sup> Chapter 10.</li> <li>Accepts a functor to fix boundary degrees of freedom. <code>f</code> is  a functor that will be called with the boolean vector of fixed boundary.  degrees of freedom and the usual arguments of <code>Dune::Functions::forEachBoundaryDOF</code>,  as defined on page 388 of the Dune<sup>1</sup> book.</li> <li>A more general version of <code>fixBoundaryDOFs</code>. Here, a functor is to be provided that accepts a basis and the corresponding boolean vector considering the Dirichlet degrees of freedom.</li> <li>Returns the underlying basis.</li> <li>Indicates whether the degree of freedom <code>i</code> is fixed.</li> <li>Returns the number of fixed degrees of freedom.</li> <li>Returns the number of all dirichlet degrees of freedom.</li> </ol> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"01_framework/feRequirements/","title":"FE requirements","text":""},{"location":"01_framework/feRequirements/#fe-requirements","title":"FE requirements","text":"<p>Finite element requirements are a simple way to communicate the needs and expectations of a finite element.</p> <p>FE requirements are used to pass information from assemblers to finite elements. </p>"},{"location":"01_framework/feRequirements/#construction-and-usage","title":"Construction and usage","text":"<p>Usually the construction is as follows: <pre><code>FErequirements req = FErequirements()\n                           .insertGlobalSolution(FESolutions::displacement, d)\n                           .insertParameter(FEParameter::loadfactor, lambda)\n                           .addAffordance(MatrixAffordances::stiffness);\nMatrixType A = sparseFlatAssembler.getReducedMatrix(req);\n</code></pre></p> <p>All the methods return a reference to <code>FErequirements</code>, so they can be chained together.</p> <p>As in line 2, the finite element solution can also be inserted. The solution is passed with the <code>enum</code> type  <code>FESolutions::displacement</code> vector <code>d</code>. This stores a reference to the vector.</p> <p>Additionally, if some parameters are to be passed, use the method <code>insertParameter</code> (line 3), where, similar to the  global solutions, an <code>enum</code> type of <code>FEParameter::loadfactor</code> is passed to indicate the meaning of the parameter,  followed by its value.</p> <p>Finally, the method <code>addAffordance</code> is used to indicate the request required from the finite element. Thus, there exist scalar, vector, matrix and general affordance collections.</p> <p>Currently, the following are defined:</p> <pre><code>  // clang-format off\n  MAKE_ENUM(ScalarAffordances,\n    noAffordance,\n    mechanicalPotentialEnergy,\n    microMagneticPotentialEnergy\n  );\n\n  MAKE_ENUM(VectorAffordances,\n    noAffordance,\n    forces,\n    microMagneticForces\n  );\n\n  MAKE_ENUM(MatrixAffordances,\n    noAffordance,\n    stiffness,\n    materialstiffness,\n    geometricstiffness,\n    stiffnessdiffBucklingVector,\n    microMagneticHessian,\n    mass\n  );\n\n  MAKE_ENUM(FEParameter,\n    noParameter,\n    loadfactor,\n    time\n    );\n\n  MAKE_ENUM(FESolutions,\n    noSolution,\n    displacement,\n    velocity,\n    director,\n</code></pre> <p>Inside the finite element, the information can then be conveniently extracted: <pre><code>const auto&amp; d      = req.getGlobalSolution(FESolutions::displacement);\nconst auto&amp; lambda = req.getParameter(FEParameter::loadfactor);\nif(req.hasAffordance(stiffness))\n  ...\n</code></pre> Thus, the local finite element can be developed.</p> <p>Affordance</p> <pre><code>It is good style to indicate that you cannot fulfill an affordance by throwing an appropriate exception!\n</code></pre>"},{"location":"01_framework/feRequirements/#fe-result-requirements","title":"FE result requirements","text":"<p>In addition to the above-mentioned finite element requirements, there are also result requirements.  They accept the same parameter types as the <code>FErequirements</code> and add one more, the <code>ResultType</code>. These are used in the <code>calculateAt</code> method of finite elements. They are used to communicate the results required from the finite elements.</p> <p>Its construction is shown below: <pre><code>ResultRequirements resultRequirements = Ikarus::ResultRequirements()\n        .insertGlobalSolution(FESolutions::displacement, d)\n        .insertParameter(FEParameter::loadfactor, lambda)\n        .addResultRequest(ResultType::cauchyStress,,ResultType::director);\n</code></pre></p> <p>The current supported results are:</p> <pre><code>  );\n\n  MAKE_ENUM(ResultType,\n    noType,\n    magnetization,\n    gradientNormOfMagnetization,\n    vectorPotential,\n    divergenceOfVectorPotential,\n    BField,\n    HField,\n    cauchyStress,\n</code></pre> <p>The interface for result requirements is similar to the finite element requirements. They do, however, support querying specific results to be calculated.</p> <pre><code>if( req.isResultRequested( ResultType::cauchyStress)) {\n  ...\n}\n\nif( req.isResultRequested( ResultType::BField)) {\n  ...\n}\n\nif( req.isResultRequested( ResultType::director)) {\n  ...\n}\n</code></pre>"},{"location":"01_framework/finiteElements/","title":"Finite elements","text":""},{"location":"01_framework/finiteElements/#finite-elements","title":"Finite elements","text":"<p>Several disciplines associate finite elements with different meanings. In Ikarus, finite elements have two different objectives. The first one is to provide an evaluation of the scalars, vectors, and matrices.  These are associated with an algebraic representation of discrete energies, weak forms, or bilinear forms. These algebraic objects are usually constructed using some combination of local functions and  parameters stemming from the underlying physical problem, e.g., load factor, Young's modulus, or viscosity.</p> <p>The second task of finite elements is to evaluate derived results in the element parameter space, e.g., stresses or geometric quantities. This leads to the following interface for the finite elements:</p>"},{"location":"01_framework/finiteElements/#interface","title":"Interface","text":"<p>Finite elements should have non-template and non-virtual (considering non-virtual interface idiom (NVI) for the latter) interface methods. This is because these methods are usually used to assemble quantities. These functions are <code>calculateScalar</code>, <code>calculateVector</code> and <code>calculateMatrix</code>. These are public methods. Such an interface is provided by the local functions are shown below:</p> <pre><code>ScalarType calculateScalar(const FErequirements&amp; req);\nvoid calculateVector(const FErequirements&amp; req, VectorType&amp; b);\nvoid calculateMatrix(const FErequirements&amp; req, MatrixType&amp; A);\nvoid calculateLocalSystem(const FErequirements&amp; req, MatrixType&amp; A, VectorType&amp; b);\nvoid calculateAt(const Resultrequirements&amp; req, const Eigen::Vector&lt;double, Traits::mydim&gt;&amp; local,\n                     ResultTypeMap&lt;ScalarType&gt;&amp; result);\nvoid globalFlatIndices(std::vector&lt;GlobalIndex&gt;&amp; indices);\n</code></pre> <p>Since we would also like to use <code>autodiff</code> for our element, we have their protected implementations. These methods are templates to allow double or <code>autodiff</code> scalar types. These methods are <code>calculateScalarImpl</code>, <code>calculateVectorImpl</code> and <code>calculateMatrixImpl</code>. <code>calculateScalar</code>, <code>calculateVector</code> and <code>calculateMatrix</code> simply forward to these implementation functions.</p> <p>Please refer to the FE requirements to learn more about the finite element requirements and result requirements.  The first four methods receive an object of type <code>FErequirements</code>. This object is responsible for passing different types of information needed for the local evaluation of the local linear algebra objects. The first method, <code>evaluateScalar</code>, simply returns by value because it is cheaper to return a <code>double</code>, for example when evaluating energy. The other methods, <code>evaluateVector</code>, <code>evaluateMatrix</code>, and <code>calculateLocalSystem</code>, receive one or two additional output arguments where the results are to be written. This interface is needed to circumvent the dynamic memory allocation, that is required if these methods return by value.</p> <p>The method <code>calculateAt</code> is responsible for evaluating several results, and it receives the <code>ResultRequirements</code> object. These results are stored inside the output argument <code>result</code>, which is of the type <code>ResultTypeMap</code>. Additionally, there is the argument <code>local</code>, which contains the element coordinates where the results are to be evaluated.</p> <p>A typical <code>calculateAt</code> method is implemented as shown below: </p> <pre><code>typename ResultTypeMap&lt;double&gt;::ResultArray res;\nif(req.isResultRequested( ResultType::gradientNormOfMagnetization)) {\n  res.resize(1,1);\n  res(0,0)=...;\n  result.insertOrAssignResult(ResultType::gradientNormOfMagnetization,res);\n}\nif(req.isResultRequested( ResultType::BField)) {\n  res.setZero(3,1);\n  res=...;\n  result.insertOrAssignResult(ResultType::BField,res);\n}\nif(req.isResultRequested( ResultType::cauchyStress)) {\n  res.setZero(3,3);\n  res = ...;\n  result.insertOrAssignResult(ResultType::cauchyStress,res);\n}\n</code></pre> <p><code>ResultTypeMap&lt;double&gt;::ResultArray</code></p> <p><code>ResultTypeMap&lt;double&gt;::ResultArray</code> is an object of type <code>Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,0,3,3&gt;</code>. Thus, the maximum size of <code>result</code> is limited to a 3x3 matrix. This is used to circumvent dynamic memory allocations again.</p> <p>The last method is the <code>globalFlatIndices</code>. It is used to write a finite element's global indices to the output parameter <code>indices</code>. This information originates from a <code>basis</code> object. See existing implementations for details.</p>"},{"location":"01_framework/finiteElements/#linear-and-non-linear-elasticity","title":"Linear and Non-linear Elasticity","text":"<p><code>LinearElastic</code> and <code>NonLinearElastic</code> classes are designed in a generic way. This means that they could be directly used for any \\(n\\)-dimensional finite element in the geometrically linear and non-linear cases. They inherit from the class <code>PowerBasisFE</code>, which helps to arrange the nodal degrees of freedom in a <code>FlatInterleaved</code> format. Refer DUNE<sup>1</sup> for more details. The constructor for both classes of elements has the following signature: <pre><code>template &lt;typename VolumeLoad = LoadDefault, typename NeumannBoundaryLoad = LoadDefault&gt;\nLinearElastic(const Basis&amp; globalBasis, const typename LocalView::Element&amp; element, double emod, double nu,\n                  VolumeLoad p_volumeLoad = {}, const BoundaryPatch&lt;GridView&gt;* p_neumannBoundary = nullptr,\n                  NeumannBoundaryLoad p_neumannBoundaryLoad = {}) {}\n</code></pre> <pre><code>template &lt;typename VolumeLoad = LoadDefault, typename NeumannBoundaryLoad = LoadDefault&gt;\nNonLinearElastic(const Basis&amp; globalBasis, const typename LocalView::Element&amp; element, const Material&amp; p_mat,\n                 VolumeLoad p_volumeLoad = {}, const BoundaryPatch&lt;GridView&gt;* p_neumannBoundary = nullptr,\n                 NeumannBoundaryLoad p_neumannBoundaryLoad = {})\n</code></pre></p> <p>The first argument defines the basis function used to interpolate the solution field, while the second argument points to the <code>gridElement</code> itself. The next set of arguments are related to the material law to be used. For the geometrically linear case, the Young's modulus and the Poisson's ratio are passed, and a <code>planeStress</code> material model is assumed. For the geometrically non-linear case, the material model is to be passed as an argument. This could be for instance, the St. Venant-Kirchhoff material law or the Neo-Hookean material law. <code>volumeLoad</code> and <code>neumannBoundaryLoad</code> are optional parameters that could be passed as per the use case. It is necessary to note that a <code>neumannBoundary</code> must be defined if a <code>neumannBoundaryLoad</code> is to be applied. Member functions are defined as per the interface mentioned above. Two member functions are written such that the stiffness matrices and load vectors can also be obtained by automatic differentiation. These functions are <code>protected</code>. They are: <pre><code>calculateScalarImpl(const FERequirementType&amp; par, const Eigen::VectorX&lt;ScalarType&gt;&amp; dx)\ncalculateVectorImpl(const FERequirementType&amp; par, const Eigen::VectorX&lt;ScalarType&gt;&amp; dx, Eigen::VectorX&lt;ScalarType&gt;&amp; force)\n</code></pre> <code>getStrainFunction(const FERequirementType&amp; par, const Eigen::VectorX&lt;ScalarType&gt;&amp; dx)</code> is used to get the desired strain measure. It can be used to toggle between the geometrically linear and non-linear cases. <code>LinearStrains</code> are used for the geometrically linear case, while <code>GreenLagrangianStrains</code> are used for the non-linear case. These strain measures are defined as expressions in <code>dune-localfefunctions</code>. Refer to Expressions for more details. The strain-displacement operators are obtained by evaluating the derivative of the strain measure with respect to the nodal degrees of freedom. This is then used to evaluate the stiffness matrix. For more details on derivatives w.r.t. coefficients, refer here. Finally, the <code>calculateAt()</code> function evaluates the <code>linearStress</code> and <code>PK2Stress</code> (the second Piola-Kirchhoff stress tensor) as per the <code>ResultRequirementsType</code>. An implementation for a push forward operation to evaluate the <code>cauchyStress</code> is an open task. Refer to open tasks for more details.</p>"},{"location":"01_framework/finiteElements/#enhanced-assumed-strain-elements","title":"Enhanced Assumed Strain Elements","text":"<p>The Enhanced Assumed Strain (EAS) elements are a class of finite elements that helps to avoid the locking phenomenon. They are obtained by re-parametrizing the Hu-Washizu principle and enforcing an orthogonality condition. This results in an extension of the standard pure displacement formulation with an enhanced strain field (\\(\\tilde\\epsilon\\)). (\\(\\tilde\\epsilon\\)) is as an additional independent variable. The locking characteristics of the pure displacement formulations can be eliminated with an appropriate choice of ansatz space for \\(\\tilde\\epsilon\\). For further theoretical aspects, the readers are referred to <sup>2</sup> and <sup>3</sup>. The EAS formulation is currently implemented for the linear-elastic case, but it could be extended to the non-linear regime. The currently implemented EAS elements are the following:</p> <ul> <li>Q1E4</li> <li>Q1E5</li> <li>Q1E7</li> <li>H1E9</li> <li>H1E21</li> </ul> <p>The notation used here is described as follows: the first alphabet stands for a Quadrilateral (Q) or a Hexahedral (H) element. The second index denotes the order of the element. E stands for the EAS element, and the number following that denotes the  number of EAS parameters used to enhance the strain field. The only difference amongst various EAS formulations arises  from the matrix, \\(\\mathbf{M}\\) which is used to approximate the enhanced strain field. An example for the calculation of the  matrix \\(\\mathbf{M}\\) for a Q1E4 element is shown below: <pre><code>template &lt;typename Geometry&gt;\nstruct EASQ1E4 {\n  static constexpr int strainSize         = 3;\n  static constexpr int enhancedStrainSize = 4;\n\n  EASQ1E4() = default;\n  explicit EASQ1E4(const Geometry&amp; geometry)\n      : geometry{std::make_unique&lt;Geometry&gt;(geometry)}, T0InverseTransformed{calcTransformationMatrix2D(geometry)} {}\n\n  auto calcM(const Dune::FieldVector&lt;double, 2&gt;&amp; quadPos) const {\n    Eigen::Matrix&lt;double, strainSize, enhancedStrainSize&gt; M;\n    M.setZero(strainSize, enhancedStrainSize);\n    const double xi   = quadPos[0];\n    const double eta  = quadPos[1];\n    M(0, 0)           = 2 * xi - 1.0;\n    M(1, 1)           = 2 * eta - 1.0;\n    M(2, 2)           = 2 * xi - 1.0;\n    M(2, 3)           = 2 * eta - 1.0;\n    const double detJ = geometry-&gt;integrationElement(quadPos);\n    M                 = T0InverseTransformed / detJ * M;\n    return M;\n  }\n\n  std::unique_ptr&lt;Geometry&gt; geometry;\n  Eigen::Matrix3d T0InverseTransformed;\n};\n</code></pre> It is to be noted that the ansatz spaces for the matrix \\(\\mathbf{M}\\) are to be modified such that they fulfill the orthogonality  condition in the \\(\\left[0,1\\right]\\) element domain used in DUNE, in contrast to the \\(\\left[-1,1\\right]\\) usually found in  literature.</p> <p>In order to add a new EAS element, the following additions are to be made: </p> <ol> <li>Create a <code>struct</code> to calculate the matrix \\(\\mathbf{M}\\) as shown above exemplarily for the Q1E4 element.</li> <li>Add the new variant to the corresponding list of 2D and 3D variants as shown below: <pre><code>template &lt;typename Geometry&gt;\nusing EAS2DVariant = std::variant&lt;EASQ1E4&lt;Geometry&gt;, EASQ1E5&lt;Geometry&gt;, EASQ1E7&lt;Geometry&gt;&gt;;\ntemplate &lt;typename Geometry&gt;\nusing EAS3DVariant = std::variant&lt;EASH1E9&lt;Geometry&gt;, EASH1E21&lt;Geometry&gt;&gt;;\n</code></pre></li> <li>Finally, add the new EAS variant with an appropriate switch statement (as shown below) to automatically call the  desired functions <pre><code>void setEASType(int numberOfEASParameters) {\n    if constexpr (Traits::mydim == 2) {\n      switch (numberOfEASParameters) {\n        case 0:\n          onlyDisplacementBase = true;\n          break;\n        case 4:\n          easVariant = EASQ1E4(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 5:\n          easVariant = EASQ1E5(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 7:\n          easVariant = EASQ1E7(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        default:\n          DUNE_THROW(Dune::NotImplemented, \"The given EAS parameters are not available for the 2D case.\");\n          break;\n      }\n    } else if constexpr (Traits::mydim == 3) {\n      switch (numberOfEASParameters) {\n        case 0:\n          onlyDisplacementBase = true;\n          break;\n        case 9:\n          easVariant = EASH1E9(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 21:\n          easVariant = EASH1E21(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        default:\n          DUNE_THROW(Dune::NotImplemented, \"The given EAS parameters are not available for the 3D case.\");\n          break;\n      }\n    }\n  }\n</code></pre></li> </ol> <p>If the number of EAS parameters is set to zero, the pure displacement formulation is then utilised for analysis.</p> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>J. C. Simo and M. S. Rifai. A class of mixed assumed strain methods and the method of incompatible modes. Int. J. Numer. Meth. Engng., 29(8):1595\u20131638, June 1990. doi:10.1002/nme.1620290802.\u00a0\u21a9</p> </li> <li> <p>U. Andelfinger and E. Ramm. EAS-elements for two-dimensional, three-dimensional, plate and shell structures and their equivalence to HR-elements. International Journal for Numerical Methods in Engineering, 36(8):1311\u20131337, 1993. doi:10.1002/nme.1620360805.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/grids/","title":"Grids","text":""},{"location":"01_framework/grids/#grids","title":"Grids","text":"<p>In the context of the finite element method, the terms \"elements\" and \"meshes\" are often used. Each element is linked with certain attributes. The finite element (FE) code should thus be able to evaluate these attributes.  Here are some examples of attributes and the capabilities expected from the FE code:</p> <ul> <li>element number - provide a unique identifier for each element</li> <li>element shape in physical space, shape functions, ... - provide a description of the geometry</li> <li>element mass matrix, element stiffness matrix, element internal force vector, ... - provide quantities with physical meaning</li> <li>and more ...</li> </ul> <p>In the FE code, there is not one single class that serves to provide all these attributes to an element.  Different goals are achieved by different classes. A group of elements along with their attributes connected to  discretize the actual physical space is called the mesh.</p> <p>In Ikarus and i.e. in Dune, the description of the grid is decoupled from the description of the mesh to preserve its physical meaning. This helps to have the flexibility of discretizing a simple square-shaped grid with different basis functions like  Langrange or NURBS bases with different polynomial orders. This helps to attain higher levels of abstraction and fewer  iterations of modifying the existing code while studying different grids or the effects of different bases.</p> <p>For the notions of grids, grid entities, and grid factories, the definitions of Dune are utilized. For details, see <sup>1</sup> Chapter 5. All the grids that satisfy the <code>dune::grid</code> interface can be used within the Ikarus framework. This link provides an overview of the available <code>dune::grid</code> modules.</p> <p>There also exists an IGA-based grid called dune-iga to perform isogeometric analysis (refer <sup>2</sup>).</p> <p>It is important to note that the grid only provides geometric information and their relationship to their neighbors.  Even though geometry is typically constructed by some ansatz functions, grids do not provide this information to the  user because some global bases provide ansatz functions for the solution fields. Thus, the user can choose if the  problem should be formulated using the iso-parametric concept, i.e., the same ansatz functions for geometry and  solution fields, or if the ansatz functions for the solution should be independent. The basis defined by Dune is directly  used here. Thus, they use the same interface. For details, see<sup>1</sup> Chapter 10.</p> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9\u21a9</p> </li> <li> <p>J. Austin Cottrell, Thomas J. R. Hughes, and Yuri Bazilevs. Isogeometric Analysis: Toward Integration of CAD and FEA. Wiley, 2009.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/localBasis/","title":"Local basis","text":""},{"location":"01_framework/localBasis/#local-basis","title":"Local Basis","text":"<p>Each finite element includes a kind of local basis in terms of ansatz functions.  These ansatz functions need to be evaluated in the parameter domain of the finite element.</p>"},{"location":"01_framework/localBasis/#interface","title":"Interface","text":"<p>In the exported module <code>dune-localfefunctions</code>, we provide  a thin wrapper with basic caching functionality for dune bases. For the definitions of bases, refer Chapter 8.2.1 of the Dune book<sup>1</sup>. Thus <code>Dune::CachedLocalBasis</code> (<code>#include &lt;dune/cachedlocalBasis/cachedlocalBasis.hh&gt;</code>) provides the following interface: <pre><code>Dune::LocalBasis(const DuneLocalBasis&amp; p_basis);// (1)!\nvoid evaluateFunction(const DomainType&amp; local, Eigen::VectorX&lt;RangeFieldType&gt;&amp; N);\nvoid evaluateJacobian(const DomainType&amp; local,Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; dN);\nvoid evaluateFunctionAndJacobian(const DomainType&amp; local,Eigen::VectorX&lt;RangeFieldType&gt;&amp; N,\n                                 Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; dN);\n\nvoid evaluateSecondDerivatives(const DomainType&amp; local, Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim*(gridDim + 1) / 2&gt;&amp; dN);                                 \n\nconst Eigen::VectorX&lt;RangeFieldType&gt;&amp; evaluateFunction(const unsigned int&amp; integrationPointIndex);\nconst Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; evaluateJacobian(const unsigned int&amp; integrationPointIndex);\nconst Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim*(gridDim + 1) / 2&gt;&amp; evaluateSecondDerivatives(const unsigned int&amp; integrationPointIndex);\nauto viewOverIntegrationPoints();// (2)!\nauto viewOverFunctionAndJacobian();// (3)!\n\ntemplate &lt;typename IntegrationRule, typename... Ints&gt;\nvoid bind(IntegrationRule&amp;&amp; p_rule, Derivatives&lt;Ints...&gt;&amp;&amp; ints);\n\nbool isBound(int i) const;// (4)!\nconst Dune::QuadraturePoint&lt;DomainFieldType, gridDim&gt;&amp; indexToIntegrationPoint(int i) const;// (5)!\n</code></pre></p> <ol> <li>The constructor only accepts a local basis that satisfies the concept <code>Concepts::DuneLocalBasis</code>. In keeping with the spirit of duck-typing, this also allows for the use of a local basis from the Dune module.</li> <li>This returns a vector of structs containing the integration point and its index. Therefore, the syntax is usually <code>for (const auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()) {...}</code></li> <li>Returns a view over the  ansatz functions and the ansatz function Jacobians at the integration points</li> <li>Checks if the i-th derivatives are bounded.</li> <li>Convert an integration point index to a full integration point.</li> </ol> <p>The first two function calls, <code>evaluateFunction</code>  and <code>evaluateJacobian</code>, can be used to calculate the function values  \\( N(\\boldsymbol{\\xi}) \\) and the spatial derivatives \\( N_{,\\boldsymbol{\\xi}}(\\boldsymbol{\\xi}) \\). One must allocate the objects and pass them as mutable references. The same holds for <code>evaluateSecondDerivatives</code>.</p> <p>In contrast to this, there are three other methods that receive an integration point index.  These methods return a <code>const</code> reference to the evaluated ansatz function values and their first and second derivatives.</p> <p>This functionality is dependent on a previous call to <code>bind(...)</code>. This binds the local basis to one quadrature rule and caches the passed <code>bindDerivatives(..)</code>. An error is thrown if <code>evaluateFunction(const unsigned int&amp; integrationPointIndex)</code> is called before binding. Finally, to bind to an integration rule and cache the value and ansatz function Jacobian, one would use the following syntax:</p> Usage with integration point indexusing integration point coordinates <pre><code>using LocalFEType = LagrangeSimplexLocalFiniteElement&lt;double,double,dim,2&gt;;\nLocalFEType localFE;\n\nDune::CachedLocalBasis(localFE.localBasis());\nconst auto&amp; rule = Dune::QuadratureRules&lt;double, Traits::mydim&gt;::rule(localView.element().type(), order);\nlocalBasis.bind(rule, bindDerivatives(0, 1));\n\nfor (const auto&amp; [gpIndex, gp] : localBasis.viewOverIntegrationPoints()) {\n  const auto&amp; N = localBasis.evaluateFunction(gpIndex);\n  const auto&amp; dN = localBasis.evaluateJacobian(gpIndex);\n}\n</code></pre> <pre><code>using LocalFEType = LagrangeSimplexLocalFiniteElement&lt;double,double,dim,2&gt;;\nLocalFEType localFE;\n\nDune::CachedLocalBasis(localFE.localBasis());\nconst auto&amp; rule = Dune::QuadratureRules&lt;double, Traits::mydim&gt;::rule(localView.element().type(), order);\nEigen::VectorXd N;\nEigen::Matrix&lt;double, Eigen::Dynamic, gridDim&gt; dN;\n\nfor(auto&amp; gp : rule){\n  localFunction.evaluateFunction(gp.position(), N); \n  localFunction.evaluateJacobian(gp.position(), dN);\n  localFunction.evaluateFunctionAndJacobian(gp.position(), N, dN);// (1)! \n}\n</code></pre> <ol> <li>Alternative to the two lines above (Line 6 and 7)</li> </ol> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/localFunctions/","title":"Local functions","text":""},{"location":"01_framework/localFunctions/#local-functions","title":"Local functions","text":"<p>Local functions are functions that are bound to single grid elements. Therefore, they are constructed from some local basis, a coefficient vector, and the geometry of the grid element. Since the implementation is quite involved, <code>localfefunctions</code> do not reside at Ikarus but in the separate  module dune-localfefunctions.</p> <p>Usually, local functions are need to be evaluated in the local coordinate system \\( \\mathbb{\\xi} \\in T_{\\text{ref}} \\subset\\mathbb{R}^n \\) :</p> \\[ f: \\boldsymbol{\\xi}^n \\rightarrow \\mathbb{R}^m \\] <p>where \\(T_{\\text{ref}}\\) is the reference element, e.g., for a hypercube, \\(T_{\\text{ref}}= [0,1]^d\\).</p>"},{"location":"01_framework/localFunctions/#interface","title":"Interface","text":"<p>Local functions provide the following interface: <pre><code>LocalFunction(const Dune::CachedLocalBasis&lt;DuneBasis&gt;&amp; p_basis, const CoeffContainer&amp; coeffs_,\n              const std::shared_ptr&lt;const Geometry&gt;&amp; geo,\n              Dune::template index_constant&lt;ID&gt; = Dune::template index_constant&lt;std::size_t(0)&gt;{}); // (1)!\n\nFunctionReturnType evaluate(const DomainType&amp; local); \nFunctionReturnType evaluate(const unsigned int&amp; integrationPointIndex); \n\nauto evaluateDerivative(const DomainType&amp; local,...); \nauto evaluateDerivative(const unsigned int&amp; integrationPointIndex,...); \nauto viewOverIntegrationPoints(); // (2)!\n\ntemplate&lt;std::size_t ID=0&gt; \nconstexpr int order(Dune::index_constant&lt;ID&gt; ); // (3)! \n\ntemplate&lt;std::size_t ID=0&gt; \nauto basis(Dune::index_constant&lt;ID&gt; ); // (4)! \n\ntemplate&lt;std::size_t ID=0&gt; \nauto coefficientsRef(Dune::index_constant&lt;ID&gt;); // (5)! \n\ntemplate &lt;typename IntegrationRule, typename... Ints&gt; \nvoid bind(IntegrationRule&amp;&amp; p_rule, Derivatives&lt;Ints...&gt;&amp;&amp; ints); // (6)!\n\nauto clone (); // (7)! \n\ntemplate&lt;typename ScalarType, std::size_t ID=0&gt; \nauto rebindClone (ScalarType, Dune::index_constant&lt;ID&gt;); // (8)! \n</code></pre></p> <ol> <li>The constructor takes a <code>Dune::CachedLocalBasis</code>, a vector of coefficients and a shared pointer to the geometry of the grid elements.     Additionally, the local function can be tagged with a compile-time constant, e.g., <code>Dune::template index_constant&lt;0&gt;</code> or <code>Dune::Indices::_0</code>.</li> <li>This returns a vector of structs representing the integration point and its index. Therefore, the syntax is <code>for (const auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()) {...}</code></li> <li>Returns the order of the local function with respect to the coefficients. An id tag can be passed, which returns the order with respect to a tagged function. For details, see Tagging leaf local functions.</li> <li>Returns the basis of the local function. An id tag can be passed, which returns the basis of a specific tagged function. For details see Tagging leaf local functions.</li> <li>Returns a reference to the coefficient of the underlying leaf local finite elements. An id tag can be passed, which returns the basis of a specific tagged function. It can return a const or non-const reference. The non-const version is deactivated, if there is more than one leaf node with the passed id tag.  For details, see Tagging leaf local functions.</li> <li>This function is passed to the given <code>localBasis</code>. See link</li> <li>Clones the local function and stores a copy of all leave nodes.</li> <li>Clones the local function and rebinds the scalar type of the coefficients with id tag <code>ID</code>. This comes in handy if, for example, one wants to replace doubles with an autodiff type.</li> </ol> <p>The \"...\" in the <code>evaluateDerivative</code> function call refers to several possible variadic templates. The implementation looks like the following:</p> Usage with integration point indexusing integration point coordinates <pre><code>using namespace Dune::DerivativeDirections; \nlocalFunction.bind(rule, bindDerivatives(0,1));     \nfor(auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()){ \n  localFunction.evaluateDerivative(gpIndex, wrt(spatialAll)); // (1)! \n  localFunction.evaluateDerivative(gpIndex, wrt(spatialAll), on(gridElement)); // (2)! \n} \n</code></pre> <ol> <li>Compute the spatial Jacobian of localFunction </li> <li>Compute the spatial Jacobian of localFunction and transform it to the grid element</li> </ol> <pre><code>using namespace Dune::DerivativeDirections; \nfor(auto&amp; gp : rule){ \n  localFunction.evaluateDerivative(gp.position(), wrt(spatialAll)); // (1)! \n  localFunction.evaluateDerivative(gp.position(), wrt(spatialAll), on(gridElement)); // (2)! \n} \n</code></pre> <ol> <li>Compute the spatial Jacobian of localFunction </li> <li>Compute the spatial Jacobian of localFunction and transform it to the grid element</li> </ol> <p>where the first call implements</p> \\[ \\operatorname{grad}_\\boldsymbol{\\xi} f : \\boldsymbol{\\xi} \\rightarrow \\mathbb{R}^{m \\times d}. \\] <p>The second one takes into account the fact that the local function is defined in some physical space \\(\\boldsymbol{X}\\) with the coordinate \\(\\boldsymbol{x}\\). Therefore, it transforms the Jacobian from the reference element \\(\\operatorname{grad}_{\\boldsymbol{\\xi}}\\) to the Jacobian on the grid element \\(\\operatorname{grad}_\\boldsymbol{x}\\). This behavior is activated, if <code>on(gridElement)</code> is passed; otherwise, if the derivatives on the reference element is needed, pass <code>on(referenceElement)</code>.  Here, <code>gridElement</code> and <code>referenceElement</code> are global constants in the namespace <code>Dune::DerivativeDirections</code>.</p> <p>Thus, if <code>on(gridElement)</code> is passed, the local function usually implements</p> \\[ \\operatorname{grad}_\\boldsymbol{x} = \\operatorname{grad}_{\\boldsymbol{\\xi}} \\boldsymbol{J}^{-1}   \\] <p>where \\(J\\) is the Jacobian of the mapping from the reference element \\(T_{\\text{ref}}\\) to the element living in physical space \\(T\\). For details, see page 22 of the Dune book<sup>1</sup>.</p> <p>Instead of passing <code>spatialAll</code> to <code>wrt(..)</code>, there are other helper functions such as:</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(spatial(0))); // (1)!  \nlocalFunction.evaluateDerivative(gpIndex, wrt(spatial(1))); // (2)! \n</code></pre> <ol> <li>Compute the first column of the spatial Jacobian of <code>localFunction</code></li> <li>Compute the second column of the spatial Jacobian of <code>localFunction</code></li> </ol> <p>which can also be combined with <code>on(...)</code>.</p>"},{"location":"01_framework/localFunctions/#derivatives-wrt-coefficients","title":"Derivatives w.r.t. coefficients","text":"<p><pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j))); \n</code></pre> which evaluates the first derivative for a vector space valued function,e.g., for \\(f(\\boldsymbol{\\xi}) = \\sum_{I=1}^n N^I(\\boldsymbol{\\xi}) \\boldsymbol{x}_I\\),  we arrive at a matrix \\(\\boldsymbol{A}\\) such that</p> \\[ [\\boldsymbol{A}]_{ij}  = A_{ij} =  \\frac{\\partial f_i(\\boldsymbol{\\xi})}{\\partial \\boldsymbol{x}_j} \\] <p>and the second derivative</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k)), along(q)); \n</code></pre> \\[ [\\boldsymbol{B}]_{jk} =  B_{jk} = q_i A_{ijk} =  \\frac{\\partial^2 (q_i  f_i(\\boldsymbol{\\xi}))}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k} \\] <p>where \\(\\boldsymbol{q}\\) is an arbitrary vector of the same size as \\(f\\), i.e., it is the direction of the derivative in this case.  \\(\\boldsymbol{A}\\) and \\(\\boldsymbol{B}\\) are simply then the returned matrices and do not have any special meaning.  If a vector is not passed while evaluating the second derivative, the result would be a third-order tensor for a vector-valued function \\(f\\). As a result, a direction derivative in the direction given by <code>along(q)</code> is computed to return a matrix \\(\\boldsymbol{B}\\) in this case.  This helps for both readability and performance. See the example later for more details.</p>"},{"location":"01_framework/localFunctions/#derivatives-wrt-coefficients-and-spatial-derivatives","title":"Derivatives w.r.t. coefficients and spatial derivatives","text":"<p>Spatial derivatives and derivatives w.r.t. the coefficients can be combined. Therefore, it is legal to call</p> <pre><code>auto B = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatialAll), along(Q)); \nauto b1 = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatial(0)), along(q)); \nauto b2 = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatial(1)), along(q)); \n</code></pre> <p>Warning</p> <p>The order of spatial and coefficient derivatives does not matter. The returned value is always rearranged so that the first derivative is the spatial one.</p> <p>The first line is then equivalent to</p> \\[ [\\boldsymbol{B}]_{jk} =  B_{jk} = Q_{il} A_{iljk} =  \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{\\xi} f(\\boldsymbol{\\xi})]_{il} Q_{il} )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] <p>For the second and third line, we have</p> \\[\\begin{align} \\boldsymbol{b}_{0,jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^0} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}, \\\\ \\boldsymbol{b}_{1,jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^1} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\end{align}\\] <p>These objects are also returned when the second and third lines above are used.</p> <p>All of these function calls, once again, can be combined with <code>on(gridElement)</code> as shown below:</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatialAll), along(Q), on(gridElement)); \n</code></pre> <p>which computes</p> \\[ \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{x} f(\\boldsymbol{\\xi})]_{il} Q_{il} )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] <p>Warning</p> <p>Currently, only first-order spatial derivatives and second-order derivatives w.r.t. the coefficients are supported.</p>"},{"location":"01_framework/localFunctions/#example-dirichlet-energy","title":"Example: Dirichlet energy","text":"<p>This example shows how the energy, gradient, and Hessian of a dirichlet energy can be calculated. $$ E(\\boldsymbol{u}) = \\frac{1}{2} \\int_\\Omega ||\\operatorname{grad}_\\boldsymbol{x} \\boldsymbol{u}(\\boldsymbol{x})|| ^2 \\textrm{d} \\boldsymbol{x} $$</p> <p>If the energy is to be minimized w.r.t. the coefficients of the nodes, the energy, gradient, and Hessian w.r.t. the coefficients are to be calculated. Of course, this depends on the optimization algorithms, but for now, the general case where all three are needed is considered.</p> <pre><code>auto dirichletEnergy() { \n  double energy = 0; \n  // bind localBasis to some integration rule \n  // create uNodalCoeffs \n  Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs, sharedGeometry); \n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) { \n    //.. calculate the inverse Jacobian of the geometry \n    const auto gradu = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll), on(gridElement)); \n    energy+= 0.5 * (gradu.transpose() * gradu).trace() * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n  } \n} \n</code></pre> <pre><code>auto gradientDirichletEnergy(Eigen::VectorXd&amp; g) { \n  //.bind localBasis to some integration rule \n  // create uNodalCoeffs \n  constexpr int size =  // spatial size of u \n      Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs, sharedGeometry); \n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) { \n    //.. calculate the inverse Jacobian of the geometry \n    const auto gradu = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll), on(gridElement)); \n    for (auto i : fe.size()) { //loop over coeffs, i.e.nodes of the finite element \n      const auto graduDCoeffs \n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeff(i)), on(gridElement)); \n      Eigen::Vector&lt;double, size&gt; tmp; \n      tmp.setZero(); \n      for (int k = 0; k &lt; gridDimension; ++k) \n        tmp += graduDCoeffs[k] * gradu.col(k);  // (1)! \n      g.segment&lt;size&gt;(i * size) += tmp * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n    } \n  } \n} \n</code></pre> <ol> <li><code>graduDCoeffs</code> contains in <code>graduDCoeffs[0]</code> the derivatives w.r.t. the coefficient of the first column, and at <code>graduDCoeffs[1]</code> the derivatives w.r.t. the second column of <code>gradu</code>.</li> </ol> <pre><code>auto hessianDirichletEnergy(Matrix&amp; h) { \n  //... bind localBasis to some integration rule \n  // and create uNodalCoeffs \n  constexpr int size =  // spatial size of u \n      Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs, sharedGeometry); \n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) { \n    //.. calculate the inverse Jacobian of the geometry \n    for (auto i : loop over coeffs, i.e.nodes of the finite element) { \n      const auto graduDCoeffsI \n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeff(i)), on(gridElement)); \n      for (auto j : fe.size()) { //loop over coeffs, i.e.nodes of the finite element \n        const auto graduDCoeffsJ \n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeffs), on(gridElement), coeffIndices(j)); \n        Eigen::Matrix&lt;double, size, size&gt; tmp; \n        tmp.setZero(); \n        for (int k = 0; k &lt; gridDimension; ++k) \n          tmp += graduDCoeffsI[k] * graduDCoeffsJ[k]; \n        h.block&lt;size, size&gt;(i * size, j * size) += tmp * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n      } \n    } \n  } \n} \n</code></pre>"},{"location":"01_framework/localFunctions/#implementations","title":"Implementations","text":"<p>In the following, the local functions that are currently available are summarized. The ansatz functions are denoted as \\(N^i(\\boldsymbol{\\xi})\\) in the table below.</p> Name Interpolation formula Note Header Standard $$ \\boldsymbol{x} = \\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i  $$ - <code>standardLocalFunction.hh</code> Projection-Based<sup>2</sup> $$ \\boldsymbol{x} = P\\left(\\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\right) $$ This is one version of geometric finite elements. These are finite elements suited  for interpolation on manifolds. Here \\(P: \\mathbb{R}^m \\rightarrow \\mathcal{M}\\) is an operator that projects  the usual linear interpolation onto a manifold. <code>projectionBasedLocalFunction.hh</code>"},{"location":"01_framework/localFunctions/#how-to-implement-your-own-local-functions","title":"How to implement your own local functions","text":"<p>To implement your own local function, the file <code>ikarus/localFunctions/impl/localFunctionTemplate.hh</code> is made available.</p> <p>The file can be copied, and then you can rename the class to your preferred name and implement the functions mentioned below.  If a particular function is not required, it has to be deleted explicitly. Then, if someone calls that function, it returns a zero matrix or vector of appropriate size.</p> <p>These functions are all templated with <code>DomainTypeOrIntegrationPointIndex</code>, which is an integration point index or position. Additionally, <code>On&lt;TransformArgs&gt;</code> specifies whether the function should be evaluated on the reference element or the grid element (see above). <pre><code>FunctionReturnType evaluateFunctionImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                        const On&lt;TransformArgs&gt;&amp;) const; // (1)! \n\nJacobian evaluateDerivativeWRTSpaceAllImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                           const On&lt;TransformArgs&gt;&amp; transArgs) const; // (2)! \n\nJacobianColType evaluateDerivativeWRTSpaceSingleImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                                     int spaceIndex, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (3)! \n\n\nCoeffDerivMatrix evaluateDerivativeWRTCoeffsImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                                 int coeffsIndex, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (4)! \n\nCoeffDerivMatrix evaluateSecondDerivativeWRTCoeffsImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                                       const std::array&lt;size_t, 2&gt;&amp; coeffsIndex,\n                                                       const Along&lt;AlongArgs...&gt;&amp; alongArgs,\n                                                       const On&lt;TransformArgs&gt;&amp; transArgs) const; // (5)! \n\nstd::array&lt;CoeffDerivEukRieMatrix, gridDim&gt; evaluateDerivativeWRTCoeffsANDSpatialImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, int coeffsIndex,\n    const On&lt;TransformArgs&gt;&amp; transArgs) const; // (6)! \n\n\nCoeffDerivEukRieMatrix evaluateDerivativeWRTCoeffsANDSpatialSingleImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, int coeffsIndex, int spatialIndex,\n    const On&lt;TransformArgs&gt;&amp; transArgs) const;  // (7)! \n\n\nauto evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, const std::array&lt;size_t, 2&gt;&amp; coeffsIndex,\n    const Along&lt;AlongArgs...&gt;&amp; alongArgs, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (8)! \n\nCoeffDerivMatrix evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialSingleImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, const std::array&lt;size_t, 2&gt;&amp; coeffsIndex,\n    const int spatialIndex, const Along&lt;AlongArgs...&gt;&amp; alongArgs, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (9)! \n</code></pre></p> <ol> <li>This is called by <code>localFunction.evaluate(...)</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(coeff(j,k)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll,coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i),coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll,coeff(j,k)), along(A))</code>. <code>A</code> can be accessed via <code>std::get&lt;0&gt;(alongArgs.args)</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i),coeff(j,k)), along(v))</code>. <code>v</code> can be accessed via <code>std::get&lt;0&gt;(alongArgs.args)</code>.</li> </ol>"},{"location":"01_framework/localFunctions/#expressions","title":"Expressions","text":"<p>Expression templates are usually used in linear algebra libraries, e.g., Eigen or Blaze. The syntax is similar to the one provided by UML but only acts on local functions. Expression templates are used here to combine existing local functions in order to obtain new nested ones.</p> <p>For example, consider the following code: <pre><code>... \nauto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0, sharedGeometry); \nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1, sharedGeometry); \n</code></pre> Two local functions that satisfy the interface described above are created. Now it is possible to combine these functions and get an object that also satisfies the concept above. Thus, the following is possible: <pre><code>... \nauto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0, sharedGeometry); \nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1, sharedGeometry); \nauto k = f + g; \nk.evaluateDerivative(ipIndex, wrt(coeff(i), spatial(d))); \n</code></pre></p> <p>Currently, binary and unary expressions are supported. The following expressions are defined:</p> Name Mathematical formula Code Note Sum $$ \\boldsymbol{f} + \\boldsymbol{g}  $$ <code>f+g</code> \\(\\boldsymbol{f}\\)  and  \\(\\boldsymbol{g}\\) needs to be of the same size. DotProduct $$ \\boldsymbol{f} \\cdot \\boldsymbol{g} = f_i g_i $$ <code>dot(f,g)</code> \\(\\boldsymbol{f}\\)  and  \\(\\boldsymbol{g}\\) needs to be of the same size. normSquared $$ \\boldsymbol{f} \\cdot \\boldsymbol{f} = f_i f_i $$ <code>normSquared(f)</code> Negate $$ -\\boldsymbol{f}  $$ <code>-f</code> sqrt $$ \\sqrt{f}  $$ <code>sqrt(f)</code> The function \\(f\\) needs a scalar return type. log $$ \\log{f}  $$ <code>log(f)</code> The function \\(f\\) needs a scalar return type. Here, log is the natural logarithm. pow $$ f^n  $$ <code>pow&lt;n&gt;(f)</code> The function \\(f\\) needs a scalar return type. \\(n\\) is an integer given during compile-time. Scale $$  a f , \\quad a \\in  \\mathbf{R}$$ <code>a*f</code> and <code>f/a</code> <code>a</code> has to satisfy <code>std::is_arithmetic&lt;..&gt;</code> LinearStrains $$ \\frac{1}{2}\\left(\\boldsymbol{H}+\\boldsymbol{H}^T \\right),\\quad \\boldsymbol{H} = \\mathrm{grad}(\\boldsymbol{f})  $$ <code>linearStrains(f)</code> If you call the formula on the left with <code>on(gridElement)</code>, it will assume the transformed derivatives. GreenLagrangianStrains $$ \\frac{1}{2}\\left(\\boldsymbol{H}+\\boldsymbol{H}^T +\\boldsymbol{H}^T \\boldsymbol{H}\\right),\\quad \\boldsymbol{H} = \\mathrm{grad}(\\boldsymbol{f})  $$ <code>greenLagrangianStrains(f)</code> If you call the formula on the left with <code>on(gridElement)</code>, it will assume the transformed derivatives. <p>These expressions can also be nested. As a result, it is valid to write <pre><code>auto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0); \nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1); \nauto k = -sqrt(dot(2*f+f,5*g)); \nk.evaluateDerivative(ipIndex, wrt(coeff(i), spatial(d))); \n</code></pre></p> <p>To use these expressions, there are additional exported static types for all expressions. <pre><code>constexpr bool isLeaf; // (1)! \nconstexpr bool children; // (2)! \n</code></pre></p> <ol> <li>This is true if the underlying expression is one of the above local functions that really contain the coefficients; see Implementations.</li> <li>Returns the number of children (2 for binary expressions and 1 for unary expressions).</li> </ol> <p>Note</p> <p>To use these expression, simply include the header <code>#include &lt;dune/localfefunctions/expressions.hh&gt;</code>.</p>"},{"location":"01_framework/localFunctions/#tagging-leaf-local-functions","title":"Tagging leaf local functions","text":"<p>In the context of mixed finite elements, there are usually several local functions that contribute to the energy. These stem from different local bases. For example, consider the Q1P0 element, where displacements are interpolated by using the four bilinear ansatz functions and the element-wise constant pressure field.</p> <p>Then, to obtain gradients and Hessians, we need to differentiate w.r.t. different coefficients.  This can be done by tagging the local function during construction. <pre><code>using namespace Dune::Indices; \nauto f = Ikarus::StandardLocalFunction(localBasis0, coeffVectors0, sharedGeometry, _0); \nauto g = Ikarus::StandardLocalFunction(localBasis1, coeffVectors1, sharedGeometry, _1); \nauto k = dot(f,g); \nk.evaluateDerivative(ipIndex, wrt(coeff(_0,i,_1,j))); // Second derivative w.r.t. the nodal coefficients\n</code></pre> To explain the last line above, let us consider that the function f is constructed as \\(f= \\sum_{I=0}^n N^L f_L\\) and similarly  \\(g= \\sum_{I=0}^m M^K g_K\\), where \\(N\\) and \\(M\\) are ansatz functions and \\(f_L\\) and \\(g_K\\) are nodal coefficients.</p> <p>Thus, the above call translates to</p> \\[\\begin{align} \\frac{\\partial^2 (\\boldsymbol{f} \\cdot \\boldsymbol{g} )}{\\partial \\boldsymbol{f}_i\\partial \\boldsymbol{g}_j}, \\end{align}\\] <p>where the correct sizes of the result are derived at compile-time. The complete Hessian of \\(\\boldsymbol{f} \\cdot \\boldsymbol{g}\\) can be calculated by the following: <pre><code>using namespace Dune::Indices; \nauto hessianDirichletEnergy(Matrix&amp; h) { \n  //... bind localBasis to some integration rule \n  using namespace Dune::Indices; \n  auto f = Ikarus::StandardLocalFunction(localBasis0, coeffVectors0, sharedGeometry, _0); \n  auto g = Ikarus::StandardLocalFunction(localBasis1, coeffVectors1, sharedGeometry, _1); \n  auto k = dot(f,g); \n  constexpr int sizef = f.correctionSize; // spatial size of the correction of the coefficients of f \n  constexpr int sizeg = g.correctionSize; // spatial size of the correction of the coefficients of g \n  constexpr int coeffSizef = coeffVectors0.size(); \n  constexpr int coeffSizeg = coeffVectors1.size(); \n\n  Dune::MultiTypeBlockMatrix&lt;Dune::MultiTypeBlockVector&lt;MatrixBlock00,MatrixBlock01&gt;, \n                                       Dune::MultiTypeBlockVector&lt;MatrixBlock10,MatrixBlock11&gt; &gt; KBlocked; // (1)! \n\n\n  for (const auto&amp; [gpIndex, gp] : k.viewOverIntegrationPoints()) { \n    for (size_t I = 0; I &lt; coeffSizef; ++I) \n      for (size_t J = 0; J &lt; coeffSizef; ++J)  \n        KBlocked[_0,_0].block&lt;sizef, sizef&gt;(I * sizef, J * sizef)  \n          += k.evaluateDerivative(gpIndex, wrt(coeff(_0,I,_0,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n\n    for (size_t I = 0; I &lt; coeffSizef; ++I) \n      for (size_t J = 0; J &lt; coeffSizeg; ++J) \n        KBlocked[_0,_1].block&lt;sizef, sizeg&gt;(I * sizef, J * sizeg)  \n          += k.evaluateDerivative(gpIndex, wrt(coeff(_0,I,_1,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n\n    for (size_t I = 0; I &lt; coeffSizeg; ++I) \n      for (size_t J = 0; J &lt; coeffSizeg; ++J) \n        KBlocked[_1,_1].block&lt;sizeg, sizeg&gt;(I * sizeg, J * sizeg)  \n          += k.evaluateDerivative(gpIndex, wrt(coeff(_1,I,_1,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n\n    for (size_t I = 0; I &lt; coeffSizeg; ++I) \n      for (size_t J = 0; J &lt; coeffSizef; ++J) \n        KBlocked[_1,_0].block&lt;sizef, sizeg&gt;(I * sizeg, J * sizef)  \n          += k.evaluateDerivative(gpIndex, wrt(coeff(_1,I,_0,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n    } \n} \n</code></pre></p> <ol> <li>This block structure is not necessary. Additionally, in this example, all types (MatrixBlock00, MatrixBlock01, MatrixBlock10, MatrixBlock11) are considered as <code>Eigen::MatrixXd</code>.</li> </ol>"},{"location":"01_framework/localFunctions/#writing-your-own-expressions","title":"Writing your own expressions","text":"<p>It is also possible to write your own expressions. To do so, please take a look at the existing expressions.  The <code>sqrt</code> and <code>normSquared</code> expressions are the most general unary and binary expressions implemented.</p>"},{"location":"01_framework/localFunctions/#implementing-the-return-value","title":"Implementing the return value","text":"<p>Implementing a return value is the first step in implementing an expression.  This is done by using the following function: <pre><code>template &lt;typename LFArgs&gt; \nauto evaluateValueOfExpression(const LFArgs &amp;lfArgs) const; \n</code></pre></p> <p>Warning</p> <p>The interface dictates that the return value needs to be an <code>Eigen</code> type. Thus, even if a scalar double is to be returned, it is to be wrapped in <code>Eigen::Vector&lt;double, 1&gt;</code></p> <p>Additionally, the evaluation of the derivative is to be implemented as shown below: <pre><code>template &lt;int DerivativeOrder, typename LFArgs&gt; \nauto evaluateDerivativeOfExpression(const LFArgs &amp;lfArgs) const; \n</code></pre></p>"},{"location":"01_framework/localFunctions/#evaluate-the-underlying-functions","title":"Evaluate the underlying functions","text":"<p>Expressions always act on existing expressions. Therefore, to have the correct return value for the expression, the underlying quantities are to be evaluated. <code>this-&gt;m()</code> is used to access unary functions, and <code>this-&gt;l()</code> and <code>this-&gt;r()</code> are used to access binary expressions.</p> <p>To evaluate unary functions, the following syntax is used:</p> <p><pre><code>const auto mEvaluated = evaluateFunctionImpl(this-&gt;m(), lfArgs); \n</code></pre> and for binary functions, <pre><code>const auto l_Evaluated = evaluateFunctionImpl(this-&gt;l(), lfArgs); \nconst auto r_Evaluated = evaluateFunctionImpl(this-&gt;r(), lfArgs); \n</code></pre> Because the expression conforms to the syntax of a local function, its derivative can also be evaluated.</p> <p>In the function <code>evaluateDerivativeOfExpression</code>, the template argument <code>DerivativeOrder</code> contains the derivative order. Additionally, the derivative types can also be accessed using the static booleans, as shown below: <pre><code>    static constexpr bool hasTwoCoeff; \n    static constexpr bool hasSingleCoeff; \n    static constexpr bool hasNoCoeff; \n    static constexpr bool hasNoSpatial; \n    static constexpr bool hasOneSpatialAll; \n    static constexpr bool hasOneSpatialSingle; \n    static constexpr bool hasOneSpatial; \n</code></pre></p> <p>Using the dot-product as a binary expression example, we have <pre><code>template &lt;int DerivativeOrder, typename LFArgs&gt; \n    auto evaluateDerivativeOfExpression(const LFArgs &amp;lfArgs) const { \n      const auto u = evaluateFunctionImpl(this-&gt;l(), lfArgs); \n      const auto v = evaluateFunctionImpl(this-&gt;r(), lfArgs); \n      if constexpr (DerivativeOrder == 1)  // (1)! \n      { \n        const auto u_x = evaluateDerivativeImpl(this-&gt;l(), lfArgs); // (2)! \n        const auto v_x = evaluateDerivativeImpl(this-&gt;r(), lfArgs); \n        return Ikarus::eval(v.transpose() * u_x + u.transpose() * v_x); // (3)!\n      } else if constexpr (DerivativeOrder == 2) {   // (4)! \n        const auto &amp;[u_x, u_y] = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (5)! \n        const auto &amp;[v_x, v_y] = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs); \n        if constexpr (LFArgs::hasNoSpatial and LFArgs::hasTwoCoeff) { // (6)! \n          const auto alonguArgs = replaceAlong(lfArgs, along(v)); // (7)! \n          const auto alongvArgs = replaceAlong(lfArgs, along(u));  \n\n          const auto u_xyAlongv = evaluateDerivativeImpl(this-&gt;l(), alongvArgs); // (8)! \n          const auto v_xyAlongu = evaluateDerivativeImpl(this-&gt;r(), alonguArgs); \n\n          return Ikarus::eval(u_xyAlongv + transpose(u_x) * v_y + transpose(v_x) * u_y + v_xyAlongu); \n        } else if constexpr (LFArgs::hasOneSpatial and LFArgs::hasSingleCoeff) { // (9)! \n          const auto u_xy = evaluateDerivativeImpl(this-&gt;l(), lfArgs); // (10)! \n          const auto v_xy = evaluateDerivativeImpl(this-&gt;r(), lfArgs); \n          if constexpr (LFArgs::hasOneSpatialSingle and LFArgs::hasSingleCoeff) { // (11)! \n            return Ikarus::eval(transpose(v) * u_xy + transpose(u_x) * v_y + transpose(v_x) * u_y \n                                + transpose(u) * v_xy); \n          } else if constexpr (LFArgs::hasOneSpatialAll and LFArgs::hasSingleCoeff) { // (12)! \n            std::array&lt;std::remove_cvref_t&lt;decltype(Ikarus::eval(transpose(v) * u_xy[0]))&gt;, gridDim&gt; res; // (13)! \n            for (int i = 0; i &lt; gridDim; ++i) \n              res[i] = Ikarus::eval(transpose(v) * u_xy[i] + transpose(u_x.col(i)) * v_y + transpose(v_x.col(i)) * u_y \n                                    + transpose(u) * v_xy[i]); \n            return res; \n          } \n        } \n      } else if constexpr (DerivativeOrder == 3) { // (14)!                                      \n        if constexpr (LFArgs::hasOneSpatialSingle) {  // (15)! \n          const auto argsForDyz = lfArgs.extractSecondWrtArgOrFirstNonSpatial(); // (16)! \n\n          const auto &amp;[u_x, u_y, u_z] = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (17)! \n          const auto &amp;[v_x, v_y, v_z] = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs); \n          const auto &amp;[u_xy, u_xz]    = evaluateSecondOrderDerivativesImpl(this-&gt;l(), lfArgs); // (18)! \n          const auto &amp;[v_xy, v_xz]    = evaluateSecondOrderDerivativesImpl(this-&gt;r(), lfArgs); \n\n          const auto alonguArgs             = replaceAlong(lfArgs, along(u)); \n          const auto alongvArgs             = replaceAlong(lfArgs, along(v)); \n          const auto argsForDyzalongv_xArgs = replaceAlong(argsForDyz, along(v_x)); // (19)! \n          const auto argsForDyzalongu_xArgs = replaceAlong(argsForDyz, along(u_x)); \n\n          const auto u_xyzAlongv = evaluateDerivativeImpl(this-&gt;l(), alongvArgs); // (20)! \n          const auto v_xyzAlongu = evaluateDerivativeImpl(this-&gt;r(), alonguArgs); \n          const auto u_yzAlongvx = evaluateDerivativeImpl(this-&gt;l(), argsForDyzalongv_xArgs); // (21)! \n          const auto v_yzAlongux = evaluateDerivativeImpl(this-&gt;r(), argsForDyzalongu_xArgs); \n\n          return Ikarus::eval(u_xyzAlongv + transpose(u_xy) * v_z + transpose(u_xz) * v_y + v_yzAlongux + u_yzAlongvx \n                              + transpose(v_xz) * u_y + transpose(v_xy) * u_z + v_xyzAlongu); \n        } else if constexpr (LFArgs::hasOneSpatialAll) { // (22)! \n          const auto &amp;alongMatrix = std::get&lt;0&gt;(lfArgs.alongArgs.args); // (23)! \n\n          const auto uTimesA = eval(u * alongMatrix); \n          const auto vTimesA = eval(v * alongMatrix); \n\n          const auto &amp;[gradu, u_c0, u_c1]  = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (24)! \n          const auto &amp;[gradv, v_c0, v_c1]  = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs); \n          const auto &amp;[gradu_c0, gradu_c1] = evaluateSecondOrderDerivativesImpl(this-&gt;l(), lfArgs); // (25)! \n          const auto &amp;[gradv_c0, gradv_c1] = evaluateSecondOrderDerivativesImpl(this-&gt;r(), lfArgs); \n\n          const auto graduTimesA = (gradu * alongMatrix.transpose()).eval(); \n          const auto gradvTimesA = (gradv * alongMatrix.transpose()).eval(); \n\n          const auto argsForDyz = lfArgs.extractSecondWrtArgOrFirstNonSpatial(); \n\n          const auto alonguAArgs          = replaceAlong(lfArgs, along(uTimesA)); \n          const auto alongvAArgs          = replaceAlong(lfArgs, along(vTimesA)); \n          const auto alonggraduTimesAArgs = replaceAlong(argsForDyz, along(graduTimesA)); \n          const auto alonggradvTimesAArgs = replaceAlong(argsForDyz, along(gradvTimesA)); \n\n          const auto u_xyzAlongv            = evaluateDerivativeImpl(this-&gt;l(), alongvAArgs); \n          const auto v_xyzAlongu            = evaluateDerivativeImpl(this-&gt;r(), alonguAArgs); \n          const auto v_c0c1AlongGraduTimesA = evaluateDerivativeImpl(this-&gt;r(), alonggraduTimesAArgs); \n          const auto u_c0c1AlongGradvTimesA = evaluateDerivativeImpl(this-&gt;l(), alonggradvTimesAArgs); \n          decltype(eval(u_xyzAlongv)) res; \n\n          res = u_xyzAlongv + v_xyzAlongu + v_c0c1AlongGraduTimesA + u_c0c1AlongGradvTimesA; \n          for (int i = 0; i &lt; gridDim; ++i) \n            res += (transpose(u_c1) * gradv_c0[i] + transpose(v_c1) * gradu_c0[i] + transpose(v_c0) * gradu_c1[i] \n                    + transpose(u_c0) * gradv_c1[i]) \n                   * alongMatrix(0, i); \n\n          return res; \n\n        } \n      }  \n    } \n</code></pre></p> <ol> <li>Compile-time branch for first-order derivatives</li> <li>Evaluates the derivative of <code>this-&gt;l()</code> in relation to the only derivative contained within the local function arguments <code>lfArgs</code>.</li> <li>Evaluates the return value; derivatives and function values are combined as dictated by the product rule.</li> <li>Compile-time branch for second-order derivatives</li> <li>We have four cases for evaluating functions because we are in the second-order derivatives branch: the function value, the function derivative w.r.t. the first argument or the second argument, and the function's derivative w.r.t. both arguments.    Here, the function <code>evaluateFirstOrderDerivativesImpl</code> returns the derivatives w.r.t. the first argument and the second argument.    If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\), this calls returns    \\begin{flalign*}    \\verb+u_x+ &amp;= \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{\\xi}} \\quad \\text{or} \\quad \\verb+u_x+ = \\frac{\\partial\\boldsymbol{u}}{\\partial\\xi_0} \\quad \\text{or} \\quad \\verb+u_x+ = \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{u}_I}\\\\    \\verb+u_y+ &amp;= \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{u}_J}    \\end{flalign*}    The first one would be returned if it is called as    <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i))); \n</code></pre>    and the second one if it is called as    <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i))); \n</code></pre>    and the third without any spatial derivative is returned using    <pre><code>    u.evaluateDerivative(gpIndex, wrt(coeff(i,j))); \n</code></pre>    Therefore, this function separates the two <code>wrt</code> arguments and returns the corresponding first order derivatives.</li> <li>Compile-time branch for the case where no spatial derivatives are requested but only the derivatives w.r.t. coefficients are needed.</li> <li>Creates a new argument variable where the <code>along</code> argument is replaced by <code>v</code>.</li> <li>This function evaluates the derivatives of <code>l</code> w.r.t. to both <code>wrt</code> arguments. Furthermore, it takes the <code>along</code> argument since otherwise the returned object would be a 3-dimensional array.    If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\)  and \\(\\boldsymbol{v}\\) of the same size as \\(\\boldsymbol{u}\\) this calls returns    \\begin{flalign*}    \\verb+u_xyAlongv + &amp;= \\frac{\\partial^2 u_i }{\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} v_i    \\end{flalign*}    This is the same if the following is called:    <pre><code>    u.evaluateDerivative(gpIndex, wrt(coeff(i,j)),along(v)); \n</code></pre></li> <li>Compile-time branch for the case where one spatial derivative and one derivative w.r.t. the coefficients is needed.</li> <li>This function evaluates the derivatives of <code>l</code> w.r.t. to both <code>wrt</code> arguments.     If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\)  this calls returns     \\begin{flalign*}     \\verb+u_xy+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_I} \\quad \\text{or} \\quad \\verb+u_xy+ = \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\xi_0\\partial\\boldsymbol{u}_I}     \\end{flalign*}     The first one would be returned if it is called as    <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i))); \n</code></pre> and the second one if it is called as    <pre><code>u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i))); \n</code></pre> In the first case the result is stored in an array. Thus, in the first index, the derivative w.r.t. to the first spatial coordinate is stored. Therefore, we have    <pre><code>spatialAllCoeffDeriv = u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i))); \nspatialAllCoeffDeriv[0] // derivative as in u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i))); \nspatialAllCoeffDeriv[1] // derivative as in u.evaluateDerivative(gpIndex, wrt(spatial(1),coeff(i))); \n</code></pre></li> <li>Compile-time branch for the case where one single spatial derivatives and one derivative w.r.t. coefficients is needed.</li> <li>Compile-time branch for the case where all spatial derivatives and one derivative w.r.t. coefficients is needed.</li> <li>The return type here is an array of single spatial derivatives and each derived w.r.t. the coefficient. Thus the type inside the array must be deduced here.</li> <li>Compile-time branch for third order derivatives</li> <li>Compile-time branch for single spatial derivatives</li> <li>To obtain derivatives w.r.t. to the second and third <code>wrt</code> argument, we extract the arguments here. E.g., for the following request:    <pre><code> u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix)); \n</code></pre> This call would extract the arguments as    <pre><code> newArgs =  \"wrt(coeff(i,j)),along(matrix))\" //THIS IS NO VALID SYNTAX \n</code></pre> This can then be used as    <pre><code>u.evaluateDerivative(gpIndex, newArgs); \n</code></pre></li> <li>As in the second order derivative case, it returns all the three first order derivatives. E.g., for the case,     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix)); \n</code></pre>     the returned values would be     \\begin{flalign*}     \\verb+u_x+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}} \\\\     \\verb+u_y+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{u}_I} \\\\     \\verb+u_z+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{u}_J}     \\end{flalign*}</li> <li>This returns the derivatives w.r.t. the given spatial direction and w.r.t. the first and second coefficient.  E.g., for the case,     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix)); \n</code></pre>     the returned values would be     \\begin{flalign*}     \\verb+u_xy+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_I} \\\\     \\verb+u_xz+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_J} \\\\     \\end{flalign*}</li> <li>Creates a new argument variable where the <code>along</code> argument is replaced by <code>v_x</code>.</li> <li>This return call would be     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i,j),along(v)); \n</code></pre>     In mathematical notation, it returns     \\begin{flalign*}     \\verb+u_xyzAlongv  + &amp;= \\frac{\\partial^3 u_i }{\\partial \\xi_0\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} v_i     \\end{flalign*}</li> <li>This return would be     <pre><code>v_x = v.evaluateDerivative(gpIndex, wrt(spatial(0)); \nu_yzAlongvx = u.evaluateDerivative(gpIndex, wrt(coeff(i,j),along(v_x)); \n</code></pre>     In mathematical notation, it returns     \\begin{flalign*}     \\verb+u_yzAlongvx+ &amp;= \\frac{\\partial^2 u_i }{\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} \\left[\\frac{\\partial \\boldsymbol{v}}{\\xi_0}\\right]_i     \\end{flalign*}</li> <li>Compile-time branch for all spatial derivatives</li> <li>Obtain the <code>along</code> argument defined, for example, in     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j),along(matrix)); \n</code></pre></li> <li>Similar to the single spatial case</li> <li>Similar to the single spatial case</li> </ol> <p>If your expression is working, it can be added to <code>dune/localfefunctions/expressions.hh</code> by submitting a PR  to dune-localfefunctions.</p> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal, 57(1):404\u2013428, 2019. doi:10.1137/18M1176798.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/manifolds/","title":"Manifolds","text":""},{"location":"01_framework/manifolds/#manifold-elements","title":"Manifold elements","text":"<p>Usually optimization problems are defined in terms of a cost function, such as:</p> <p>$$  \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) $$ where \\( f: \\mathcal{M} \\rightarrow \\mathbb{R} \\).</p> <p>Usually \\( \\mathcal{M} \\) is an Euclidean vector space \\( \\mathbb{R}^n \\).</p> <p>In a finite element context, for example, in 2D elasticity problems, we have a  two-dimensional displacement for each node. As a result, if there are \\(n \\) nodes, we optimize in \\( {\\mathbb{R}^{2n}} \\).</p> <p>The nodal degrees of freedom should be wrapped in <code>Ikarus::RealTuple&lt;double,2&gt;</code> in this case.</p> <p>Another case of optimization is on non-linear manifolds. These arise typically for Cosserat materials \\( \\mathcal{S}\\mathcal{O}(3) \\)<sup>1</sup>,  Reissner-Mindlin shells \\( \\mathcal{S}^2 \\)<sup>2</sup> and micro-magnetics \\( \\mathcal{S}^{2} \\) or incompressible materials.</p>"},{"location":"01_framework/manifolds/#interface","title":"Interface","text":"<p>The general interface of the manifold elements is represented by the following concept. <pre><code>namespace Ikarus::Concepts {\n  template &lt;typename ManifoldType&gt;\n  concept Manifold = requires(ManifoldType var, typename ManifoldType::CorrectionType correction, std::ostream&amp; s,\n                              typename ManifoldType::CoordinateType value) {\n    typename ManifoldType::ctype; // (1)!\n    ManifoldType::valueSize; // (2)!\n    ManifoldType::correctionSize; // (3)!\n    typename ManifoldType::CoordinateType; // (4)!\n    typename ManifoldType::CorrectionType; // (5)!\n    { var.getValue() } -&gt; std::convertible_to&lt;typename ManifoldType::CoordinateType&gt;; // (6)!\n    { var.setValue(value) } -&gt; std::same_as&lt;void&gt;; // (7)!\n    { var+=correction };  // (8)!\n    //...\n  };\n}  \n</code></pre></p> <ol> <li>The type for the coordinate values, usually <code>double</code>.</li> <li>The number of values to store for the state of the element. E.g., the three-dimensional unit vector needs three entries to store its state.</li> <li>The size of the correction for an element. <code>valueSize</code> and <code>correctionSize</code> are the same in Euclidean space. But, for example, the three-dimensional unit vector needs a two-dimensional correction (which lives in the tangent space).</li> <li>The type to store the element coordinates is usually <code>Eigen::Vector&lt;double,ManifoldType::valueSize&gt;</code></li> <li>The type to store the element correction type is usually <code>Eigen::Vector&lt;double,ManifoldType::correctionSize&gt;</code></li> <li>Access the underlying coordinate vector of the manifold element.</li> <li>Directly set the value. E.g., set <code>Ikarus::UnitVector&lt;double,3&gt; a; a.setValue(Eigen::Vector3d::UnitZ());</code></li> <li>Update the element with a correction vector. E.g.,      <pre><code>   Ikarus::RealTuple&lt;double,3&gt; a; \n   a+= Eigen::Vector3d::UnitX();\n\n   Ikarus::UnitVector&lt;double,3&gt; b; \n   b+= Eigen::Vector2d::UnitX();\n</code></pre></li> </ol>"},{"location":"01_framework/manifolds/#implementations","title":"Implementations","text":"Name Formal definition Notes Header \\(n\\)-th dimensional Euclidean space $$ \\boldsymbol{x} \\in \\mathbb{R}^n  $$ <code>realTuple.hh</code> Unit sphere $$ \\boldsymbol{x} \\in \\mathcal{S}^{n-1}, \\quad \\mathcal{S}^{n-1} = \\left\\{ \\boldsymbol{x} \\in \\mathbb{R}^n :  \\boldsymbol{x}\\cdot  \\boldsymbol{x}  = 1 \\right\\}  $$ <code>unitVector.hh</code> <ol> <li> <p>Oliver Sander. Geodesic finite elements for cosserat rods. International Journal for Numerical Methods in Engineering, 82(13):1645\u20131670, 2010. doi:10.1002/nme.2814.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> </ol>"},{"location":"01_framework/nonlinearOperator/","title":"Nonlinear operator","text":""},{"location":"01_framework/nonlinearOperator/#nonlinear-operator","title":"Nonlinear operator","text":"<p>The class <code>NonLinearOperator</code> consists of a collection of a function and its derivatives, including their dependence  on parameters. </p> <p>Let us assume a function <code>f(x)</code> and its derivative <code>df(x)</code>. Then, a <code>NonLinearOperator</code> can be constructed as follows:</p> <pre><code>double x               = 13;\nauto fvLambda  = [&amp;](auto&amp;&amp; x) { return f(x); };\nauto dfvLambda = [&amp;](auto&amp;&amp; x) { return df(x); };\n\nauto nonLinOp = Ikarus::NonLinearOperator(functions(fvLambda, dfvLambda), parameter(x));\n</code></pre> <p>Note</p> <p>It is assumed that the second function is the derivative of the first function, the third function is the derivative of the second function (2<sup>nd</sup> derivative of the first function), and so on.</p> <p><code>functions(...)</code> and <code>parameter(...)</code> are helper functions. They are necessary to distinguish which argument is a function and which argument is a parameter.</p> <p><code>nonLinOp</code> provides the following features: <pre><code>void updateAll() // (1)!\nvoid update&lt;n&gt;() // (2)!\nauto&amp; value() // (3)!\nauto&amp; derivative() // (4)!\nauto&amp; secondDerivative() // (5)!\nauto&amp; nthDerivative&lt;n&gt;() // (6)!\nauto&amp; firstParameter() // (7)!\nauto&amp; secondParameter() // (8)!\nauto&amp; nthParameter&lt;n&gt;() // (9)!\nauto&amp; lastParameter() // (10)!\nauto subOperator&lt;n,m,...&gt;() // (11)!\n</code></pre></p> <ol> <li>Evaluates all functions.</li> <li>Evaluates the n-th function in <code>functions(...)</code> . Counting starts from 0, as always in C++.</li> <li>Returns the result of the function evaluation.</li> <li>Returns the result of the evaluation of the first derivative (if the function for the first derivative is passed to the nonlinear operator during construction).</li> <li>Returns the result of the evaluation of the second derivative (if the function for the second derivative is passed to the nonlinear operator during construction).</li> <li>Returns the result of the evaluation of the n-th derivative (if the function for the n-th derivative is passed to the nonlinear operator during construction).</li> <li>Returns the value of the first parameter.</li> <li>Returns the value of the second parameter (if available).</li> <li>Returns the value of the n-th parameter (if available).</li> <li>Returns the value of the last parameter.</li> <li>Creates an <code>Ikarus::NonLinearOperator</code> with a subset of the derivatives. For example, let us consider a nonlinear operator with     (function, first derivative, second derivative). <code>subOperator&lt;0,1&gt;()</code> then returns a nonlinear operator with     (function, first derivative).</li> </ol>"},{"location":"01_framework/observer/","title":"Observer and observables","text":""},{"location":"01_framework/observer/#observer-and-observable","title":"Observer and Observable","text":"<p>To write output messages when desired by the user, the observer pattern is implemented in Ikarus. Four things are necessary to understand the implementation of observer patterns: <code>Messages</code>, <code>IObservable</code>,  <code>IObserver</code> and <code>Subscriptions</code>.</p>"},{"location":"01_framework/observer/#messages","title":"Messages","text":"<p>A message class is a list of possible events that can happen and might be of interest. The messages that are used for  nonlinear solvers are listed below as an example. <pre><code>enum class NonLinearSolverMessages {\n  BEGIN,\n  INIT,\n  ITERATION_STARTED,\n  ITERATION_ENDED,\n  RESIDUALNORM_UPDATED,\n  CORRECTIONNORM_UPDATED,\n  SOLUTION_CHANGED,\n  FINISHED_SUCESSFULLY,\n  END\n};\n</code></pre></p>"},{"location":"01_framework/observer/#iobservable","title":"IObservable","text":"<p>A class can be observable. The class then sends notifications when events are happening. To become observable, a class  must inherit from <code>IObservable&lt;MessageType&gt;</code>, for example, <pre><code>class NewtonRaphson : public IObservable&lt;NonLinearSolverMessages&gt; {...};\n</code></pre> The function <code>this-&gt;notify(MessageType::Message)</code> is called at the appropriate position in the code to send a  notification. This could be, for example, <pre><code>this-&gt;notify(NonLinearSolverMessages::SOLUTION_CHANGED);\n</code></pre></p>"},{"location":"01_framework/observer/#iobserver","title":"IObserver","text":"<p>A class can be an observer. The class is then notified when events are happening and can perform actions. A very simple example is shown below. To become an observer, the class must inherit from <code>IObserver&lt;MessageType&gt;</code>, where <code>MessageType</code> is the <code>enum</code> of messages to use (see above).  <pre><code>class OurFirstObserver : public IObserver&lt;NonLinearSolverMessages&gt; {\npublic:\n  void updateImpl(NonLinearSolverMessages message) override {\n    if (message == NonLinearSolverMessages::ITERATION_STARTED) std::cout &lt;&lt; \"Iteration started.\\n\";\n  }\n};\n</code></pre> The observer has to implement the function <code>void updateImpl(MessageType message)</code>. In this function, all actions can be implemented that should be performed when the corresponding message is received.</p> <p>To connect observer and observable, one has to call <code>observalbe.subscribe(MessageType::Message,observer)</code>. Example: <pre><code>Ikarus::NewtonRaphson nr(...);\nauto ourSimpleObserver = std::make_shared&lt;OurFirstObserver&gt;();\nnr.subscribe(NonLinearSolverMessages::ITERATION_STARTED, ourSimpleObserver);\n};\n</code></pre></p>"},{"location":"01_framework/observer/#subscriptions","title":"Subscriptions","text":"<p>There are a couple of options for the subscription: <pre><code>subscribe(MessageType::Message,observer) // (1)!\nsubscribeAll(observer) // (2)!\nsubscribeAll({observer1,observer2}) // (3)!\nunSubscribe(...) // (4)!\n</code></pre></p> <ol> <li>Subscribes to one specific message.</li> <li>Subscribes to all the messages in <code>enum</code>.</li> <li>Multiple observers can subscribe at once.</li> <li>Unsubscribe from specific messages or all messages.</li> </ol> <p>To send a message together with data, the sender (observable) calls <pre><code>this-&gt;notify(MessageType::Message,data);\n</code></pre> and the receiver (observer) has to implement <pre><code>void updateImpl(MessageType message, data) override {...}\n</code></pre> To see all available options for <code>data</code>, we refer to the file <code>observer.hh</code>.</p>"},{"location":"01_framework/solvers/","title":"Solvers","text":""},{"location":"01_framework/solvers/#solvers","title":"Solvers","text":"<p>In Ikarus, there are essentially two types of solvers: linear and non-linear.</p>"},{"location":"01_framework/solvers/#linear-solver","title":"Linear solver","text":"<p>It solves for the vector \\( \\boldsymbol{x} \\) in</p> <p>$$ \\boldsymbol{A}  \\boldsymbol{x} =  \\boldsymbol{b} $$ where \\(\\boldsymbol{A} \\) and \\(\\boldsymbol{b}\\) are any matrix or vector, respectively. These solvers can be direct or iterative. Furthermore, they depend on the underlying structure of the  matrix \\(\\boldsymbol{A} \\), i.e., whether it is stored in a <code>dense</code> or <code>sparse</code> format.</p> <p>Currently, only the linear solvers provided by the Eigen  library are supported.</p> <p>Linear solvers can be constructed by calling the constructor:</p> <pre><code>LinearSolver(const SolverTypeTag&amp; solverTypeTag)\n</code></pre> <p>There exists an enum type <code>SolverTypeTag</code> with the following values:</p> <pre><code>    si_BiCGSTAB,\n    sd_SimplicialLLT,\n    sd_SimplicialLDLT,\n    sd_SparseLU,\n    sd_SparseQR,\n    sd_CholmodSupernodalLLT,\n    sd_UmfPackLU,\n    sd_SuperLU,\n    d_PartialPivLU,\n    d_FullPivLU,\n    d_HouseholderQR,\n    d_ColPivHouseholderQR,\n    d_FullPivHouseholderQR,\n    d_CompleteOrthogonalDecomposition,\n    d_LLT,\n    d_LDLT,\n  };\n\n  enum class MatrixTypeTag { Dense, Sparse };\n</code></pre> <p>The prefixes <code>s_</code> and  <code>d_</code> indicate whether the linear solver can be used for <code>sparse</code> or <code>dense</code> matrices, respectively. Furthermore, there is also a second prefix for sparse solvers: <code>d</code> and <code>i</code> for direct solvers and for iterative solvers, respectively. Thus, using <code>si_ConjugateGradient</code> means that this solver is for sparse matrices and is an iterative solver.</p> <p>Note</p> <p>All dense solvers are currently direct solvers. Therefore, we do not distinguish them.</p> <p>The naming of the solvers is the same as in the Eigen library.  For more details on the solvers, we refer to Eigen's documentation for dense decompositions and to Eigen's documentation for sparse decompositions.</p>"},{"location":"01_framework/solvers/#interface","title":"Interface","text":"<p>Similar to Eigen's interface, the following functions are provided: <pre><code>void analyzePattern(const MatrixType&amp; A);  // (1)!\nvoid factorize(const MatrixType&amp; A); // (2)!\nLinearSolver&amp; compute(const MatrixType&amp; A); // (3)!\nvoid solve(Eigen::VectorX&lt;ScalarType&gt;&amp;x, const Eigen::VectorX&lt;ScalarType&gt;&amp; b); // (4)!\n</code></pre></p> <ol> <li>If the matrix is sparse, Eigen can collect information on the sparsity pattern of the matrix for a faster <code>solve</code> step. This pattern does not change if the non-zero entries are modified.</li> <li>This method applies a decomposition technique for direct solvers, e.g., LU decomposition. For iterative solvers, the method is a non-linear operator.</li> <li>It calls both the functions <code>analyzePattern</code> and <code>factorize</code>.</li> <li>Solves the problem and stores the result in <code>x</code>.</li> </ol> <p>Tip</p> <p>If your algorithm relies on special features or attributes of a linear solver, then the solver is to be directly used. For example, if the <code>.determinant()</code> method of <code>Eigen::SimplicialLDLT</code> is required, it must be called directly because  <code>LinearSolver</code>does not support it.</p>"},{"location":"01_framework/solvers/#nonlinear-solver","title":"Nonlinear solver","text":"<p>Non-linear solvers are usually used to solve a kind of optimization problem, e.g., root-finding or minimization problems like: \\begin{align}   \\boldsymbol{R}(\\boldsymbol{x}) \\stackrel{!}{=} \\boldsymbol{0} \\quad \\text{or} \\quad   \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) \\end{align}</p> <p>It has the following interface: <pre><code>void setup(const NewtonRaphsonSettings&amp; p_settings); // (1)!\nSolverInformation solve(const SolutionType&amp; dx_predictor = NoPredictor{}); // (2)!\nauto&amp; nonLinearOperator(); // (3)!\n</code></pre></p> <ol> <li>With this function, several properties of the nonlinear solver can be set. E.g., residual tolerance or maximum number of iterations</li> <li>Solves the non-linear problem. An initial guess to the function can be passed, otherwise, a zero vector is assumed.    It returns the <code>SolverInformation</code> which contains information like the success of the solution step and more. </li> <li>Just returns the underlying <code>nonLinearOperator</code>, see link.</li> </ol> <p>Note</p> <p>To ease the construction process, the non-linear solver can provide a method <code>make[...]</code> that allows shorter syntax since no <code>std::shared_ptr</code> has to be constructed specifying the template arguments.  The construction of the nonlinear solvers can be very different. Therefore, we do not impose an interface for the constructors.</p>"},{"location":"01_framework/solvers/#implementations","title":"Implementations","text":"Name Purpose Constraints on nonlinear operator Header Properties Newton-Raphson Root finding Value and gradient <code>newtonRaphson.hh</code> Locally quadratic convergence Newton-Raphson with scalar subsidiary function Root finding with a scalar function as additional constraint Value, gradient and a scalar function <code>newtonRaphsonWithScalarSubsidiaryFunction.hh</code> Locally quadratic convergence Trust-Region Minimization Value, gradient and Hessian <code>trustRegion.hh</code> Globally convergent and locally quadratic convergence <p>To see the Newton-Raphson implementation, we refer to the tests inside <code>nonLinearOperatorTest.cpp</code>, and for the  trust-region method, <code>trustRegionTest.cpp</code>.</p>"},{"location":"02_examples/","title":"Index","text":""},{"location":"02_examples/#examples","title":"Examples","text":"<p>In order to understand several features of Ikarus, a set of examples is provided within the finite element framework. These can be found at IkarusExamples. The installation and execution  methodologies are briefly discussed in the README file  of the repository. Each example is given a unique identification in the beginning of the file name of the form <code>iksXXX</code>. This unique identification is also used in the following instead of the complete <code>*.cpp</code> file name. Auxiliary files  for the examples, such as <code>*.msh</code>, <code>*.geo</code>, or <code>*.parset</code> can be found in <code>../../src/testFiles/</code>.  In order to add a new example, create a pull request with your executable file in the repository IkarusExamples and, in  parallel, update the documentation here. See How to Contribute and  How to Edit for more information.  </p> <p>The available examples are:</p> Identification Name of the example iks001 Compute the value of \\(\\pi\\) iks002 Cantilever beam with point load iks003 Deformation of an incompressible rubber block iks004 Plate subjected to a surface load iks005 Newton-Raphson method iks006 Non-linear Elasticity for 2D solids iks007 Von-Mises truss iks008 Cook's membrane"},{"location":"02_examples/cantileverBeam/","title":"Cantilever beam with point load","text":""},{"location":"02_examples/cantileverBeam/#cantilever-beam-with-point-load","title":"Cantilever beam with point load","text":""},{"location":"02_examples/cantileverBeam/#description","title":"Description","text":"<p>The example <code>iks002_cantileverBeamOneDGrid.cpp</code> demonstrates a simple implementation of the standard one-dimensional  Timoshenko beam element, which is clamped on the left-hand side. A point load is applied on the right-hand side of the beam. It uses <code>Dune::OneDGrid</code> to generate the required  grid. The implementation shown here assembles the stiffness matrices explicitly. Advanced  implementations of matrix assembly and other features of Ikarus are showcased in the other examples.</p>"},{"location":"02_examples/cantileverBeam/#code-highlights","title":"Code highlights","text":"<p>The <code>main()</code> function calls the following function to run the example. <pre><code>void exampleTimoshenkoBeam(const int polynomialOrderW, // (1)! \nconst int polynomialOrderPhi, // (2)!\nconst int numElements // (3)!\n);\n</code></pre></p> <ol> <li>polynomial order for the approximation of the displacement <code>w</code></li> <li>polynomial order for the approximation of the rotation <code>phi</code></li> <li>number of elements</li> </ol> <p>This function has pre-defined geometric and material parameters that are mentioned below: <pre><code>const double b  = 1; // (1)! \nconst double L  = 10; // (2)! \nconst double E  = 1000; // (3)! \nconst double G  = E / 2;  // Poisson's ratio = 0 // (4)! \nconst double t  = 1e-3; // (5)! \n</code></pre></p> <ol> <li>breadth of the beam (rectangular cross-section assumed)</li> <li>length of the beam</li> <li>Young's modulus</li> <li>Shear modulus (Poisson's ratio is assumed to be zero)</li> <li>thickness of the beam (rectangular cross-section assumed)</li> </ol> <p>The material matrix is then defined as  <pre><code>Eigen::Matrix2d C;\nC &lt;&lt; EI, 0, 0, GA;\n</code></pre></p> <p>The one-dimension grid is created by specifying the starting (<code>0</code>) and end (<code>L</code>) points of the beam and using <code>numElements</code>. The grid module <code>Dune::OneDGrid</code><sup>1</sup> is used here. The composite basis feature in Dune allows for  different bases for the degrees of freedom <code>w</code> and <code>phi</code>. Empty dense global and local stiffness matrices are then defined along with  a global external load vector. The quadrature rule for integration of the stiffness matrix and the external load vector is set up as shown below: <pre><code>const int maxOrderIntegration = std::max(2 * (polynomialOrderW - 1), 2 * polynomialOrderPhi);\nconst auto &amp;rule\n    = Dune::QuadratureRules&lt;double, 1&gt;::rule(ele.type(), maxOrderIntegration, Dune::QuadratureType::GaussLegendre);\n</code></pre> The local element stiffness matrix is then obtained by the following function: <pre><code>void TimoshenkoBeamStiffness(auto &amp;KLocal, auto &amp;localView, auto &amp;gridElement, auto &amp;quadratureRule, const Eigen::Matrix2d &amp;C);\n</code></pre> Access to the information corresponding to the two independent degrees of freedom (<code>w</code> and <code>phi</code>) can be obtained by using the child elements as depicted below: <pre><code>auto wFE   = localView.tree().child(_0);\nauto phiFE = localView.tree().child(_1);\nDune::CachedLocalBasis basisW(wFE.finiteElement().localBasis()); // (1)! \nDune::CachedLocalBasis basisPhi(phiFE.finiteElement().localBasis()); // (2)! \n</code></pre></p> <ol> <li>a local basis created for <code>w</code></li> <li>a local basis created for <code>phi</code></li> </ol> <p>The determinant of Jacobian is obtained by using <code>auto detJ = gridElement.geometry().volume();</code>. The  \\(\\mathbf{B}\\)-operator and the local stiffness matrix are then obtained by <pre><code>Eigen::Matrix2Xd B;\nfor (auto &amp;gp : quadratureRule) { // (1)! \n  basisW.evaluateJacobian(gp.position(), dNwDxi); // (2)! \n  basisPhi.evaluateFunction(gp.position(), Nphi); // (3)! \n  basisPhi.evaluateJacobian(gp.position(), dNphiDxi); // (4)! \n\n  B.setZero(Eigen::NoChange, numDofsPerEle);\n\n  for (unsigned int i = 0; i &lt; wFE.size(); ++i)\n    B(1, wFE.localIndex(i)) = dNwDxi[i] / detJ; // (5)! \n\n  for (unsigned int i = 0; i &lt; phiFE.size(); ++i)\n    B.col(phiFE.localIndex(i)) &lt;&lt; dNphiDxi[i] / detJ, Nphi[i]; // (6)! \n\n  KLocal += B.transpose() * C * B * detJ * gp.weight(); // (7)! \n}\n</code></pre></p> <ol> <li>Looping over the integration point</li> <li>derivative of the ansatz function of <code>w</code> with respect to the local parametric space</li> <li>ansatz function of <code>phi</code></li> <li>derivative of the basis of <code>phi</code> with respect to the local parametric space</li> <li>Filling up the \\(\\mathbf{B}\\)-operator for the columns corresponding to 'w'</li> <li>Filling up the \\(\\mathbf{B}\\)-operator for the columns corresponding to 'phi'</li> <li>Integrating to arrive at the local stiffness matrix</li> </ol> <p>Assembly of the local element stiffness matrices is done to obtain the global element stiffness matrix, as shown below: <pre><code>for (auto i = 0U; i &lt; localView.size(); ++i)\n  for (auto j = 0U; j &lt; localView.size(); ++j)\n    KGlobal(localView.index(i)[0], localView.index(j)[0]) += KLocal(i, j);\n</code></pre> The point load on the right end of the beam is applied by setting the corresponding entry in the global external load  vector to the prescribed value <code>F</code> using the command <code>FExtGlobal(getGlobalDofId(TimoshenkoBeam::w, basis, L)) = F;</code>. The function  <pre><code>unsigned int getGlobalDofId(TimoshenkoBeam requestedQuantity, const auto &amp;basis, const double position);\n</code></pre> with <pre><code>enum class TimoshenkoBeam { w, phi };\n</code></pre> is used to get the degree of freedom of the <code>requestedQuantity</code> (<code>w</code> or <code>phi</code>) for the defined <code>basis</code> at position <code>L</code>.</p> <p>The left end of the beam is clamped by using the following code: <pre><code>std::vector&lt;unsigned int&gt; fixedDofs{getGlobalDofId(TimoshenkoBeam::w, basis, 0.0),\n                                    getGlobalDofId(TimoshenkoBeam::phi, basis, 0.0)};\nfor (auto dof : fixedDofs) {\n  KGlobal.col(dof).setZero();\n  KGlobal.row(dof).setZero();\n  KGlobal(dof, dof) = 1.0;\n}\n</code></pre> Finally, the system of equations is solved by using the solver type <code>Ikarus::SolverTypeTag::d_LDLT</code>. For more  details on the solver types, refer to the documentation. For post-processing, the deformed configuration of the beam can be plotted using the following function, shown here in the example: <pre><code>void plotDeformedTimoschenkoBeam(auto &amp;gridView, auto &amp;basis, auto &amp;d_glob, double EI, double GA, double L, double F);\n</code></pre> This function uses the plotting features of Matplot++,  which has a similar syntax to Matplotlib.</p>"},{"location":"02_examples/cantileverBeam/#takeaways","title":"Takeaways","text":"<ul> <li><code>Dune::OneDGrid</code> can be used to create one-dimensional grids. </li> <li>Grids and quadrature rules from Dune can be directly incorporated into the Ikarus framework.</li> <li>A composite basis can be used to have different ansatz functions for different degrees of freedom.</li> <li>Solvers from the Eigen library can be used to solve the linear system of equations.</li> <li><code>localBasis</code> functions can be used to evaluate the ansatz functions and its derivatives.</li> </ul> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"02_examples/computePi/","title":"Compute the value of pi","text":""},{"location":"02_examples/computePi/#compute-the-value-of-pi","title":"Compute the value of \\(\\pi\\)","text":""},{"location":"02_examples/computePi/#description","title":"Description","text":"<p>The example <code>iks001_computePi.cpp</code> shows the calculation of \\(\\pi\\) by computing the area and circumference of a unit circle. This example helps to understand the <code>Grid</code> module from Dune and the refinement techniques it brings. The example shows that a global refinement doesn't refine the number of grid entities on the boundary of the circle, which leads to a poor approximation of \\(\\pi\\) when comparing it with the area and circumference of the circle. On the other hand, it also shows how elements on the boundaries can be marked and refined, thereby resulting in an accurate approximation of \\(\\pi\\).</p>"},{"location":"02_examples/computePi/#code-highlights","title":"Code highlights","text":"<p>This example contains the following two functions: <pre><code>boundaryUnawareRefinedCircle();\nboundaryAwareRefinedCircle();\n</code></pre> demonstrating the usage of certain attributes of the grid module from Dune<sup>1</sup>. Firstly, we explain the function <code>boundaryUnawareRefinedCircle();</code>.</p> <p>Here, a <code>circleCoarse.msh</code> file, which was created using Gmsh, is read using the <code>Dune::GmshReader</code> and a <code>Dune::ALUGrid</code> object is created as shown below: <pre><code>constexpr int gridDim = 2;  // (1)\nusing Grid            = Dune::ALUGrid&lt;gridDim, 2, Dune::simplex, Dune::conforming&gt;;\nauto grid             = Dune::GmshReader&lt;Grid&gt;::read(\"auxiliaryFiles/circleCoarse.msh\", false);\nauto gridView         = grid-&gt;leafGridView();  // (2)\n</code></pre> It is to note that dune-grid only supports Version 2 of the Gmsh format. The <code>draw(gridView);</code> functionality is  included within the Ikarus framework to quickly draw grids and verify them for any major errors. The function <code>grid-&gt;globalRefine(1);</code> is invoked to refine the grid on a global level. This means that, if we have  a single square-shaped 4-node quadrilateral element, the <code>globalRefine(1)</code> function will bisect the element once in  either direction and thereby result in a grid with 2 elements in either direction. This type of refinement is done for triangular elements in  the following, and the area of the circle is compared to the value of \\(\\pi\\). The area of the circle itself is obtained by  summing the volumes (area in 2D terms) of individual elements. <pre><code>double area = 0.0;\nfor (int i = 0; i &lt; 3; ++i) {\n  area = 0.0;\n  grid-&gt;globalRefine(1);\n  auto gridViewRefined = grid-&gt;leafGridView();\n  std::cout &lt;&lt; \"This gridview contains: \";\n  std::cout &lt;&lt; gridViewRefined.size(0) &lt;&lt; \" elements\" &lt;&lt; std::endl;\n  for (auto &amp;element : elements(gridViewRefined)) {\n    area += element.geometry().volume();\n  }\n  std::cout &lt;&lt; std::setprecision(10) &lt;&lt; \"Area: \" &lt;&lt; area &lt;&lt; \" Pi: \" &lt;&lt; std::numbers::pi &lt;&lt; std::endl;\n}\n</code></pre> The area of individual elements is also written in a <code>*.vtu</code> file using the module <code>Dune::VTKWriter</code>. More explanations  of this are found in subsequent examples. In this example, we restrict ourselves to the grid refinement strategies and  accessing grid entities from Dune.</p> <p>It is also possible to check if the element has any edges at the boundary using the method <code>element.hasBoundaryIntersections()</code>. If this is true, the edges intersecting with the boundaries can be extracted, and the <code>volume</code> method on this <code>intersection</code>  object would then return the length of the edge in the 2D case. The circumference of this unit circle is then computed as shown below: <pre><code>double circumference = 0.0;\nfor (auto &amp;element : elements(gridView))\n  if (element.hasBoundaryIntersections())\n    for (auto &amp;intersection : intersections(gridView, element))\n      if (intersection.boundary()) circumference += intersection.geometry().volume();\n</code></pre> It is observed that even though the grid is globally refined in every loop, the computed value of \\(\\pi\\) never converges.  This is due to the fact that the triangular grid doesn't change its area with refinement. Even though the grid has many elements with every refinement,  it doesn't contain enough information about the boundary of the circle to predict an accurate value of \\(\\pi\\). In order to refine  the boundary entities correctly, the <code>boundaryAwareRefinedCircle()</code> function is formulated and explained next.</p> <p>In this function, the grid is created explicitly and isn't read from an external <code>*.msh</code> file. The corners are  calculated manually, which is followed by the insertion of vertices, elements, and boundary segments as shown below: <pre><code>Dune::GridFactory&lt;Dune::ALUGrid&lt;gridDim, 2, Dune::simplex, Dune::conforming&gt;&gt; gridFactory;\nEigen::Vector2d v(1, 0);\nstd::array&lt;FieldVector&lt;double, 2&gt;, 6&gt; corners0;\nEigen::Rotation2D&lt;double&gt; R;\nR.angle() = 0.0;\nfor (auto &amp;corner : corners0) {\n  Eigen::Vector2d a = R * v;\n  corner[0]         = a[0];\n  corner[1]         = a[1];\n  R.angle() += 60.0 / 180.0 * std::numbers::pi;\n}\n\ngridFactory.insertVertex({0, 0});\ngridFactory.insertVertex(corners0[0]);\ngridFactory.insertVertex(corners0[1]);\ngridFactory.insertVertex(corners0[2]);\ngridFactory.insertVertex(corners0[3]);\ngridFactory.insertVertex(corners0[4]);\ngridFactory.insertVertex(corners0[5]);\n\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 1, 2});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 2, 3});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 3, 4});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 4, 5});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 5, 6});\ngridFactory.insertElement(Dune::GeometryTypes::triangle, {0, 6, 1});\n\n/// Create boundary segments which map the boundaries onto the unit circle\ngridFactory.insertBoundarySegment({1, 2}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[0], corners0[1]));\ngridFactory.insertBoundarySegment({2, 3}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[1], corners0[2]));\ngridFactory.insertBoundarySegment({3, 4}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[2], corners0[3]));\ngridFactory.insertBoundarySegment({4, 5}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[3], corners0[4]));\ngridFactory.insertBoundarySegment({5, 6}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[4], corners0[5]));\ngridFactory.insertBoundarySegment({6, 1}, std::make_shared&lt;UnitCircleBoundary&gt;(corners0[5], corners0[0]));\n\nauto grid     = gridFactory.createGrid();\nauto gridView = grid-&gt;leafGridView();\n</code></pre> To refine the grid entities living in the boundary, the elements that have intersections with the boundary are  first marked and then refined, as shown in the code below: <pre><code>for (const auto &amp;ele : elements(grid-&gt;leafGridView())) {\n  if (ele.hasBoundaryIntersections()) grid-&gt;mark(1, ele);\n}\ngrid-&gt;preAdapt();\ngrid-&gt;adapt();\ngrid-&gt;postAdapt();\nauto gridViewRefined = grid-&gt;leafGridView();\n</code></pre> Now, the calculation of area and circumference to determine the value of \\(\\pi\\) converges correctly.</p>"},{"location":"02_examples/computePi/#takeaways","title":"Takeaways","text":"<ul> <li><code>Dune::GmshReader</code> can be used to read <code>*.msh</code> files to import grids.</li> <li>Grid entities can be marked and locally refined, or the grid can be globally refined.</li> <li>Grids can also be explicitly created by inserting vertices, elements, and boundary segments.</li> <li><code>element.hasBoundaryIntersections()</code> can be used to check if an element has any intersections with the boundaries.</li> </ul> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"02_examples/cooksMembrane/","title":"Cook's membrane","text":""},{"location":"02_examples/cooksMembrane/#cooks-membrane","title":"Cook's membrane","text":""},{"location":"02_examples/cooksMembrane/#description","title":"Description","text":"<p>The example <code>iks008_cooksMembrane.cpp</code> implements the Cook's membrane problem adapted from the paper<sup>1</sup>.  This problem can be solved not only with the structured meshes provided, but also with unstructured and triangular meshes.  The input parameters, like material and grid parameters, are read from the file <code>iks008_cooksMembrane.parset</code>. The problem can also be solved with the standard 2D planar solid element  or with enhanced assumed strain elements. For more details on the element technologies, refer to the documentation. <code>iks008</code> solves the problem with a set of existing finite elements and compares the convergence rates.</p>"},{"location":"02_examples/cooksMembrane/#code-highlights","title":"Code highlights","text":"<p>In this example, the standard Q1 finite element and the enhanced assumed strain elements Q1E4, Q1E5, and Q1E7 are used to solve the Cook's membrane problem. Convergence studies are done for the vertical displacement in the top right corner, and the assembly time for the stiffness matrix is also compared. The date and time utilities from the standard C++ library are used to determine the computation times in this example. This example not only loops over the different refinement levels for a convergence plot but also loops over the different element types.  In order to avoid re-building the complete code with modifications to certain input parameters, the <code>parametertreeparser.hh</code> can be used from the dune-common module. The <code>Dune::ParameterTree</code> is used to read the Young's modulus (<code>E</code>), the Poisson's ratio (<code>nu</code>), and the level of refinement (<code>refinement_level</code>), as shown below: <pre><code>Dune::ParameterTree parameterSet;\nDune::ParameterTreeParser::readINITree(argv[1], parameterSet);\n\nconst Dune::ParameterTree &amp;gridParameters     = parameterSet.sub(\"GridParameters\");\nconst Dune::ParameterTree &amp;controlParameters  = parameterSet.sub(\"ControlParameters\");\nconst Dune::ParameterTree &amp;materialParameters = parameterSet.sub(\"MaterialParameters\");\n\nconst double E             = materialParameters.get&lt;double&gt;(\"E\");\nconst double nu            = materialParameters.get&lt;double&gt;(\"nu\");\nconst int refinement_level = gridParameters.get&lt;int&gt;(\"refinement\");\n</code></pre> <code>argv[1]</code> is the variable in the argument vector that contains <code>iks008_cooksMembrane.parset</code> to read the input parameters.  The file <code>cook.msh</code> contains the Cook's membrane problem with a structured grid, whereas <code>cook_tri.msh</code> and <code>cook_unstructured.msh</code>  contains the same problem with triangular elements and with an unstructured mesh, respectively. The mesh file is read using  <code>Dune::GmshReader</code> and <code>Dune::UGGrid</code> is used to get the <code>grid</code> object. <code>easSet</code> is an <code>Eigen::Vector</code> that contains the number of EAS parameters for the four element types.  It is important to note that if the number of EAS parameters is set to zero, the standard Q1 formulation is used.  <pre><code>Eigen::Vector&lt;int, 4&gt; easSet;\neasSet &lt;&lt; 0, 4, 5, 7;\n</code></pre> The EAS elements are created then, as shown below: <pre><code>auto numberOfEASParameters = easSet(nep); // (1)!\nstd::vector&lt;Ikarus::EnhancedAssumedStrains&lt;Ikarus::LinearElastic&lt;decltype(basis)&gt;&gt;&gt; fes;\nfor (auto &amp;element : elements(gridView)) {\n  fes.emplace_back(basis, element, E, nu, &amp;volumeLoad, &amp;neumannBoundary, &amp;neumannBoundaryLoad);\n  fes.back().setEASType(numberOfEASParameters);\n}\n</code></pre></p> <ol> <li><code>nep</code> is the index of the <code>for</code>-loop which runs from 0 to 4 here.</li> </ol> <p>The Dirichlet boundary conditions are defined for the left edge, and the Neumann boundary condition on the right edge is defined by the usage of the dune-python interface. A sparse assembler is used, and the linear system of equations is solved. The vertical displacement in the top right corner is computed as shown below and is later stored in a vector:  <pre><code>auto dispGlobalFunc = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;Dune::FieldVector&lt;double, 2&gt;&gt;(*basis, D_Glob);\nauto localView      = basis.flat().localView();\nauto localw         = localFunction(dispGlobalFunc);\ndouble uy_fe        = 0.0;\nEigen::Vector2d req_pos;\nreq_pos &lt;&lt; 48.0, 60.0;\nfor (auto &amp;ele : elements(gridView)) {\n  localView.bind(ele);\n  localw.bind(ele);\n  const auto geo = localView.element().geometry();\n  for (size_t i = 0; i &lt; 4; ++i) {\n    if (Dune::FloatCmp::eq(geo.corner(i)[0], req_pos[0]) and Dune::FloatCmp::eq(geo.corner(i)[1], req_pos[1])) {\n      const auto local_pos = geo.local(toDune(req_pos));\n      uy_fe                = toEigen(localw(local_pos)).eval()[1];\n    }\n  }\n}\n</code></pre> The datasets are then stored and plotted using Matplot++. The deformed configuration is also written using the <code>Dune::VTKWriter</code> and can be visualized using Paraview. Several log information is also displayed in this example using spdlog.</p>"},{"location":"02_examples/cooksMembrane/#takeaways","title":"Takeaways","text":"<ul> <li><code>Dune::ParameterTree</code> can be used to read input parameters from an external <code>*.parset</code> file.</li> <li>A linear elastic element of arbitrary dimension can be used to solve the underlying problem. In 2D and 3D, this element can be enriched with enhanced assumed strains.</li> <li><code>spdlog/spdlog.h</code> can be used to display log information.</li> <li><code>chrono</code> library can be used to determine the computation time.</li> </ul> <ol> <li> <p>Robert D. Cook. Improved Two-Dimensional Finite Element. J. Struct. Div., 100(9):1851\u20131863, September 1974. doi:10.1061/JSDEAG.0003877.\u00a0\u21a9</p> </li> </ol>"},{"location":"02_examples/incompressibleRubberBlock/","title":"Compression of an incompressible rubber block","text":""},{"location":"02_examples/incompressibleRubberBlock/#deformation-of-an-incompressible-rubber-block","title":"Deformation of an incompressible rubber block","text":""},{"location":"02_examples/incompressibleRubberBlock/#description","title":"Description","text":"<p><code>iks003_incompressible_LinearElasticity.cpp</code> uses finite element technology with displacement and pressure as independent degrees of freedom to simulate the deformation of an incompressible rubber block. The potential energy  for such a system is defined in the <code>Solid struct</code> by the function <code>calculateScalarImpl(const FERequirementType &amp;par, const Eigen::VectorX&lt;ScalarType&gt; &amp;dx)</code>.  This function uses the principles of automatic differentiation to provide the stiffness matrix and other necessary quantities to perform a static structural analysis.</p>"},{"location":"02_examples/incompressibleRubberBlock/#code-highlights","title":"Code highlights","text":"<p>The <code>struct</code> named <code>Solid</code> is created which is not inherited from any class. It is constructed as shown below: <pre><code>Solid(const Basis &amp;basis, const typename LocalView::Element &amp;element, double emod, double nu)\n    : localView_{basis.flat().localView()}, emod_{emod}, nu_{nu} {\n  localView_.bind(element);\n  mu_       = emod_ / (2 * (1 + nu_));\n  lambdaMat = convertLameConstants({.emodul = emod_, .nu = nu_}).toLamesFirstParameter();\n}\n</code></pre> It takes a reference to the basis function (<code>&amp;basis</code>), the element (<code>&amp;element</code>), and the material parameters, namely Young's modulus  (<code>emod</code>) and Poisson's ratio (<code>nu</code>), as arguments during construction. The function <code>convertLameConstants()</code> is a helper function to switch between the Lame parameters.</p> <p><code>ScalarType calculateScalarImpl(const FERequirementType &amp;par, const Eigen::VectorX&lt;ScalarType&gt; &amp;dx)</code> is  then defined, returning a scalar value, in this case the energy. The energy is then calculated as follows: <pre><code>energy += (0.5 * (2 * mu_ * symgradu.squaredNorm() - 1 / lambdaMat * Dune::power(pressure, 2)) + pressure * divU\n           - x.dot(fext))\n          * geo.integrationElement(gp.position()) * gp.weight();  // plane strain for 2D\n</code></pre> Here: </p> <ul> <li><code>symgradu</code> is the symmetric part of the gradient of displacements </li> <li><code>lambdaMat</code> is the first Lame parameter</li> <li><code>pressure</code> and <code>x</code> are the nodal pressure and current position, respectively</li> <li><code>divU</code> is the divergence of the displacement vector</li> <li><code>fext</code> is the external force vector</li> <li><code>gp.position()</code> and <code>gp.weight()</code> are the positions and weights from the quadrature rule</li> <li><code>geo.integrationElement()</code> returns the determinant of Jacobian required from the iso-parametric concept</li> </ul> <p>A Yasp 2D grid<sup>1</sup> is created of the size \\(L\\) x \\(h\\) with 20 elements in both directions, as shown below:  <pre><code>using Grid        = Dune::YaspGrid&lt;gridDim&gt;;\nconst double L    = 1;\nconst double h    = 1;\nconst size_t elex = 20;\nconst size_t eley = 20;\n\nDune::FieldVector&lt;double, 2&gt; bbox       = {L, h};\nstd::array&lt;int, 2&gt; elementsPerDirection = {elex, eley};\nauto grid                               = std::make_shared&lt;Grid&gt;(bbox, elementsPerDirection);\nauto gridView                           = grid-&gt;leafGridView();\n</code></pre> A linear Lagrangian basis is opted for the displacements and a constant basis for the pressure degrees of freedom using the <code>composite</code> basis feature from Dune, as shown below: <pre><code>auto basis = Ikarus::makeBasis(\ngridView, composite(power&lt;2&gt;(lagrange&lt;1&gt;()), lagrange&lt;0&gt;()));\n</code></pre> Here, <code>power&lt;2&gt;</code> is used to approximate the displacement field in both \\(x\\) and \\(y\\) directions. A vector of <code>Solid</code> finite elements that are decorated by <code>AutoDiffFE</code> are then constructed as shown below: <pre><code>std::vector&lt;AutoDiffFE&lt;Solid&lt;decltype(basis)&gt;&gt;&gt; fes;\nfor (auto &amp;ele : elements(gridView))\n  fes.emplace_back(basis, ele, Emod, nu);\n</code></pre> The displacement degrees of freedom at position \\(y=0\\) are fixed using the following snippet: <pre><code>auto basisP = std::make_shared&lt;const decltype(basis)&gt;(basis);\nIkarus::DirichletValues dirichletValues(basisP-&gt;flat());\ndirichletValues.fixDOFs([](auto &amp;basis_, auto &amp;dirichletFlags) {\n  Dune::Functions::forEachBoundaryDOF(subspaceBasis(basis_, _0),\n                   [&amp;](auto &amp;&amp;localIndex, auto &amp;&amp;localView, auto &amp;&amp;intersection) {\n                       if (std::abs(intersection.geometry().center()[1]) &lt; 1e-8)\n                         dirichletFlags[localView.index(localIndex)] = true;\n  });\n}); \n</code></pre> Here, all the element edges lying on the boundary of the physical domain are looped over and checked to see if the first index  of the center of the edge (<code>intersection.geometry().center()[1]</code>) is closer to zero. If this is the case, the corresponding displacement  degrees of freedom (obtained via <code>subspaceBasis(basis_, _0)</code>) are set to <code>true</code> and used by the assembler later.</p> <p>A <code>sparse</code> and a <code>dense</code> assembler are used to arrive at the stiffness matrix and the external load vector using the  finite element requirements as described here. <pre><code>auto sparseFlatAssembler = SparseFlatAssembler(fes, dirichletValues);\nauto denseFlatAssembler  = DenseFlatAssembler(fes, dirichletValues);\nauto req = FErequirements().addAffordance(Ikarus::AffordanceCollections::elastoStatics);\n\nauto fextFunction = [&amp;](auto &amp;&amp;lambdaLocal, auto &amp;&amp;dLocal) -&gt; auto &amp; {\n  req.insertGlobalSolution(Ikarus::FESolutions::displacement, dLocal)\n      .insertParameter(Ikarus::FEParameter::loadfactor, lambdaLocal);\n  return denseFlatAssembler.getReducedVector(req);\n};\nauto KFunction = [&amp;](auto &amp;&amp;lambdaLocal, auto &amp;&amp;dLocal) -&gt; auto &amp; {\n  req.insertGlobalSolution(Ikarus::FESolutions::displacement, dLocal)\n      .insertParameter(Ikarus::FEParameter::loadfactor, lambdaLocal);\n  return sparseFlatAssembler.getReducedMatrix(req);\n};\n</code></pre> The <code>SparseLU</code> package from the Eigen library is used to solve the linear system of equations. </p> <p>For post-processing, the function <code>Dune::Functions::makeDiscreteGlobalBasisFunction()</code> is used to create a function for  the displacements and pressure using the basis functions and the nodal values. <code>Dune::VTKWriter</code> is used to write  the <code>*.vtu</code> files. The results can then be plotted, for example, using Paraview. <pre><code>auto disp\n    = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;Dune::FieldVector&lt;double, 2&gt;&gt;(subspaceBasis(basis.flat(), _0), d);\nauto pressure = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;double&gt;(subspaceBasis(basis.flat(), _1), d);\nDune::VTKWriter vtkWriter(gridView, Dune::VTK::nonconforming);\nvtkWriter.addVertexData(disp, Dune::VTK::FieldInfo(\"displacement\", Dune::VTK::FieldInfo::Type::vector, 2));\nvtkWriter.addVertexData(pressure, Dune::VTK::FieldInfo(\"pressure\", Dune::VTK::FieldInfo::Type::scalar, 1));\nvtkWriter.write(\"iks003_incompressibleLinearElasticity\");\n</code></pre></p>"},{"location":"02_examples/incompressibleRubberBlock/#takeaways","title":"Takeaways","text":"<ul> <li><code>Ikarus::AutoDiffFE</code> can be used to arrive at the stiffness matrix and external load vector from the energy function.</li> <li>Easier implementation of mixed finite elements is possible due to the composite basis feature from Dune.</li> <li>Helper functions are included to switch between the Lame parameters.</li> <li>Grids from Dune can be directly incorporated within the Ikarus framework.</li> <li>Sparse and dense assemblers can be used to construct the global stiffness matrices and load vectors.</li> <li>Solvers from the Eigen library can be used to solve the linear system of equations.</li> <li>Post-processing can be done via Paraview after writing the <code>*.vtu</code> files using <code>Dune::VTKWriter</code>.</li> </ul> <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>"},{"location":"02_examples/kirchhoffPlate/","title":"Plate subjected to a surface load","text":""},{"location":"02_examples/kirchhoffPlate/#plate-subjected-to-a-surface-load","title":"Plate subjected to a surface load","text":""},{"location":"02_examples/kirchhoffPlate/#description","title":"Description","text":"<p>Kirchhoff-type plate element is implemented in <code>iks004_kirchhoffPlate.cpp</code> using the automatic differentiation technique as commented before. The basis used for discretization is a NURBS basis from the <code>dune-iga</code> module. The problem is solved, and convergence plots are created by comparing the solutions to the available analytical solutions for the simply supported case.</p>"},{"location":"02_examples/kirchhoffPlate/#code-highlights","title":"Code highlights","text":"<p>Similar to the <code>struct</code> named <code>Solid</code> in <code>iks003_incompressible_LinearElasticity.cpp</code>, here a <code>struct</code> named <code>KirchhoffPlate</code> is created. It inherits from <code>ScalarFieldFE</code> and it must be decorated with <code>AutoDiffFE</code> as well to compute the required matrices and vectors. It is constructed as shown below:</p> <p><pre><code>KirchhoffPlate(const Basis &amp;basis, const typename LocalView::Element &amp;element, double p_Emodul, double p_nu,\n               double p_thickness)\n    : BaseDisp(basis.flat(), element),\n      Emodul{p_Emodul},\n      nu{p_nu},\n      thickness{p_thickness} {\n  this-&gt;localView().bind(element);\n  geometry_.emplace(this-&gt;localView().element().geometry());\n}\n</code></pre> It takes in the <code>p_thickness</code> parameter in addition to the ones in <code>Solid</code>. Here, the energy is calculated as: <pre><code>energy += (0.5 * kappa.dot(D * kappa) - w * lambda) * geometry_-&gt;integrationElement(gp.position()) * gp.weight();\n</code></pre> with <code>kappa</code> being the vector of curvature containing \\(\\kappa_{xx}, \\kappa_{yy}\\) and \\(\\kappa_{xy}\\). If the boundaries  are clamped, the penalty method could be used, for example, to fix the derivatives of the displacements. Here, however, the example for the simply supported case is discussed further.</p> <p>A two-dimensional NURBS grid is created from the dune-iga module. </p> <pre><code>constexpr int griddim                                    = 2; // (1)! \nconstexpr int dimworld                                   = 2; // (2)! \nconst std::array&lt;std::vector&lt;double&gt;, griddim&gt; knotSpans = { { {0, 0, 1, 1}, {0, 0, 1, 1} } }; // (3)! \nusing ControlPoint = Dune::IGA::NURBSPatchData&lt;griddim, dimworld&gt;::ControlPointType;\nconst double Lx = 1; // (4)! \nconst double Ly = 1; // (5)! \n\nconst std::vector&lt;std::vector&lt;ControlPoint&gt;&gt; controlPoints\n    = { { {.p = {0, 0}, .w = 1}, {.p = {0, Ly}, .w = 1} }, \n        { {.p = {Lx, 0}, .w = 1}, {.p = {Lx, Ly}, .w = 1} } }; // (6)! \n\nstd::array&lt;int, griddim&gt; dimsize = {2, 2}; // (7)! \n\nauto controlNet = Dune::IGA::NURBSPatchData&lt;griddim, dimworld&gt;::ControlPointNetType(dimsize, controlPoints); // (8)!\nusing Grid      = Dune::IGA::NURBSGrid&lt;griddim, dimworld&gt;;\n\nDune::IGA::NURBSPatchData&lt;griddim, dimworld&gt; patchData;\n\npatchData.knotSpans     = knotSpans; // (9)! \npatchData.degree        = {1, 1}; // (10)! \npatchData.controlPoints = controlNet; // (11)! \npatchData = Dune::IGA::degreeElevate(patchData, 0, 1); // (12)! \npatchData = Dune::IGA::degreeElevate(patchData, 1, 1); // (13)! \nGrid grid(patchData); // (14)!\n</code></pre> <ol> <li>The dimension of the grid. Here, two-dimensional.</li> <li>The dimension of the physical space in which the grid lies (the embedding space of the grid). Here, two-dimensional.</li> <li>The knot vector for the NURBS grid.</li> <li>Length of the plate</li> <li>Width of the plate</li> <li>Control points and the weights for the square plate (the control points are ordered such that all the control points for a particular \\(x\\)-position are listed first, followed by the subsequent \\(x\\)-positions in ascending order).</li> <li>Number of control points in either direction.</li> <li>Creation of the control net.</li> <li>Binding the <code>knotSpans</code> to a particular NURBS <code>patchData</code>.</li> <li>The polynomial degree for the basis in either direction. It can also be calculated from the <code>knotSpans</code>.</li> <li>Binding the <code>controlNet</code> to a particular NURBS <code>patchData</code>.</li> <li>Elevating the polynomial degree for the <code>patchData</code> in \\(x\\)-direction (<code>0</code>) by 1.</li> <li>Elevating the polynomial degree for the <code>patchData</code> in \\(y\\)-direction (<code>1</code>) by 1.</li> <li>Creating the grid object from the patch data</li> </ol> <p>In order to obtain the convergence plots, the system is solved five times, with the refinement level  increasing by 1 each time using the command <code>grid.globalRefine(1);</code>. The NURBS basis can be obtained from the freestanding functions <code>nurbs()</code>, as shown below: <pre><code>auto basis = Ikarus::makeBasis(gridView, nurbs());\n</code></pre> This is followed by specifying the Dirichlet boundary conditions, creating the finite elements and the assembler,  solving the system of equations, and post-processing using Paraview as mentioned in the previous examples. The analytical solution for the simply supported case is adapted from  Wikipedia and is also mentioned below:  <pre><code>auto wAna = [&amp;](auto x) {\n  double w                = 0.0;\n  const int seriesFactors = 40;\n  const double pi         = std::numbers::pi;\n  auto oddFactors\n      = std::ranges::iota_view(1, seriesFactors) | std::views::filter([](auto i) { return i % 2 != 0; });\n  for (auto m : oddFactors)\n    for (auto n : oddFactors)\n      w += sin(m * pi * x[0] / Lx) * sin(n * pi * x[1] / Ly)\n           / (m * n * Dune::power(m * m / (Lx * Lx) + n * n / (Ly * Ly), 2));\n\n  return 16 * totalLoad / (Dune::power(pi, 6) * D) * w;\n};\n</code></pre> The <code>Dune::Functions::makeDiscreteGlobalBasisFunction</code> is used to create a function from the nodal finite element  solution of the displacements and the NURBS basis whereas the <code>Dune::Functions::makeAnalyticGridViewFunction</code> is  used to create a function by using the function to evaluate the analytical solutions and the <code>gridView</code> to get the position <code>x</code>. Local functions are then created that are used later to calculate the \\(L^2\\)-error. <pre><code>auto wGlobalFunction = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;Dune::FieldVector&lt;double, 1&gt;&gt;(basis.flat(), w);\nauto wGlobalAnalyticFunction = Dune::Functions::makeAnalyticGridViewFunction(wAna, gridView);\nauto localw                  = localFunction(wGlobalFunction);\nauto localwAna               = localFunction(wGlobalAnalyticFunction);\n</code></pre> The \\(L^2\\)-error is calculated by using  $$ L^2\\textrm{-error} = \\sqrt{\\sum_{ele} \\int_{\\Omega_{ele}} \\left( w_{analytical}-w_{FE} \\right)^2} $$  as shown below:  <pre><code>double l2_error = 0.0;\nfor (auto &amp;ele : elements(gridView)) {\n  localView.bind(ele);\n  localw.bind(ele);\n  localwAna.bind(ele);\n  const auto geo   = localView.element().geometry();\n  const auto &amp;rule = Dune::QuadratureRules&lt;double, 2&gt;::rule(ele.type(), 2 * localView.tree().finiteElement().localBasis().order());\n  for (auto gp : rule) {\n    const auto gpGlobalPos = geo.global(gp.position());\n\n    const auto w_ex = localwAna(gp.position());\n    const auto w_fe = localw(gp.position());\n    l2_error += Dune::power(w_ex - w_fe, 2) * ele.geometry().integrationElement(gp.position()) * gp.weight();\n  }\n}\nl2_error = std::sqrt(l2_error);\n</code></pre> The number of degrees of freedom for each refinement level and its corresponding \\(L^2\\)-error is pushed to a vector that  can be later used to create plots using the features from Matlab.   <pre><code>std::vector&lt;double&gt; dofsVec;\nstd::vector&lt;double&gt; l2Evcector;\ndofsVec.push_back(basis.flat().size());\nl2Evcector.push_back(l2_error);\n</code></pre></p>"},{"location":"02_examples/kirchhoffPlate/#takeaways","title":"Takeaways","text":"<ul> <li>NURBS grids can be created using the <code>dune-iga</code> module.</li> <li>The basis for the corresponding NURBS grid can be obtained using the <code>nurbs()</code> function.</li> <li>The Kirchhoff plate element can be easily implemented by evaluating the energy and using automatic differentiation methods.</li> <li>\\(L^2\\)-error can be evaluated to perform convergence studies.</li> </ul>"},{"location":"02_examples/newtonRaphsonMethod/","title":"Newton-Raphson method","text":""},{"location":"02_examples/newtonRaphsonMethod/#newton-raphson-method","title":"Newton-Raphson method","text":""},{"location":"02_examples/newtonRaphsonMethod/#description","title":"Description","text":"<p><code>iks005_newtonRaphson.cpp</code> shows a basic example of the Newton-Raphson method to solve a non-linear set of equations. A function that shows the algorithm explicitly is provided, and another function which is implemented in Ikarus is demonstrated. The function that depicts the Ikarus implementation uses a non-linear operator to perform the Newton-Raphson iterations. A logger can also be subscribed to in order to observe the residual norms, for instance.</p>"},{"location":"02_examples/newtonRaphsonMethod/#code-highlights","title":"Code highlights","text":"<p>Here, the <code>main()</code> function uses two functions, namely <code>void newtonRaphsonVeryBasicExample();</code> and <code>void newtonRaphsonBasicExampleWithLogger();</code>  that demonstrate the implementation of the Newton-Raphson scheme and also show the method to subscribe to loggers for information, respectively.  The function, which is solved in this example, and its derivative are mentioned below: <pre><code>auto f(double &amp;x) { return 0.5 * x * x + x - 2; }\nauto df(double &amp;x) { return x + 1; }\n</code></pre> First, the <code>void newtonRaphsonVeryBasicExample();</code> function is described.  The settings for the Newton-Raphson method are defined as: <pre><code>double x               = 13; // (1)!\nconst double eps       = 1e-10; // (2)!\nconst int maxIter      = 20; // (3)!\nconst double xExpected = std::sqrt(5.0) - 1.0; // (4)!\n</code></pre></p> <ol> <li>Starting point for the Newton-Raphson method to find the closest root</li> <li>Tolerance level below which the iterations stop</li> <li>Maximum number of iterations</li> <li>Expected value (analytical solution)</li> </ol> <p>Functors are created then to evaluate the function to be solved for and its derivative. These are then passed to the non-linear operator as shown below: <pre><code>auto fvLambda  = [&amp;](auto &amp;&amp;x) { return f(x); };\nauto dfvLambda = [&amp;](auto &amp;&amp;x) { return df(x); };\nIkarus::NonLinearOperator nonLinOp(Ikarus::functions(fvLambda, dfvLambda), Ikarus::parameter(x));\n</code></pre> The standard implementation of the Newton-Raphson method is illustrated in this function, which also uses <code>nonLinOp</code>. <pre><code>int iterCount = 1;\nwhile (abs(nonLinOp.value()) &gt; eps and iterCount &lt;= maxIter) {\n  x -= nonLinOp.value() / nonLinOp.derivative();\n  nonLinOp.updateAll();\n  iterCount++;\n\n  std::cout &lt;&lt; \"nonlinearOperator, value(): \" &lt;&lt; nonLinOp.value() &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"nonlinearOperator, x: \" &lt;&lt; nonLinOp.firstParameter() &lt;&lt; \"\\n\";\n}\n</code></pre> One could also use the existing functionality in Ikarus to obtain a similar solution from the Newton-Raphson scheme, as depicted below: <pre><code>Ikarus::NewtonRaphson nr(nonLinOp);\nnr.setup({eps, maxIter});\nconst auto solverInfo = nr.solve(x);\n\nstd::cout &lt;&lt; \"success: \" &lt;&lt; solverInfo.success &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"iterations: \" &lt;&lt; solverInfo.iterations &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"residuum: \" &lt;&lt; solverInfo.residualnorm &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"solution: \" &lt;&lt; x &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"expected solution: \" &lt;&lt; xExpected &lt;&lt; \"\\n\";\n</code></pre> Further details on the non-linear solver can be found here.</p> <p>Instead of using the multiple <code>std::cout</code> statements, one can simply subscribe for the desired information  using the functionalities from the observer module.  This is exemplified by the function <code>void newtonRaphsonBasicExampleWithLogger();</code> and the <code>class OurFirstObserver</code>. It is also possible to subscribe to the existing non-linear solver messages mentioned here. <pre><code>class OurFirstObserver : public IObserver&lt;NonLinearSolverMessages&gt; {\n public:\n  void updateImpl(NonLinearSolverMessages message) override {\n    if (message == NonLinearSolverMessages::ITERATION_STARTED) std::cout &lt;&lt; \"Iteration started.\\n\";\n  }\n};\n\nvoid newtonRaphsonBasicExampleWithLogger() {\n  double x               = 13;\n  const double eps       = 1e-10;\n  const int maxIter      = 20;\n  const double xExpected = std::sqrt(5.0) - 1.0;\n\n  auto fvLambda  = [&amp;](auto &amp;&amp;x) { return f(x); };\n  auto dfvLambda = [&amp;](auto &amp;&amp;x) { return df(x); };\n  Ikarus::NonLinearOperator nonLinOp(Ikarus::functions(fvLambda, dfvLambda), Ikarus::parameter(x));\n\n  Ikarus::NewtonRaphson nr(nonLinOp);\n  nr.setup({eps, maxIter});\n\n  auto ourSimpleObserver = std::make_shared&lt;OurFirstObserver&gt;();\n  nr.subscribe(NonLinearSolverMessages::ITERATION_STARTED, ourSimpleObserver);\n\n  const auto solverInfo = nr.solve(x);\n  if (solverInfo.success)\n    std::cout &lt;&lt; \"solution: \" &lt;&lt; x &lt;&lt; \"\\n\";\n  else\n    std::cout &lt;&lt; \"The Newton-Raphson procedure failed to converge\" &lt;&lt; std::endl;\n}\n</code></pre></p>"},{"location":"02_examples/newtonRaphsonMethod/#takeaways","title":"Takeaways","text":"<ul> <li>Functors for the function and its derivative can be used to create a simple non-linear operator.</li> <li>A <code>NewtonRaphson</code> object can be created using the non-linear operator.</li> <li>The settings for the Newton-Raphson scheme can be modified by using the <code>setup()</code> function.</li> <li>Nonlinear solver messages can be subscribed to print the desired quantities.</li> </ul>"},{"location":"02_examples/nonLinearElasticity/","title":"Non-linear elasticity for 2D solids","text":""},{"location":"02_examples/nonLinearElasticity/#non-linear-elasticity-for-2d-solids","title":"Non-linear Elasticity for 2D solids","text":""},{"location":"02_examples/nonLinearElasticity/#description","title":"Description","text":"<p>In <code>iks006_nonlinear2DSolid.cpp</code>, an automatic differentiation-based implementation is used to perform a non-linear analysis on a 2D block.  Various methods to obtain a 2D grid via Dune are also shown in the commented section at the beginning. Python is used to provide a Neumann boundary condition, providing a demonstration for the usage of  Python-based code within the Ikarus framework. The load control method is chosen as the desired control routine, and Newton-Raphson (or trust region methods) are used to solve the non-linear problem itself.</p>"},{"location":"02_examples/nonLinearElasticity/#code-highlights","title":"Code highlights","text":"<p>This example uses two macros, <code>gridType</code> and <code>solverType</code>, that are to be set as desired before executing the example. The <code>gridType</code> can be set to 0, 1, or 2, denoting an <code>ALUGrid</code>, a <code>YaspGrid</code>, and a <code>NURBSGrid</code> respectively. The <code>solverType</code> can be set to either 0 or 1 for <code>Newton-Raphson</code> and <code>Trust region</code> methods respectively.</p> <p>When <code>ALUGrid</code> is chosen, the mesh file <code>auxiliaryFiles/unstructuredTrianglesfine.msh</code> is read using <code>Dune::GmshReader</code>  and is then globally refined once. The <code>YaspGrid</code> created a square block of length 1 with 10 elements in either direction. The <code>NURBSGrid</code> also creates a square block of length 1 with a polynomial degree of 2 in both directions.  The block is subjected to a Neumann load on the right edge (\\(x=1\\)) that is incorporated using the dune-python interface as shown below: <pre><code>Dune::BitSetVector&lt;1&gt; neumannVertices(gridView.size(2), false);\nstd::string lambdaNeumannVertices = std::string(\"lambda x: ( x[0]&gt;0.999 )\");\n\nPython::start();\nPython::Reference main = Python::import(\"__main__\");\nPython::run(\"import math\");\nPython::runStream() &lt;&lt; std::endl &lt;&lt; \"import sys\" &lt;&lt; std::endl &lt;&lt; \"import os\" &lt;&lt; std::endl;\nauto pythonNeumannVertices = Python::make_function&lt;bool&gt;(Python::evaluate(lambdaNeumannVertices));\n\nfor (auto &amp;&amp;vertex : vertices(gridView)) {\n  bool isNeumann                          = pythonNeumannVertices(vertex.geometry().corner(0));\n  neumannVertices[indexSet.index(vertex)] = isNeumann;\n}\nBoundaryPatch&lt;decltype(gridView)&gt; neumannBoundary(gridView, neumannVertices);\n</code></pre> After the basis is defined, the non-linear elastic finite element is created as shown below: <pre><code>auto volumeLoad = [](auto &amp;globalCoord, auto &amp;lamb) {\n  Eigen::Vector2d fext;\n  fext.setZero();\n  return fext;\n};\n\nauto neumannBoundaryLoad = [](auto &amp;globalCoord, auto &amp;lamb) {\n  Eigen::Vector2d fext;\n  fext.setZero();\n  fext[1] = lamb / 40;\n  return fext;\n};\n\nauto matParameter = Ikarus::toLamesFirstParameterAndShearModulus({.emodul = 1000, .nu = 0.3});\n\nIkarus::StVenantKirchhoff matSVK(matParameter);\nauto reducedMat = planeStress(matSVK);\n\nstd::vector&lt;Ikarus::NonLinearElastic&lt;decltype(basis), decltype(reducedMat)&gt;&gt;&gt; fes;\nfor (auto &amp;element : elements(gridView))\n  fes.emplace_back(*basis, element, reducedMat, &amp;neumannBoundary, neumannBoundaryLoad, volumeLoad);\n</code></pre> The functors <code>volumeLoad</code> and <code>neumannBoundaryLoad</code> are used to obtain the external volume and surface loads acting on a particular position. We use a Saint Venant\u2013Kirchhoff material model, which we transform to a plane stress material law for our two-dimensional simulation. The line \\(y=0\\) is clamped by applying the Dirichlet boundary condition expressed below: <pre><code>auto basisP = std::make_shared&lt;const decltype(basis)&gt;(basis);\nIkarus::DirichletValues dirichletValues(basisP-&gt;flat());\n\ndirichletValues.fixBoundaryDOFs([&amp;](auto &amp;dirichletFlags, auto &amp;&amp;localIndex, auto &amp;&amp;localView, auto &amp;&amp;intersection) {\n  if (std::abs(intersection.geometry().center()[1]) &lt; 1e-8) dirichletFlags[localView.index(localIndex)] = true;\n});\n</code></pre> The finite element requirements are defined by using the affordance <code>Ikarus::AffordanceCollections::elastoStatics</code>. This is then used to create functors to get the stiffness matrix, residual vector, and energy value using a sparse assembler. A non-linear operator and the linear solver used by the <code>solverType</code> are defined as: <pre><code>auto nonLinOp = Ikarus::NonLinearOperator(functions(energyFunction, residualFunction, KFunction), parameter(d, lambda));\nauto linSolver = Ikarus::LinearSolver(Ikarus::SolverTypeTag::sd_UmfPackLU);\n</code></pre> An object for the Newton-Raphson method or the trust region method can then be defined as <pre><code>#if solverType == 0\n  auto nr = Ikarus::makeNewtonRaphson(nonLinOp.subOperator&lt;1, 2&gt;(), std::move(linSolver));\n#endif\n#if solverType == 1\n  auto nr = Ikarus::makeTrustRegion(nonLinOp);\n  nr-&gt;setup({.verbosity = 1,\n             .maxiter   = 30,\n             .grad_tol  = 1e-8,\n             .corr_tol  = 1e-8,\n             .useRand   = false,\n             .rho_reg   = 1e6,\n             .Delta0    = 1});\n#endif\n</code></pre> All the available output messages are subscribed to be displayed by using the following commands: <pre><code>auto nonLinearSolverObserver = std::make_shared&lt;NonLinearSolverLogger&gt;();\nnr-&gt;subscribeAll(nonLinearSolverObserver);\n</code></pre> The load control method is finally used as the path-following technique to solve this non-linear problem. It also subscribes to all the available information being written to the <code>vtkWriter</code>. Output files are written for the deformed configuration at every load step that can be visualized using Paraview. The load control method is executed by the following commands: <pre><code>auto lc = Ikarus::LoadControl(nr, 20, {0, 2000});\nlc.subscribeAll(vtkWriter);\nlc.run();\n</code></pre></p>"},{"location":"02_examples/nonLinearElasticity/#takeaways","title":"Takeaways","text":"<ul> <li>Grid types, finite element discretizations, and solver types are independent entities that are used to solve the problem at hand and can be switched easily to compare various formulations.</li> <li>The dune-python interface can be used to read external codes written in Python.</li> <li>A geometrically non-linear elastic finite element can be used from the Ikarus library.</li> <li>The Newton-Raphson and trust regions methods can be used as non-linear solvers.</li> <li>The load control method is used here as the path-following technique.</li> </ul>"},{"location":"02_examples/vonMisesTruss/","title":"Von Mises truss","text":""},{"location":"02_examples/vonMisesTruss/#von-mises-truss-calculation","title":"Von Mises truss calculation","text":""},{"location":"02_examples/vonMisesTruss/#description","title":"Description","text":"<p><code>iks007_vonMisesTruss.cpp</code> utilizes the tools and features mentioned in the previous examples to solve the  standard Von-Mises truss example found in literature (refer to Section 2<sup>1</sup>).</p>"},{"location":"02_examples/vonMisesTruss/#code-highlights","title":"Code highlights","text":"<p>The struct named <code>Truss</code> is created such that it inherits from <code>PowerBasisFE</code>. It must be decorated with <code>AutoDiffFE</code> as well to compute the stiffness matrix and load vectors during construction. It is constructed as shown below: <pre><code>Truss(const Basis &amp;basis, const typename LocalView::Element &amp;element, double p_EA)\n    : BaseDisp(basis.flat(), element), EA{p_EA} {\n  this-&gt;localView().bind(element);\n}\n</code></pre> It takes a reference to the basis function (<code>&amp;basis</code>), the element (<code>&amp;element</code>), and the axial stiffness of the  truss structure (<code>p_EA</code>) as arguments during construction.</p> <p><code>ScalarType calculateScalarImpl(const FERequirementType &amp;par, const Eigen::VectorX&lt;ScalarType&gt; &amp;dx)</code> is then defined, returning a scalar value, in this case the energy. The energy is defined as <code>0.5 * EA / sqrt(LRefsquared) * Egl * Egl</code> with <code>Egl</code> being the Green-Lagrange strain defined as <pre><code>const Scalar Egl = 0.5 * (lsquared - LRefsquared) / LRefsquared;\n</code></pre> The grid in this example is created explicitly. The grid is created here from the dune-foamgrid module. This allows the user to embed a one- or two-dimensional grid in a physical space of any dimension. Thus, here we embed  a one-dimensional truss system in a 2D plane. The height (<code>h</code>) and length (<code>L</code>) of the truss system are defined, which is followed by  the addition of the vertices and elements to create a grid as shown below: <pre><code>Dune::GridFactory&lt;Dune::FoamGrid&lt;1, 2, double&gt;&gt; gridFactory;\nconst double h = 1.0;\nconst double L = 1.0;\ngridFactory.insertVertex({0, 0});\ngridFactory.insertVertex({L, h});\ngridFactory.insertVertex({2 * L, 0});\ngridFactory.insertElement(Dune::GeometryTypes::line, {0, 1});\ngridFactory.insertElement(Dune::GeometryTypes::line, {1, 2});\nauto grid     = gridFactory.createGrid();\nauto gridView = grid-&gt;leafGridView();\n</code></pre> The Lagrange basis is used to approximate the displacement field. The <code>Truss</code> elements are then created, followed by the fixing of the  degrees of freedom at the boundaries (<code>{0,0}</code> and <code>{2 * L,0}</code>). A vertical downward load is applied to the center node. The non-linear operator is then constructed. The Newton-Raphson method is used as the non-linear solver, and an <code>nonLinearSolverObserver</code> is  created to write messages as desired by the non-linear solver. An additional <code>lvkObserver</code> is created using the <code>Ikarus::GenericControlObserver</code>  feature. This observer helps to fill up the matrix <code>lambdaAndDisp</code> with the load factor <code>lambda</code> and the two unconstrained degrees of freedom whenever  the solution is changed (<code>ControlMessages::SOLUTION_CHANGED</code>), which means that the Newton-Raphson method has converged to a solution. This is implemented as depicted in the following: <pre><code>const int loadSteps = 10;\nEigen::Matrix3Xd lambdaAndDisp;\nlambdaAndDisp.setZero(Eigen::NoChange, loadSteps + 1);\nauto lvkObserver = std::make_shared&lt;Ikarus::GenericControlObserver&gt;(ControlMessages::SOLUTION_CHANGED, [&amp;](int step) {\n  lambdaAndDisp(0, step) = lambda;\n  lambdaAndDisp(1, step) = d[2];\n  lambdaAndDisp(2, step) = d[3];\n});\n</code></pre> The load control method is used as the path-following strategy, and it is subscribed to both <code>vtkWriter</code> and <code>lvkObserver</code>. The features from Matplot++ are then used to plot the load-displacement curve from the matrix <code>lambdaAndDisp</code>.</p>"},{"location":"02_examples/vonMisesTruss/#takeaways","title":"Takeaways","text":"<ul> <li><code>Dune::FoamGrid</code> can be used to embed one or two-dimensional grid entities into a multi-dimensional physical space.</li> <li>A simple truss element can be constructed using the automatic differentiation procedure.</li> <li><code>Ikarus::GenericControlObserver</code> can be used to perform user-desired tasks at any desired point by observing a non-linear solver procedure.</li> </ul> <ol> <li> <p>R. V. Mises. \u00dcber die stabilit\u00e4tsprobleme der elastizit\u00e4tstheorie. ZAMM - Journal of Applied Mathematics and Mechanics / Zeitschrift f\u00fcr Angewandte Mathematik und Mechanik, 3(6):406\u2013422, 1923. doi:10.1002/zamm.19230030602.\u00a0\u21a9</p> </li> </ol>"},{"location":"03_contribution/buildDocumentationLocally/","title":"Build the documentation locally","text":""},{"location":"03_contribution/buildDocumentationLocally/#how-to-edit-this-documentation","title":"How to edit this documentation","text":""},{"location":"03_contribution/buildDocumentationLocally/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ikarus cloned on your computer,   see the download page.</li> </ul>"},{"location":"03_contribution/buildDocumentationLocally/#preview-the-documentation-locally","title":"Preview the documentation locally","text":"<ul> <li>Change the cmake option, for example, in Clion: Open <code>File --&gt; Settings --&gt; Build,Execution,Deployment --&gt; Cmake</code>.    Add <code>-DBUILD_DOCS=TRUE</code> to your cmake options    </li> <li>Choose target <code>localSite</code> and build it (for instance, click on the hammer)</li> </ul> <ul> <li>After a couple of seconds, build messages should appear that look similar to the picture below.   </li> <li>Click on <code>Services</code> in the footer, double-click on <code>Docker</code> and unfold <code>Containers</code>. There should be    one container with a blue box, while the other containers have a blue box with a white square inside   (see figure below). In this example, the container we are looking for is <code>elegant_bassi</code>.   The name will be different on your computer, but the relevant criterion for finding the container   is the blue box.   </li> <li>Click on the container with the blue box and navigate to <code>Port Bindings</code>.</li> <li>Add a new port by clicking on <code>+</code>, activate <code>Host port</code> under <code>Modify options</code> and enter   <code>8000</code> in both fields (see image below). Confirm with <code>OK</code>.   </li> <li>Click on <code>Save</code> in the lower right corner. This will restart the container. Messages will appear    saying that the build failed. These messages can be ignored. The build process restarts automatically.</li> <li>After a few seconds, Click on this link.</li> <li>Now you should see a live preview of the documentation in your browser.</li> <li>You can edit the documentation in CLion. <code>Ctrl</code> + <code>s</code> saves the documentation and updates it in   the browser window.</li> <li>Cancel the build process to stop the live preview. To restart the live preview, you will have to   modify the container settings again. Therefore, it is recommended to stop the live preview   only after you have finished working on the documentation. </li> </ul>"},{"location":"03_contribution/codeStyle/","title":"Code style","text":""},{"location":"03_contribution/codeStyle/#code-style","title":"Code style","text":"<p>This section explains some general implementational ideas used in  various parts of the code. It is dedicated to the users who would like to extend or modify the implemented functionality and/or would like to learn more about the implementation strategies and certain theoretical aspects.</p>"},{"location":"03_contribution/codeStyle/#general-remarks","title":"General remarks","text":"<ul> <li>The directories and filenames use <code>camelCase</code>.</li> <li>The source files and the header files have a <code>cpp</code> and a <code>hh</code> extension, respectively.</li> <li>A <code>clang-format</code> file is used, which needs to be executed in each extended or modified file before a PR can be merged.</li> <li>Readability and value semantics are the essence of the code.</li> <li>Classnames use <code>PascalCase</code></li> <li>Commenting within the code and the other code styles were influenced by the books by Robert C. Martin<sup>1</sup> and John K. Ousterhout<sup>2</sup>.</li> </ul> <ol> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>John K. Ousterhout. A Philosophy of Software Design. Yaknyam Press, 2021.\u00a0\u21a9</p> </li> </ol>"},{"location":"03_contribution/howToEdit/","title":"Edit the documentation","text":""},{"location":"03_contribution/howToEdit/#how-to-edit-this-documentation","title":"How to edit this documentation","text":""},{"location":"03_contribution/howToEdit/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ikarus cloned on your computer,    see the download page.</li> </ul>"},{"location":"03_contribution/howToEdit/#edit-a-page","title":"Edit a page","text":"<ul> <li>Open Ikarus</li> <li>Go to the folder <code>docs\\website</code></li> <li>Go to the Markdown file that corresponds to the page to be edited</li> <li>Apply your changes using any desired tool</li> <li>Create a pull request</li> <li>Once the pull request is accepted, the website is automatically updated</li> </ul>"},{"location":"03_contribution/howToEdit/#add-a-new-page","title":"Add a new page","text":"<ul> <li>Open Ikarus</li> <li>Go to the folder <code>docs\\website</code> and create a new Markdown file,    e.g. <code>MyAdditionalPage.md</code>. The new Markdown file could be added in any relevant existing folder or added to a new folder starting with a consecutive folder number, e.g., <code>XX_myFolder</code> </li> <li>Open the file <code>docs\\mkdocs.yml</code></li> <li>Find the navigation section which starts with <code># Navigation</code></li> <li>The navigation section describes the navigation on the left side of the website. Add <code>XX_myFolder/MyAdditionalPage.md</code> where you want it to appear</li> <li>Create a pull request</li> <li>Once the pull request is accepted, the website is automatically updated</li> </ul>"},{"location":"03_contribution/howToEdit/#insert-a-latex-formula","title":"Insert a LaTeX formula","text":"<p>The Markdown format:</p> <p><code>$$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$</code> </p> <p>The compiled output:</p> \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\]"},{"location":"03_contribution/howToEdit/#insert-a-c-code","title":"Insert a C++ code","text":"<p>The Markdown format: <pre><code>    ```cpp\n    double complicatedCalculation(double number, double anotherNumber) \n    {\n      return number*anotherNumber;\n    };\n    ```\n</code></pre></p> <p>The compiled output:</p> <pre><code>double complicatedCalculation(double number, double anotherNumber) \n{\n  return number*anotherNumber;\n};\n</code></pre>"},{"location":"03_contribution/howToEdit/#insert-tables-warnings-and-notes","title":"Insert tables, warnings and notes","text":"<p>Look at the Markdown file (<code>03_contribution/howToEdit.md</code>) to see how tables, warnings and notes can be inserted.</p> Grid Entity Interface <code>GridViewType leafGridView()</code> <code>GridViewType levelGridView(int level)</code> <p>Insert a warning</p> <p>Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly.</p> <p>References</p> <p>For available features in the documentation see Mkdocs-Material and Mkdocs.</p>"},{"location":"03_contribution/openTask/","title":"Open Tasks","text":""},{"location":"03_contribution/openTask/#open-tasks","title":"Open tasks","text":"<p>Thank you for your interest in contributing to this code base. The following task are open for your contributions.</p>"},{"location":"03_contribution/openTask/#local-functions","title":"Local functions","text":"<ul> <li> <p>Implementing a unit normal field function<sup>1</sup> and its derivatives w.r.t. its coefficients \\( \\boldsymbol{x}_i \\)</p> \\[  \\boldsymbol{n} = \\frac{\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2}{||\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2||}, \\quad \\text{with } \\boldsymbol{a}_{\\alpha} = \\sum_{i=1}^n N^i_{,\\alpha}(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\] <p>To implement this, see link.</p> </li> <li> <p>Support second derivatives</p> </li> <li>Add \\( \\operatorname{div} \\) and \\( \\operatorname{curl} \\) wrapper</li> </ul>"},{"location":"03_contribution/openTask/#control-routines","title":"Control routines","text":"<ul> <li>Dynamics (Explicit/ implicit time stepping)</li> </ul>"},{"location":"03_contribution/openTask/#control-routines-addons","title":"Control routines - addons","text":"<ul> <li>Extended systems</li> <li>Nonlinear dependence of \\(F_{ext}\\) on \\(\\mathbf{D}\\) and \\(\\lambda\\) for path-following techniques, see control routines.</li> </ul>"},{"location":"03_contribution/openTask/#finite-element-helper","title":"Finite element helper","text":"<ul> <li>Implement a default mass matrix</li> </ul>"},{"location":"03_contribution/openTask/#finite-elements","title":"Finite elements","text":"<ul> <li>Nonlinear Reissner-Mindlin shell <sup>2</sup></li> <li>Kirchhoff-Love shell</li> <li>3D-Beam</li> <li>Standard beam and plate formulations</li> <li>Add calculation of different stress measures (push-forward or pull-back of PK2 stresses or similar)</li> </ul>"},{"location":"03_contribution/openTask/#further-addons","title":"Further addons","text":"<ul> <li>Muesli</li> </ul> <p>Code style</p> <p>For details on the code style, refer link.</p> <ol> <li> <p>This is usually needed for a Kirchhoff-Love shell implementation, see <sup>3</sup>.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> <li> <p>J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering, 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013.\u00a0\u21a9</p> </li> </ol>"},{"location":"04_blog/","title":"Blog","text":""},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/","title":"Release of v0.3 (Prometheus)","text":"<p>We are happy to announce that Ikarus has made it to version 0.3. In this version, some new features are added,  and maintenance-related fixes have been done by us (Tarun and Alex). We are moving forward to the first version (v1.0) release,  and we consider v0.3 to be a bigger milestone.</p> <p>As this is the first blog, we would like to start by sharing the thoughts behind the reasons for creating Ikarus. Being  researchers ourselves, we found it motivating to have an independent code for investigating various aspects of  computational mechanics. On that note, we proceeded with the finite element approach to implement a generic  code for solving partial differential equations, which was inspired by generic algorithms.  Consequently, Ikarus was born, granting us the wings to perform intensive research in this field.  It is basically a C++ library, providing several features to carry out finite element analysis.</p> <p>During the development phase, we were always asked two questions: \"How to use Ikarus?\" and \"Why to use Ikarus when  there are so many other tools to perform a finite element analysis\"? To address such concerns, we attempted to make  things easier for users in this version by automating several workflows on GitHub, updating the documentation, and  adding some concepts from finite element fundamentals with relevant examples. To be specific, the major concern was  easy-to-read documentation. We hope that good documentation  will motivate us to make even better documentation, in the spirit of an \"inverse\"  broken windows theory. A quick overview of this version is provided in the following text.</p> <p> </p> Prometheus brings fire to humanity by Heinrich F\u00fcger"},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/#workflows","title":"Workflows","text":"<p>A workflow for codespell has been created in order to have a smarter  CI. This workflow is executed on GitHub after every commit is pushed. The CI has now the capability to check grammar and  typographical errors in comments and variable names. The examples, which resided earlier in the repository of Ikarus,  have now been moved to a new repository. The users can thereby just use Ikarus as an external finite element library by installing  it, followed by the execution of their own simulations. A workflow is created that checks if all the examples are working with  every commit to the <code>main</code> branch of Ikarus. This ensures the proper functioning of the existing examples in Ikarus  during the development of newer features. Docker images are automatically generated as well for systems with Ikarus  installed, with commits to the <code>main</code> branch. The Docker images make it even easier to use Ikarus because no additional  software is required. A license statement is also added to each file, and the license files  themselves are separated into a separate folder. A workflow also checks for the inclusion of the license statement in  the files associated with Ikarus. Moreover, we created a workflow that automatically creates a release on GitHub  and pushes it to DaRUS,  enabling us to assign a DOI to the current version.</p>"},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/#finite-element-technology","title":"Finite element technology","text":"<p>A beginner to finite element technology, in the context of computational solid mechanics, always starts with simulations in the  linear-elastic regime. This instilled us with the desire to incorporate this element technology into Ikarus in a sophisticated  way. As a result, we implemented a template-based code that enables the users to utilize the linear-elastic finite  elements in single and multi-dimensions for various geometries with lesser modifications to the code. To avoid locking characteristics, the elements can also be decorated with the enhanced assumed strain (EAS) concept. A variety of examples,  including the famous Cook's membrane problem, are made available to learn the implementation styles of Ikarus. This was  followed by adding path-following techniques, which use a scalar subsidiary function to also solve non-linear problems.  Furthermore, an additional class was added to handle homogeneous and inhomogeneous Dirichlet boundary conditions.  A set of local functions that enable efficient implementation of finite elements are also moved to a separate repository  for easier code handling and faster workflow processing in Ikarus.</p>"},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/#documentation-and-social-media","title":"Documentation and social media","text":"<p>For a better understanding of Ikarus, the entire documentation has been refactored with grammatical corrections and the  inclusion of relevant information while excluding the unnecessary parts. Installation instructions, blog capabilities, and brief explanations of examples are added. Additionally, the snow plug-in from Material for MkDocs is included for this release as a seasonal plug-in. Links to the Ikarus developers' social media accounts can also be found on the bottom-right side of the page.  Finally, a Gitter community is formed in order to interact more with users and quickly resolve issues.</p>"},{"location":"04_blog/2022/12/16/release-of-v03-prometheus/#what-next","title":"What next?","text":"<p>The following are some key milestones that have been completed or are planned to be released as stepping stones to version 1.0.</p> <ul> <li> <p> Workflows</p> <ul> <li> License and example checks (#107 and #114)</li> <li> Create Docker images</li> <li> Create a workflow to create a \"release\" and add a version to DaRUS</li> <li> Deploy Python bindings to PyPi and create Python bindings</li> </ul> </li> <li> <p> Finite element technology</p> <ul> <li> Linear elastic finite elements with EAS (#74)</li> <li> Path-following techniques (#80)</li> <li> Efficient implementation of non-linear elasticity</li> <li> Standard plate and beam elements</li> <li> Handling inhomogeneous Dirichlet boundary conditions in all existing solving methods</li> <li> Include a mechanical-material library</li> <li> Linear dynamics</li> <li> More supporting examples</li> </ul> </li> <li> <p> Documentation</p> <ul> <li> Improving existing documentation and describing examples of Ikarus (#106 and #125)</li> <li> Detailed explanations of examples in Ikarus</li> <li> Implementation of linear and non-linear elasticity</li> <li> Logo and gallery</li> </ul> </li> </ul>"},{"location":"05_cppReferences/cppRef/","title":"C++ recommendations","text":""},{"location":"05_cppReferences/cppRef/#c-recommendations","title":"C++ recommendations","text":"<p>Since Ikarus is written in C++, we summarize our recommendations to dig deeper into C++ coding on this page.</p>"},{"location":"05_cppReferences/cppRef/#best-practices","title":"Best practices","text":"<ol> <li>C++ Core Guidelines</li> <li>Jason Turner's collection of best practices</li> <li>More C++ idioms</li> </ol>"},{"location":"05_cppReferences/cppRef/#videos","title":"Videos","text":"<p>Here we collect some useful videos on general coding or coding with C++:</p> <ol> <li>Clean Code - Uncle Bob / Lesson 1 - How to write code cleanly, see also <sup>1</sup></li> <li>CppCon 2014: Herb Sutter \"Back to the Basics! Essentials of Modern C++ Style\"</li> <li>CppCon 2018: Jonathan Boccara \u201c105 STL Algorithms in Less Than an Hour\u201d - \"Almost\" all algorithms in the STL</li> <li>Back to Basics: Object-Oriented Programming - Jon Kalb - CppCon 2019 - How to do modern \"Object-Oriented Programming\" (if you really have to)</li> <li>CppCon 2021 - Back To Basics</li> <li>CppCon 2019 - Back to Basics</li> </ol>"},{"location":"05_cppReferences/cppRef/#books","title":"Books","text":"<ol> <li>[Meyers S. 1995]<sup>2</sup></li> <li>[Gamma E. et al. 1995]<sup>3</sup></li> <li>[Meyers S. 2005]<sup>4</sup></li> <li>[Reddy M. 2011]<sup>5</sup></li> <li>[Iglberger K. 2022]<sup>6</sup></li> </ol>"},{"location":"05_cppReferences/cppRef/#further-references","title":"Further references","text":"<ol> <li>Cppcon Videos - These videos are released after every C++ conference. For beginners, the \"Back to basics\" track is recommended.</li> <li>Godblot - Online compiler with assembler output. It's useful to quickly determine whether something will be fast or slow.    Furthermore, libraries like Eigen can be added. Also, any other header files found on the internet can be included with the link.</li> <li>Blog by Arthur O'Dwyer</li> </ol> <ol> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version. Pearson Education, 1995.\u00a0\u21a9</p> </li> <li> <p>Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH, 1995.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs. Pearson Education, 2005.\u00a0\u21a9</p> </li> <li> <p>Martin Reddy. API Design for C++. Elsevier, 2011.\u00a0\u21a9</p> </li> <li> <p>Klaus Iglberger. C++ Software Design: Design Principles and Patterns for High-Quality Software. O'Reilly, 2022.\u00a0\u21a9</p> </li> </ol>"},{"location":"99_Literature/99_Literature/","title":"Literature","text":""},{"location":"99_Literature/99_Literature/#literature","title":"Literature","text":"<ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>Gerald A. Wempner. Discrete approximations related to nonlinear theories of solids. International Journal of Solids and Structures, 7(11):1581\u20131599, 1971. doi:10.1016/0020-7683(71)90038-2.\u00a0\u21a9</p> </li> <li> <p>M.A. Crisfield. A fast incremental/iterative solution procedure that handles \u201csnap-through\u201d. Computers &amp; Structures, 13(1):55\u201362, 1981. doi:10.1016/0045-7949(81)90108-5.\u00a0\u21a9</p> </li> <li> <p>E. Ramm. Strategies for Tracing the Nonlinear Response Near Limit Points. In W. Wunderlich, E. Stein, and K.-J. Bathe, editors, Nonlinear Finite Element Analysis in Structural Mechanics, pages 63\u201389. Springer Berlin Heidelberg, Berlin, Heidelberg, 1981. doi:10.1007/978-3-642-81589-8_5.\u00a0\u21a9</p> </li> <li> <p>E. Riks. The Application of Newton\u2019s Method to the Problem of Elastic Stability. Journal of Applied Mechanics, 39(4):1060\u20131065, 1972. doi:10.1115/1.3422829.\u00a0\u21a9</p> </li> <li> <p>J. C. Simo and M. S. Rifai. A class of mixed assumed strain methods and the method of incompatible modes. Int. J. Numer. Meth. Engng., 29(8):1595\u20131638, June 1990. doi:10.1002/nme.1620290802.\u00a0\u21a9</p> </li> <li> <p>U. Andelfinger and E. Ramm. EAS-elements for two-dimensional, three-dimensional, plate and shell structures and their equivalence to HR-elements. International Journal for Numerical Methods in Engineering, 36(8):1311\u20131337, 1993. doi:10.1002/nme.1620360805.\u00a0\u21a9</p> </li> <li> <p>J. Austin Cottrell, Thomas J. R. Hughes, and Yuri Bazilevs. Isogeometric Analysis: Toward Integration of CAD and FEA. Wiley, 2009.\u00a0\u21a9</p> </li> <li> <p>Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal, 57(1):404\u2013428, 2019. doi:10.1137/18M1176798.\u00a0\u21a9</p> </li> <li> <p>Oliver Sander. Geodesic finite elements for cosserat rods. International Journal for Numerical Methods in Engineering, 82(13):1645\u20131670, 2010. doi:10.1002/nme.2814.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> <li> <p>Robert D. Cook. Improved Two-Dimensional Finite Element. J. Struct. Div., 100(9):1851\u20131863, September 1974. doi:10.1061/JSDEAG.0003877.\u00a0\u21a9</p> </li> <li> <p>R. V. Mises. \u00dcber die stabilit\u00e4tsprobleme der elastizit\u00e4tstheorie. ZAMM - Journal of Applied Mathematics and Mechanics / Zeitschrift f\u00fcr Angewandte Mathematik und Mechanik, 3(6):406\u2013422, 1923. doi:10.1002/zamm.19230030602.\u00a0\u21a9</p> </li> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>John K. Ousterhout. A Philosophy of Software Design. Yaknyam Press, 2021.\u00a0\u21a9</p> </li> <li> <p>J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering, 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version. Pearson Education, 1995.\u00a0\u21a9</p> </li> <li> <p>Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH, 1995.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs. Pearson Education, 2005.\u00a0\u21a9</p> </li> <li> <p>Martin Reddy. API Design for C++. Elsevier, 2011.\u00a0\u21a9</p> </li> <li> <p>Klaus Iglberger. C++ Software Design: Design Principles and Patterns for High-Quality Software. O'Reilly, 2022.\u00a0\u21a9</p> </li> </ol>"},{"location":"04_blog/archive/2022/","title":"2022","text":""},{"location":"04_blog/category/prometheus/","title":"Prometheus","text":""},{"location":"04_blog/category/path-following/","title":"Path-following","text":""},{"location":"04_blog/category/documentation/","title":"Documentation","text":""},{"location":"04_blog/category/release/","title":"Release","text":""},{"location":"04_blog/category/linear-elasticity/","title":"Linear elasticity","text":""},{"location":"04_blog/category/docker-images/","title":"Docker images","text":""},{"location":"04_blog/category/licenses/","title":"Licenses","text":""}]}